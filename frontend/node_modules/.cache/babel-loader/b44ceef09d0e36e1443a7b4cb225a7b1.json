{"ast":null,"code":"'use strict';\n\nconst MiniPass = require('minipass');\n\nconst EE = require('events').EventEmitter;\n\nconst fs = require('fs'); // for writev\n\n\nconst binding = process.binding('fs');\nconst writeBuffers = binding.writeBuffers;\n/* istanbul ignore next */\n\nconst FSReqWrap = binding.FSReqWrap || binding.FSReqCallback;\n\nconst _autoClose = Symbol('_autoClose');\n\nconst _close = Symbol('_close');\n\nconst _ended = Symbol('_ended');\n\nconst _fd = Symbol('_fd');\n\nconst _finished = Symbol('_finished');\n\nconst _flags = Symbol('_flags');\n\nconst _flush = Symbol('_flush');\n\nconst _handleChunk = Symbol('_handleChunk');\n\nconst _makeBuf = Symbol('_makeBuf');\n\nconst _mode = Symbol('_mode');\n\nconst _needDrain = Symbol('_needDrain');\n\nconst _onerror = Symbol('_onerror');\n\nconst _onopen = Symbol('_onopen');\n\nconst _onread = Symbol('_onread');\n\nconst _onwrite = Symbol('_onwrite');\n\nconst _open = Symbol('_open');\n\nconst _path = Symbol('_path');\n\nconst _pos = Symbol('_pos');\n\nconst _queue = Symbol('_queue');\n\nconst _read = Symbol('_read');\n\nconst _readSize = Symbol('_readSize');\n\nconst _reading = Symbol('_reading');\n\nconst _remain = Symbol('_remain');\n\nconst _size = Symbol('_size');\n\nconst _write = Symbol('_write');\n\nconst _writing = Symbol('_writing');\n\nconst _defaultFlag = Symbol('_defaultFlag');\n\nclass ReadStream extends MiniPass {\n  constructor(path, opt) {\n    opt = opt || {};\n    super(opt);\n    this.writable = false;\n    if (typeof path !== 'string') throw new TypeError('path must be a string');\n    this[_fd] = typeof opt.fd === 'number' ? opt.fd : null;\n    this[_path] = path;\n    this[_readSize] = opt.readSize || 16 * 1024 * 1024;\n    this[_reading] = false;\n    this[_size] = typeof opt.size === 'number' ? opt.size : Infinity;\n    this[_remain] = this[_size];\n    this[_autoClose] = typeof opt.autoClose === 'boolean' ? opt.autoClose : true;\n    if (typeof this[_fd] === 'number') this[_read]();else this[_open]();\n  }\n\n  get fd() {\n    return this[_fd];\n  }\n\n  get path() {\n    return this[_path];\n  }\n\n  write() {\n    throw new TypeError('this is a readable stream');\n  }\n\n  end() {\n    throw new TypeError('this is a readable stream');\n  }\n\n  [_open]() {\n    fs.open(this[_path], 'r', (er, fd) => this[_onopen](er, fd));\n  }\n\n  [_onopen](er, fd) {\n    if (er) this[_onerror](er);else {\n      this[_fd] = fd;\n      this.emit('open', fd);\n\n      this[_read]();\n    }\n  }\n\n  [_makeBuf]() {\n    return Buffer.allocUnsafe(Math.min(this[_readSize], this[_remain]));\n  }\n\n  [_read]() {\n    if (!this[_reading]) {\n      this[_reading] = true;\n\n      const buf = this[_makeBuf]();\n      /* istanbul ignore if */\n\n\n      if (buf.length === 0) return process.nextTick(() => this[_onread](null, 0, buf));\n      fs.read(this[_fd], buf, 0, buf.length, null, (er, br, buf) => this[_onread](er, br, buf));\n    }\n  }\n\n  [_onread](er, br, buf) {\n    this[_reading] = false;\n    if (er) this[_onerror](er);else if (this[_handleChunk](br, buf)) this[_read]();\n  }\n\n  [_close]() {\n    if (this[_autoClose] && typeof this[_fd] === 'number') {\n      fs.close(this[_fd], _ => this.emit('close'));\n      this[_fd] = null;\n    }\n  }\n\n  [_onerror](er) {\n    this[_reading] = true;\n\n    this[_close]();\n\n    this.emit('error', er);\n  }\n\n  [_handleChunk](br, buf) {\n    let ret = false; // no effect if infinite\n\n    this[_remain] -= br;\n    if (br > 0) ret = super.write(br < buf.length ? buf.slice(0, br) : buf);\n\n    if (br === 0 || this[_remain] <= 0) {\n      ret = false;\n\n      this[_close]();\n\n      super.end();\n    }\n\n    return ret;\n  }\n\n  emit(ev, data) {\n    switch (ev) {\n      case 'prefinish':\n      case 'finish':\n        break;\n\n      case 'drain':\n        if (typeof this[_fd] === 'number') this[_read]();\n        break;\n\n      default:\n        return super.emit(ev, data);\n    }\n  }\n\n}\n\nclass ReadStreamSync extends ReadStream {\n  [_open]() {\n    let threw = true;\n\n    try {\n      this[_onopen](null, fs.openSync(this[_path], 'r'));\n\n      threw = false;\n    } finally {\n      if (threw) this[_close]();\n    }\n  }\n\n  [_read]() {\n    let threw = true;\n\n    try {\n      if (!this[_reading]) {\n        this[_reading] = true;\n\n        do {\n          const buf = this[_makeBuf]();\n          /* istanbul ignore next */\n\n\n          const br = buf.length === 0 ? 0 : fs.readSync(this[_fd], buf, 0, buf.length, null);\n          if (!this[_handleChunk](br, buf)) break;\n        } while (true);\n\n        this[_reading] = false;\n      }\n\n      threw = false;\n    } finally {\n      if (threw) this[_close]();\n    }\n  }\n\n  [_close]() {\n    if (this[_autoClose] && typeof this[_fd] === 'number') {\n      try {\n        fs.closeSync(this[_fd]);\n      } catch (er) {}\n\n      this[_fd] = null;\n      this.emit('close');\n    }\n  }\n\n}\n\nclass WriteStream extends EE {\n  constructor(path, opt) {\n    opt = opt || {};\n    super(opt);\n    this.readable = false;\n    this[_writing] = false;\n    this[_ended] = false;\n    this[_needDrain] = false;\n    this[_queue] = [];\n    this[_path] = path;\n    this[_fd] = typeof opt.fd === 'number' ? opt.fd : null;\n    this[_mode] = opt.mode === undefined ? 0o666 : opt.mode;\n    this[_pos] = typeof opt.start === 'number' ? opt.start : null;\n    this[_autoClose] = typeof opt.autoClose === 'boolean' ? opt.autoClose : true; // truncating makes no sense when writing into the middle\n\n    const defaultFlag = this[_pos] !== null ? 'r+' : 'w';\n    this[_defaultFlag] = opt.flags === undefined;\n    this[_flags] = this[_defaultFlag] ? defaultFlag : opt.flags;\n    if (this[_fd] === null) this[_open]();\n  }\n\n  get fd() {\n    return this[_fd];\n  }\n\n  get path() {\n    return this[_path];\n  }\n\n  [_onerror](er) {\n    this[_close]();\n\n    this[_writing] = true;\n    this.emit('error', er);\n  }\n\n  [_open]() {\n    fs.open(this[_path], this[_flags], this[_mode], (er, fd) => this[_onopen](er, fd));\n  }\n\n  [_onopen](er, fd) {\n    if (this[_defaultFlag] && this[_flags] === 'r+' && er && er.code === 'ENOENT') {\n      this[_flags] = 'w';\n\n      this[_open]();\n    } else if (er) this[_onerror](er);else {\n      this[_fd] = fd;\n      this.emit('open', fd);\n\n      this[_flush]();\n    }\n  }\n\n  end(buf, enc) {\n    if (buf) this.write(buf, enc);\n    this[_ended] = true; // synthetic after-write logic, where drain/finish live\n\n    if (!this[_writing] && !this[_queue].length && typeof this[_fd] === 'number') this[_onwrite](null, 0);\n  }\n\n  write(buf, enc) {\n    if (typeof buf === 'string') buf = new Buffer(buf, enc);\n\n    if (this[_ended]) {\n      this.emit('error', new Error('write() after end()'));\n      return false;\n    }\n\n    if (this[_fd] === null || this[_writing] || this[_queue].length) {\n      this[_queue].push(buf);\n\n      this[_needDrain] = true;\n      return false;\n    }\n\n    this[_writing] = true;\n\n    this[_write](buf);\n\n    return true;\n  }\n\n  [_write](buf) {\n    fs.write(this[_fd], buf, 0, buf.length, this[_pos], (er, bw) => this[_onwrite](er, bw));\n  }\n\n  [_onwrite](er, bw) {\n    if (er) this[_onerror](er);else {\n      if (this[_pos] !== null) this[_pos] += bw;\n      if (this[_queue].length) this[_flush]();else {\n        this[_writing] = false;\n\n        if (this[_ended] && !this[_finished]) {\n          this[_finished] = true;\n\n          this[_close]();\n\n          this.emit('finish');\n        } else if (this[_needDrain]) {\n          this[_needDrain] = false;\n          this.emit('drain');\n        }\n      }\n    }\n  }\n\n  [_flush]() {\n    if (this[_queue].length === 0) {\n      if (this[_ended]) this[_onwrite](null, 0);\n    } else if (this[_queue].length === 1) this[_write](this[_queue].pop());else {\n      const iovec = this[_queue];\n      this[_queue] = [];\n      writev(this[_fd], iovec, this[_pos], (er, bw) => this[_onwrite](er, bw));\n    }\n  }\n\n  [_close]() {\n    if (this[_autoClose] && typeof this[_fd] === 'number') {\n      fs.close(this[_fd], _ => this.emit('close'));\n      this[_fd] = null;\n    }\n  }\n\n}\n\nclass WriteStreamSync extends WriteStream {\n  [_open]() {\n    let fd;\n\n    try {\n      fd = fs.openSync(this[_path], this[_flags], this[_mode]);\n    } catch (er) {\n      if (this[_defaultFlag] && this[_flags] === 'r+' && er && er.code === 'ENOENT') {\n        this[_flags] = 'w';\n        return this[_open]();\n      } else throw er;\n    }\n\n    this[_onopen](null, fd);\n  }\n\n  [_close]() {\n    if (this[_autoClose] && typeof this[_fd] === 'number') {\n      try {\n        fs.closeSync(this[_fd]);\n      } catch (er) {}\n\n      this[_fd] = null;\n      this.emit('close');\n    }\n  }\n\n  [_write](buf) {\n    try {\n      this[_onwrite](null, fs.writeSync(this[_fd], buf, 0, buf.length, this[_pos]));\n    } catch (er) {\n      this[_onwrite](er, 0);\n    }\n  }\n\n}\n\nconst writev = (fd, iovec, pos, cb) => {\n  const done = (er, bw) => cb(er, bw, iovec);\n\n  const req = new FSReqWrap();\n  req.oncomplete = done;\n  binding.writeBuffers(fd, iovec, pos, req);\n};\n\nexports.ReadStream = ReadStream;\nexports.ReadStreamSync = ReadStreamSync;\nexports.WriteStream = WriteStream;\nexports.WriteStreamSync = WriteStreamSync;","map":{"version":3,"sources":["/home/n/React/loginpagedemo/frontend/node_modules/tar/node_modules/fs-minipass/index.js"],"names":["MiniPass","require","EE","EventEmitter","fs","binding","process","writeBuffers","FSReqWrap","FSReqCallback","_autoClose","Symbol","_close","_ended","_fd","_finished","_flags","_flush","_handleChunk","_makeBuf","_mode","_needDrain","_onerror","_onopen","_onread","_onwrite","_open","_path","_pos","_queue","_read","_readSize","_reading","_remain","_size","_write","_writing","_defaultFlag","ReadStream","constructor","path","opt","writable","TypeError","fd","readSize","size","Infinity","autoClose","write","end","open","er","emit","Buffer","allocUnsafe","Math","min","buf","length","nextTick","read","br","close","_","ret","slice","ev","data","ReadStreamSync","threw","openSync","readSync","closeSync","WriteStream","readable","mode","undefined","start","defaultFlag","flags","code","enc","Error","push","bw","pop","iovec","writev","WriteStreamSync","writeSync","pos","cb","done","req","oncomplete","exports"],"mappings":"AAAA;;AACA,MAAMA,QAAQ,GAAGC,OAAO,CAAC,UAAD,CAAxB;;AACA,MAAMC,EAAE,GAAGD,OAAO,CAAC,QAAD,CAAP,CAAkBE,YAA7B;;AACA,MAAMC,EAAE,GAAGH,OAAO,CAAC,IAAD,CAAlB,C,CAEA;;;AACA,MAAMI,OAAO,GAAGC,OAAO,CAACD,OAAR,CAAgB,IAAhB,CAAhB;AACA,MAAME,YAAY,GAAGF,OAAO,CAACE,YAA7B;AACA;;AACA,MAAMC,SAAS,GAAGH,OAAO,CAACG,SAAR,IAAqBH,OAAO,CAACI,aAA/C;;AAEA,MAAMC,UAAU,GAAGC,MAAM,CAAC,YAAD,CAAzB;;AACA,MAAMC,MAAM,GAAGD,MAAM,CAAC,QAAD,CAArB;;AACA,MAAME,MAAM,GAAGF,MAAM,CAAC,QAAD,CAArB;;AACA,MAAMG,GAAG,GAAGH,MAAM,CAAC,KAAD,CAAlB;;AACA,MAAMI,SAAS,GAAGJ,MAAM,CAAC,WAAD,CAAxB;;AACA,MAAMK,MAAM,GAAGL,MAAM,CAAC,QAAD,CAArB;;AACA,MAAMM,MAAM,GAAGN,MAAM,CAAC,QAAD,CAArB;;AACA,MAAMO,YAAY,GAAGP,MAAM,CAAC,cAAD,CAA3B;;AACA,MAAMQ,QAAQ,GAAGR,MAAM,CAAC,UAAD,CAAvB;;AACA,MAAMS,KAAK,GAAGT,MAAM,CAAC,OAAD,CAApB;;AACA,MAAMU,UAAU,GAAGV,MAAM,CAAC,YAAD,CAAzB;;AACA,MAAMW,QAAQ,GAAGX,MAAM,CAAC,UAAD,CAAvB;;AACA,MAAMY,OAAO,GAAGZ,MAAM,CAAC,SAAD,CAAtB;;AACA,MAAMa,OAAO,GAAGb,MAAM,CAAC,SAAD,CAAtB;;AACA,MAAMc,QAAQ,GAAGd,MAAM,CAAC,UAAD,CAAvB;;AACA,MAAMe,KAAK,GAAGf,MAAM,CAAC,OAAD,CAApB;;AACA,MAAMgB,KAAK,GAAGhB,MAAM,CAAC,OAAD,CAApB;;AACA,MAAMiB,IAAI,GAAGjB,MAAM,CAAC,MAAD,CAAnB;;AACA,MAAMkB,MAAM,GAAGlB,MAAM,CAAC,QAAD,CAArB;;AACA,MAAMmB,KAAK,GAAGnB,MAAM,CAAC,OAAD,CAApB;;AACA,MAAMoB,SAAS,GAAGpB,MAAM,CAAC,WAAD,CAAxB;;AACA,MAAMqB,QAAQ,GAAGrB,MAAM,CAAC,UAAD,CAAvB;;AACA,MAAMsB,OAAO,GAAGtB,MAAM,CAAC,SAAD,CAAtB;;AACA,MAAMuB,KAAK,GAAGvB,MAAM,CAAC,OAAD,CAApB;;AACA,MAAMwB,MAAM,GAAGxB,MAAM,CAAC,QAAD,CAArB;;AACA,MAAMyB,QAAQ,GAAGzB,MAAM,CAAC,UAAD,CAAvB;;AACA,MAAM0B,YAAY,GAAG1B,MAAM,CAAC,cAAD,CAA3B;;AAEA,MAAM2B,UAAN,SAAyBtC,QAAzB,CAAkC;AAChCuC,EAAAA,WAAW,CAAEC,IAAF,EAAQC,GAAR,EAAa;AACtBA,IAAAA,GAAG,GAAGA,GAAG,IAAI,EAAb;AACA,UAAMA,GAAN;AAEA,SAAKC,QAAL,GAAgB,KAAhB;AAEA,QAAI,OAAOF,IAAP,KAAgB,QAApB,EACE,MAAM,IAAIG,SAAJ,CAAc,uBAAd,CAAN;AAEF,SAAK7B,GAAL,IAAY,OAAO2B,GAAG,CAACG,EAAX,KAAkB,QAAlB,GAA6BH,GAAG,CAACG,EAAjC,GAAsC,IAAlD;AACA,SAAKjB,KAAL,IAAca,IAAd;AACA,SAAKT,SAAL,IAAkBU,GAAG,CAACI,QAAJ,IAAgB,KAAG,IAAH,GAAQ,IAA1C;AACA,SAAKb,QAAL,IAAiB,KAAjB;AACA,SAAKE,KAAL,IAAc,OAAOO,GAAG,CAACK,IAAX,KAAoB,QAApB,GAA+BL,GAAG,CAACK,IAAnC,GAA0CC,QAAxD;AACA,SAAKd,OAAL,IAAgB,KAAKC,KAAL,CAAhB;AACA,SAAKxB,UAAL,IAAmB,OAAO+B,GAAG,CAACO,SAAX,KAAyB,SAAzB,GACjBP,GAAG,CAACO,SADa,GACD,IADlB;AAGA,QAAI,OAAO,KAAKlC,GAAL,CAAP,KAAqB,QAAzB,EACE,KAAKgB,KAAL,IADF,KAGE,KAAKJ,KAAL;AACH;;AAED,MAAIkB,EAAJ,GAAU;AAAE,WAAO,KAAK9B,GAAL,CAAP;AAAkB;;AAC9B,MAAI0B,IAAJ,GAAY;AAAE,WAAO,KAAKb,KAAL,CAAP;AAAoB;;AAElCsB,EAAAA,KAAK,GAAI;AACP,UAAM,IAAIN,SAAJ,CAAc,2BAAd,CAAN;AACD;;AAEDO,EAAAA,GAAG,GAAI;AACL,UAAM,IAAIP,SAAJ,CAAc,2BAAd,CAAN;AACD;;AAED,GAACjB,KAAD,IAAW;AACTtB,IAAAA,EAAE,CAAC+C,IAAH,CAAQ,KAAKxB,KAAL,CAAR,EAAqB,GAArB,EAA0B,CAACyB,EAAD,EAAKR,EAAL,KAAY,KAAKrB,OAAL,EAAc6B,EAAd,EAAkBR,EAAlB,CAAtC;AACD;;AAED,GAACrB,OAAD,EAAW6B,EAAX,EAAeR,EAAf,EAAmB;AACjB,QAAIQ,EAAJ,EACE,KAAK9B,QAAL,EAAe8B,EAAf,EADF,KAEK;AACH,WAAKtC,GAAL,IAAY8B,EAAZ;AACA,WAAKS,IAAL,CAAU,MAAV,EAAkBT,EAAlB;;AACA,WAAKd,KAAL;AACD;AACF;;AAED,GAACX,QAAD,IAAc;AACZ,WAAOmC,MAAM,CAACC,WAAP,CAAmBC,IAAI,CAACC,GAAL,CAAS,KAAK1B,SAAL,CAAT,EAA0B,KAAKE,OAAL,CAA1B,CAAnB,CAAP;AACD;;AAED,GAACH,KAAD,IAAW;AACT,QAAI,CAAC,KAAKE,QAAL,CAAL,EAAqB;AACnB,WAAKA,QAAL,IAAiB,IAAjB;;AACA,YAAM0B,GAAG,GAAG,KAAKvC,QAAL,GAAZ;AACA;;;AACA,UAAIuC,GAAG,CAACC,MAAJ,KAAe,CAAnB,EAAsB,OAAOrD,OAAO,CAACsD,QAAR,CAAiB,MAAM,KAAKpC,OAAL,EAAc,IAAd,EAAoB,CAApB,EAAuBkC,GAAvB,CAAvB,CAAP;AACtBtD,MAAAA,EAAE,CAACyD,IAAH,CAAQ,KAAK/C,GAAL,CAAR,EAAmB4C,GAAnB,EAAwB,CAAxB,EAA2BA,GAAG,CAACC,MAA/B,EAAuC,IAAvC,EAA6C,CAACP,EAAD,EAAKU,EAAL,EAASJ,GAAT,KAC3C,KAAKlC,OAAL,EAAc4B,EAAd,EAAkBU,EAAlB,EAAsBJ,GAAtB,CADF;AAED;AACF;;AAED,GAAClC,OAAD,EAAW4B,EAAX,EAAeU,EAAf,EAAmBJ,GAAnB,EAAwB;AACtB,SAAK1B,QAAL,IAAiB,KAAjB;AACA,QAAIoB,EAAJ,EACE,KAAK9B,QAAL,EAAe8B,EAAf,EADF,KAEK,IAAI,KAAKlC,YAAL,EAAmB4C,EAAnB,EAAuBJ,GAAvB,CAAJ,EACH,KAAK5B,KAAL;AACH;;AAED,GAAClB,MAAD,IAAY;AACV,QAAI,KAAKF,UAAL,KAAoB,OAAO,KAAKI,GAAL,CAAP,KAAqB,QAA7C,EAAuD;AACrDV,MAAAA,EAAE,CAAC2D,KAAH,CAAS,KAAKjD,GAAL,CAAT,EAAoBkD,CAAC,IAAI,KAAKX,IAAL,CAAU,OAAV,CAAzB;AACA,WAAKvC,GAAL,IAAY,IAAZ;AACD;AACF;;AAED,GAACQ,QAAD,EAAY8B,EAAZ,EAAgB;AACd,SAAKpB,QAAL,IAAiB,IAAjB;;AACA,SAAKpB,MAAL;;AACA,SAAKyC,IAAL,CAAU,OAAV,EAAmBD,EAAnB;AACD;;AAED,GAAClC,YAAD,EAAgB4C,EAAhB,EAAoBJ,GAApB,EAAyB;AACvB,QAAIO,GAAG,GAAG,KAAV,CADuB,CAEvB;;AACA,SAAKhC,OAAL,KAAiB6B,EAAjB;AACA,QAAIA,EAAE,GAAG,CAAT,EACEG,GAAG,GAAG,MAAMhB,KAAN,CAAYa,EAAE,GAAGJ,GAAG,CAACC,MAAT,GAAkBD,GAAG,CAACQ,KAAJ,CAAU,CAAV,EAAaJ,EAAb,CAAlB,GAAqCJ,GAAjD,CAAN;;AAEF,QAAII,EAAE,KAAK,CAAP,IAAY,KAAK7B,OAAL,KAAiB,CAAjC,EAAoC;AAClCgC,MAAAA,GAAG,GAAG,KAAN;;AACA,WAAKrD,MAAL;;AACA,YAAMsC,GAAN;AACD;;AAED,WAAOe,GAAP;AACD;;AAEDZ,EAAAA,IAAI,CAAEc,EAAF,EAAMC,IAAN,EAAY;AACd,YAAQD,EAAR;AACE,WAAK,WAAL;AACA,WAAK,QAAL;AACE;;AAEF,WAAK,OAAL;AACE,YAAI,OAAO,KAAKrD,GAAL,CAAP,KAAqB,QAAzB,EACE,KAAKgB,KAAL;AACF;;AAEF;AACE,eAAO,MAAMuB,IAAN,CAAWc,EAAX,EAAeC,IAAf,CAAP;AAXJ;AAaD;;AApH+B;;AAuHlC,MAAMC,cAAN,SAA6B/B,UAA7B,CAAwC;AACtC,GAACZ,KAAD,IAAW;AACT,QAAI4C,KAAK,GAAG,IAAZ;;AACA,QAAI;AACF,WAAK/C,OAAL,EAAc,IAAd,EAAoBnB,EAAE,CAACmE,QAAH,CAAY,KAAK5C,KAAL,CAAZ,EAAyB,GAAzB,CAApB;;AACA2C,MAAAA,KAAK,GAAG,KAAR;AACD,KAHD,SAGU;AACR,UAAIA,KAAJ,EACE,KAAK1D,MAAL;AACH;AACF;;AAED,GAACkB,KAAD,IAAW;AACT,QAAIwC,KAAK,GAAG,IAAZ;;AACA,QAAI;AACF,UAAI,CAAC,KAAKtC,QAAL,CAAL,EAAqB;AACnB,aAAKA,QAAL,IAAiB,IAAjB;;AACA,WAAG;AACD,gBAAM0B,GAAG,GAAG,KAAKvC,QAAL,GAAZ;AACA;;;AACA,gBAAM2C,EAAE,GAAGJ,GAAG,CAACC,MAAJ,KAAe,CAAf,GAAmB,CAAnB,GAAuBvD,EAAE,CAACoE,QAAH,CAAY,KAAK1D,GAAL,CAAZ,EAAuB4C,GAAvB,EAA4B,CAA5B,EAA+BA,GAAG,CAACC,MAAnC,EAA2C,IAA3C,CAAlC;AACA,cAAI,CAAC,KAAKzC,YAAL,EAAmB4C,EAAnB,EAAuBJ,GAAvB,CAAL,EACE;AACH,SAND,QAMS,IANT;;AAOA,aAAK1B,QAAL,IAAiB,KAAjB;AACD;;AACDsC,MAAAA,KAAK,GAAG,KAAR;AACD,KAbD,SAaU;AACR,UAAIA,KAAJ,EACE,KAAK1D,MAAL;AACH;AACF;;AAED,GAACA,MAAD,IAAY;AACV,QAAI,KAAKF,UAAL,KAAoB,OAAO,KAAKI,GAAL,CAAP,KAAqB,QAA7C,EAAuD;AACrD,UAAI;AACFV,QAAAA,EAAE,CAACqE,SAAH,CAAa,KAAK3D,GAAL,CAAb;AACD,OAFD,CAEE,OAAOsC,EAAP,EAAW,CAAE;;AACf,WAAKtC,GAAL,IAAY,IAAZ;AACA,WAAKuC,IAAL,CAAU,OAAV;AACD;AACF;;AAzCqC;;AA4CxC,MAAMqB,WAAN,SAA0BxE,EAA1B,CAA6B;AAC3BqC,EAAAA,WAAW,CAAEC,IAAF,EAAQC,GAAR,EAAa;AACtBA,IAAAA,GAAG,GAAGA,GAAG,IAAI,EAAb;AACA,UAAMA,GAAN;AACA,SAAKkC,QAAL,GAAgB,KAAhB;AACA,SAAKvC,QAAL,IAAiB,KAAjB;AACA,SAAKvB,MAAL,IAAe,KAAf;AACA,SAAKQ,UAAL,IAAmB,KAAnB;AACA,SAAKQ,MAAL,IAAe,EAAf;AACA,SAAKF,KAAL,IAAca,IAAd;AACA,SAAK1B,GAAL,IAAY,OAAO2B,GAAG,CAACG,EAAX,KAAkB,QAAlB,GAA6BH,GAAG,CAACG,EAAjC,GAAsC,IAAlD;AACA,SAAKxB,KAAL,IAAcqB,GAAG,CAACmC,IAAJ,KAAaC,SAAb,GAAyB,KAAzB,GAAiCpC,GAAG,CAACmC,IAAnD;AACA,SAAKhD,IAAL,IAAa,OAAOa,GAAG,CAACqC,KAAX,KAAqB,QAArB,GAAgCrC,GAAG,CAACqC,KAApC,GAA4C,IAAzD;AACA,SAAKpE,UAAL,IAAmB,OAAO+B,GAAG,CAACO,SAAX,KAAyB,SAAzB,GACjBP,GAAG,CAACO,SADa,GACD,IADlB,CAZsB,CAetB;;AACA,UAAM+B,WAAW,GAAG,KAAKnD,IAAL,MAAe,IAAf,GAAsB,IAAtB,GAA6B,GAAjD;AACA,SAAKS,YAAL,IAAqBI,GAAG,CAACuC,KAAJ,KAAcH,SAAnC;AACA,SAAK7D,MAAL,IAAe,KAAKqB,YAAL,IAAqB0C,WAArB,GAAmCtC,GAAG,CAACuC,KAAtD;AAEA,QAAI,KAAKlE,GAAL,MAAc,IAAlB,EACE,KAAKY,KAAL;AACH;;AAED,MAAIkB,EAAJ,GAAU;AAAE,WAAO,KAAK9B,GAAL,CAAP;AAAkB;;AAC9B,MAAI0B,IAAJ,GAAY;AAAE,WAAO,KAAKb,KAAL,CAAP;AAAoB;;AAElC,GAACL,QAAD,EAAY8B,EAAZ,EAAgB;AACd,SAAKxC,MAAL;;AACA,SAAKwB,QAAL,IAAiB,IAAjB;AACA,SAAKiB,IAAL,CAAU,OAAV,EAAmBD,EAAnB;AACD;;AAED,GAAC1B,KAAD,IAAW;AACTtB,IAAAA,EAAE,CAAC+C,IAAH,CAAQ,KAAKxB,KAAL,CAAR,EAAqB,KAAKX,MAAL,CAArB,EAAmC,KAAKI,KAAL,CAAnC,EACE,CAACgC,EAAD,EAAKR,EAAL,KAAY,KAAKrB,OAAL,EAAc6B,EAAd,EAAkBR,EAAlB,CADd;AAED;;AAED,GAACrB,OAAD,EAAW6B,EAAX,EAAeR,EAAf,EAAmB;AACjB,QAAI,KAAKP,YAAL,KACA,KAAKrB,MAAL,MAAiB,IADjB,IAEAoC,EAFA,IAEMA,EAAE,CAAC6B,IAAH,KAAY,QAFtB,EAEgC;AAC9B,WAAKjE,MAAL,IAAe,GAAf;;AACA,WAAKU,KAAL;AACD,KALD,MAKO,IAAI0B,EAAJ,EACL,KAAK9B,QAAL,EAAe8B,EAAf,EADK,KAEF;AACH,WAAKtC,GAAL,IAAY8B,EAAZ;AACA,WAAKS,IAAL,CAAU,MAAV,EAAkBT,EAAlB;;AACA,WAAK3B,MAAL;AACD;AACF;;AAEDiC,EAAAA,GAAG,CAAEQ,GAAF,EAAOwB,GAAP,EAAY;AACb,QAAIxB,GAAJ,EACE,KAAKT,KAAL,CAAWS,GAAX,EAAgBwB,GAAhB;AAEF,SAAKrE,MAAL,IAAe,IAAf,CAJa,CAMb;;AACA,QAAI,CAAC,KAAKuB,QAAL,CAAD,IAAmB,CAAC,KAAKP,MAAL,EAAa8B,MAAjC,IACA,OAAO,KAAK7C,GAAL,CAAP,KAAqB,QADzB,EAEE,KAAKW,QAAL,EAAe,IAAf,EAAqB,CAArB;AACH;;AAEDwB,EAAAA,KAAK,CAAES,GAAF,EAAOwB,GAAP,EAAY;AACf,QAAI,OAAOxB,GAAP,KAAe,QAAnB,EACEA,GAAG,GAAG,IAAIJ,MAAJ,CAAWI,GAAX,EAAgBwB,GAAhB,CAAN;;AAEF,QAAI,KAAKrE,MAAL,CAAJ,EAAkB;AAChB,WAAKwC,IAAL,CAAU,OAAV,EAAmB,IAAI8B,KAAJ,CAAU,qBAAV,CAAnB;AACA,aAAO,KAAP;AACD;;AAED,QAAI,KAAKrE,GAAL,MAAc,IAAd,IAAsB,KAAKsB,QAAL,CAAtB,IAAwC,KAAKP,MAAL,EAAa8B,MAAzD,EAAiE;AAC/D,WAAK9B,MAAL,EAAauD,IAAb,CAAkB1B,GAAlB;;AACA,WAAKrC,UAAL,IAAmB,IAAnB;AACA,aAAO,KAAP;AACD;;AAED,SAAKe,QAAL,IAAiB,IAAjB;;AACA,SAAKD,MAAL,EAAauB,GAAb;;AACA,WAAO,IAAP;AACD;;AAED,GAACvB,MAAD,EAAUuB,GAAV,EAAe;AACbtD,IAAAA,EAAE,CAAC6C,KAAH,CAAS,KAAKnC,GAAL,CAAT,EAAoB4C,GAApB,EAAyB,CAAzB,EAA4BA,GAAG,CAACC,MAAhC,EAAwC,KAAK/B,IAAL,CAAxC,EAAoD,CAACwB,EAAD,EAAKiC,EAAL,KAClD,KAAK5D,QAAL,EAAe2B,EAAf,EAAmBiC,EAAnB,CADF;AAED;;AAED,GAAC5D,QAAD,EAAY2B,EAAZ,EAAgBiC,EAAhB,EAAoB;AAClB,QAAIjC,EAAJ,EACE,KAAK9B,QAAL,EAAe8B,EAAf,EADF,KAEK;AACH,UAAI,KAAKxB,IAAL,MAAe,IAAnB,EACE,KAAKA,IAAL,KAAcyD,EAAd;AACF,UAAI,KAAKxD,MAAL,EAAa8B,MAAjB,EACE,KAAK1C,MAAL,IADF,KAEK;AACH,aAAKmB,QAAL,IAAiB,KAAjB;;AAEA,YAAI,KAAKvB,MAAL,KAAgB,CAAC,KAAKE,SAAL,CAArB,EAAsC;AACpC,eAAKA,SAAL,IAAkB,IAAlB;;AACA,eAAKH,MAAL;;AACA,eAAKyC,IAAL,CAAU,QAAV;AACD,SAJD,MAIO,IAAI,KAAKhC,UAAL,CAAJ,EAAsB;AAC3B,eAAKA,UAAL,IAAmB,KAAnB;AACA,eAAKgC,IAAL,CAAU,OAAV;AACD;AACF;AACF;AACF;;AAED,GAACpC,MAAD,IAAY;AACV,QAAI,KAAKY,MAAL,EAAa8B,MAAb,KAAwB,CAA5B,EAA+B;AAC7B,UAAI,KAAK9C,MAAL,CAAJ,EACE,KAAKY,QAAL,EAAe,IAAf,EAAqB,CAArB;AACH,KAHD,MAGO,IAAI,KAAKI,MAAL,EAAa8B,MAAb,KAAwB,CAA5B,EACL,KAAKxB,MAAL,EAAa,KAAKN,MAAL,EAAayD,GAAb,EAAb,EADK,KAEF;AACH,YAAMC,KAAK,GAAG,KAAK1D,MAAL,CAAd;AACA,WAAKA,MAAL,IAAe,EAAf;AACA2D,MAAAA,MAAM,CAAC,KAAK1E,GAAL,CAAD,EAAYyE,KAAZ,EAAmB,KAAK3D,IAAL,CAAnB,EACJ,CAACwB,EAAD,EAAKiC,EAAL,KAAY,KAAK5D,QAAL,EAAe2B,EAAf,EAAmBiC,EAAnB,CADR,CAAN;AAED;AACF;;AAED,GAACzE,MAAD,IAAY;AACV,QAAI,KAAKF,UAAL,KAAoB,OAAO,KAAKI,GAAL,CAAP,KAAqB,QAA7C,EAAuD;AACrDV,MAAAA,EAAE,CAAC2D,KAAH,CAAS,KAAKjD,GAAL,CAAT,EAAoBkD,CAAC,IAAI,KAAKX,IAAL,CAAU,OAAV,CAAzB;AACA,WAAKvC,GAAL,IAAY,IAAZ;AACD;AACF;;AArI0B;;AAwI7B,MAAM2E,eAAN,SAA8Bf,WAA9B,CAA0C;AACxC,GAAChD,KAAD,IAAW;AACT,QAAIkB,EAAJ;;AACA,QAAI;AACFA,MAAAA,EAAE,GAAGxC,EAAE,CAACmE,QAAH,CAAY,KAAK5C,KAAL,CAAZ,EAAyB,KAAKX,MAAL,CAAzB,EAAuC,KAAKI,KAAL,CAAvC,CAAL;AACD,KAFD,CAEE,OAAOgC,EAAP,EAAW;AACX,UAAI,KAAKf,YAAL,KACA,KAAKrB,MAAL,MAAiB,IADjB,IAEAoC,EAFA,IAEMA,EAAE,CAAC6B,IAAH,KAAY,QAFtB,EAEgC;AAC9B,aAAKjE,MAAL,IAAe,GAAf;AACA,eAAO,KAAKU,KAAL,GAAP;AACD,OALD,MAME,MAAM0B,EAAN;AACH;;AACD,SAAK7B,OAAL,EAAc,IAAd,EAAoBqB,EAApB;AACD;;AAED,GAAChC,MAAD,IAAY;AACV,QAAI,KAAKF,UAAL,KAAoB,OAAO,KAAKI,GAAL,CAAP,KAAqB,QAA7C,EAAuD;AACrD,UAAI;AACFV,QAAAA,EAAE,CAACqE,SAAH,CAAa,KAAK3D,GAAL,CAAb;AACD,OAFD,CAEE,OAAOsC,EAAP,EAAW,CAAE;;AACf,WAAKtC,GAAL,IAAY,IAAZ;AACA,WAAKuC,IAAL,CAAU,OAAV;AACD;AACF;;AAED,GAAClB,MAAD,EAAUuB,GAAV,EAAe;AACb,QAAI;AACF,WAAKjC,QAAL,EAAe,IAAf,EACErB,EAAE,CAACsF,SAAH,CAAa,KAAK5E,GAAL,CAAb,EAAwB4C,GAAxB,EAA6B,CAA7B,EAAgCA,GAAG,CAACC,MAApC,EAA4C,KAAK/B,IAAL,CAA5C,CADF;AAED,KAHD,CAGE,OAAOwB,EAAP,EAAW;AACX,WAAK3B,QAAL,EAAe2B,EAAf,EAAmB,CAAnB;AACD;AACF;;AAlCuC;;AAqC1C,MAAMoC,MAAM,GAAG,CAAC5C,EAAD,EAAK2C,KAAL,EAAYI,GAAZ,EAAiBC,EAAjB,KAAwB;AACrC,QAAMC,IAAI,GAAG,CAACzC,EAAD,EAAKiC,EAAL,KAAYO,EAAE,CAACxC,EAAD,EAAKiC,EAAL,EAASE,KAAT,CAA3B;;AACA,QAAMO,GAAG,GAAG,IAAItF,SAAJ,EAAZ;AACAsF,EAAAA,GAAG,CAACC,UAAJ,GAAiBF,IAAjB;AACAxF,EAAAA,OAAO,CAACE,YAAR,CAAqBqC,EAArB,EAAyB2C,KAAzB,EAAgCI,GAAhC,EAAqCG,GAArC;AACD,CALD;;AAOAE,OAAO,CAAC1D,UAAR,GAAqBA,UAArB;AACA0D,OAAO,CAAC3B,cAAR,GAAyBA,cAAzB;AAEA2B,OAAO,CAACtB,WAAR,GAAsBA,WAAtB;AACAsB,OAAO,CAACP,eAAR,GAA0BA,eAA1B","sourcesContent":["'use strict'\nconst MiniPass = require('minipass')\nconst EE = require('events').EventEmitter\nconst fs = require('fs')\n\n// for writev\nconst binding = process.binding('fs')\nconst writeBuffers = binding.writeBuffers\n/* istanbul ignore next */\nconst FSReqWrap = binding.FSReqWrap || binding.FSReqCallback\n\nconst _autoClose = Symbol('_autoClose')\nconst _close = Symbol('_close')\nconst _ended = Symbol('_ended')\nconst _fd = Symbol('_fd')\nconst _finished = Symbol('_finished')\nconst _flags = Symbol('_flags')\nconst _flush = Symbol('_flush')\nconst _handleChunk = Symbol('_handleChunk')\nconst _makeBuf = Symbol('_makeBuf')\nconst _mode = Symbol('_mode')\nconst _needDrain = Symbol('_needDrain')\nconst _onerror = Symbol('_onerror')\nconst _onopen = Symbol('_onopen')\nconst _onread = Symbol('_onread')\nconst _onwrite = Symbol('_onwrite')\nconst _open = Symbol('_open')\nconst _path = Symbol('_path')\nconst _pos = Symbol('_pos')\nconst _queue = Symbol('_queue')\nconst _read = Symbol('_read')\nconst _readSize = Symbol('_readSize')\nconst _reading = Symbol('_reading')\nconst _remain = Symbol('_remain')\nconst _size = Symbol('_size')\nconst _write = Symbol('_write')\nconst _writing = Symbol('_writing')\nconst _defaultFlag = Symbol('_defaultFlag')\n\nclass ReadStream extends MiniPass {\n  constructor (path, opt) {\n    opt = opt || {}\n    super(opt)\n\n    this.writable = false\n\n    if (typeof path !== 'string')\n      throw new TypeError('path must be a string')\n\n    this[_fd] = typeof opt.fd === 'number' ? opt.fd : null\n    this[_path] = path\n    this[_readSize] = opt.readSize || 16*1024*1024\n    this[_reading] = false\n    this[_size] = typeof opt.size === 'number' ? opt.size : Infinity\n    this[_remain] = this[_size]\n    this[_autoClose] = typeof opt.autoClose === 'boolean' ?\n      opt.autoClose : true\n\n    if (typeof this[_fd] === 'number')\n      this[_read]()\n    else\n      this[_open]()\n  }\n\n  get fd () { return this[_fd] }\n  get path () { return this[_path] }\n\n  write () {\n    throw new TypeError('this is a readable stream')\n  }\n\n  end () {\n    throw new TypeError('this is a readable stream')\n  }\n\n  [_open] () {\n    fs.open(this[_path], 'r', (er, fd) => this[_onopen](er, fd))\n  }\n\n  [_onopen] (er, fd) {\n    if (er)\n      this[_onerror](er)\n    else {\n      this[_fd] = fd\n      this.emit('open', fd)\n      this[_read]()\n    }\n  }\n\n  [_makeBuf] () {\n    return Buffer.allocUnsafe(Math.min(this[_readSize], this[_remain]))\n  }\n\n  [_read] () {\n    if (!this[_reading]) {\n      this[_reading] = true\n      const buf = this[_makeBuf]()\n      /* istanbul ignore if */\n      if (buf.length === 0) return process.nextTick(() => this[_onread](null, 0, buf))\n      fs.read(this[_fd], buf, 0, buf.length, null, (er, br, buf) =>\n        this[_onread](er, br, buf))\n    }\n  }\n\n  [_onread] (er, br, buf) {\n    this[_reading] = false\n    if (er)\n      this[_onerror](er)\n    else if (this[_handleChunk](br, buf))\n      this[_read]()\n  }\n\n  [_close] () {\n    if (this[_autoClose] && typeof this[_fd] === 'number') {\n      fs.close(this[_fd], _ => this.emit('close'))\n      this[_fd] = null\n    }\n  }\n\n  [_onerror] (er) {\n    this[_reading] = true\n    this[_close]()\n    this.emit('error', er)\n  }\n\n  [_handleChunk] (br, buf) {\n    let ret = false\n    // no effect if infinite\n    this[_remain] -= br\n    if (br > 0)\n      ret = super.write(br < buf.length ? buf.slice(0, br) : buf)\n\n    if (br === 0 || this[_remain] <= 0) {\n      ret = false\n      this[_close]()\n      super.end()\n    }\n\n    return ret\n  }\n\n  emit (ev, data) {\n    switch (ev) {\n      case 'prefinish':\n      case 'finish':\n        break\n\n      case 'drain':\n        if (typeof this[_fd] === 'number')\n          this[_read]()\n        break\n\n      default:\n        return super.emit(ev, data)\n    }\n  }\n}\n\nclass ReadStreamSync extends ReadStream {\n  [_open] () {\n    let threw = true\n    try {\n      this[_onopen](null, fs.openSync(this[_path], 'r'))\n      threw = false\n    } finally {\n      if (threw)\n        this[_close]()\n    }\n  }\n\n  [_read] () {\n    let threw = true\n    try {\n      if (!this[_reading]) {\n        this[_reading] = true\n        do {\n          const buf = this[_makeBuf]()\n          /* istanbul ignore next */\n          const br = buf.length === 0 ? 0 : fs.readSync(this[_fd], buf, 0, buf.length, null)\n          if (!this[_handleChunk](br, buf))\n            break\n        } while (true)\n        this[_reading] = false\n      }\n      threw = false\n    } finally {\n      if (threw)\n        this[_close]()\n    }\n  }\n\n  [_close] () {\n    if (this[_autoClose] && typeof this[_fd] === 'number') {\n      try {\n        fs.closeSync(this[_fd])\n      } catch (er) {}\n      this[_fd] = null\n      this.emit('close')\n    }\n  }\n}\n\nclass WriteStream extends EE {\n  constructor (path, opt) {\n    opt = opt || {}\n    super(opt)\n    this.readable = false\n    this[_writing] = false\n    this[_ended] = false\n    this[_needDrain] = false\n    this[_queue] = []\n    this[_path] = path\n    this[_fd] = typeof opt.fd === 'number' ? opt.fd : null\n    this[_mode] = opt.mode === undefined ? 0o666 : opt.mode\n    this[_pos] = typeof opt.start === 'number' ? opt.start : null\n    this[_autoClose] = typeof opt.autoClose === 'boolean' ?\n      opt.autoClose : true\n\n    // truncating makes no sense when writing into the middle\n    const defaultFlag = this[_pos] !== null ? 'r+' : 'w'\n    this[_defaultFlag] = opt.flags === undefined\n    this[_flags] = this[_defaultFlag] ? defaultFlag : opt.flags\n\n    if (this[_fd] === null)\n      this[_open]()\n  }\n\n  get fd () { return this[_fd] }\n  get path () { return this[_path] }\n\n  [_onerror] (er) {\n    this[_close]()\n    this[_writing] = true\n    this.emit('error', er)\n  }\n\n  [_open] () {\n    fs.open(this[_path], this[_flags], this[_mode],\n      (er, fd) => this[_onopen](er, fd))\n  }\n\n  [_onopen] (er, fd) {\n    if (this[_defaultFlag] &&\n        this[_flags] === 'r+' &&\n        er && er.code === 'ENOENT') {\n      this[_flags] = 'w'\n      this[_open]()\n    } else if (er)\n      this[_onerror](er)\n    else {\n      this[_fd] = fd\n      this.emit('open', fd)\n      this[_flush]()\n    }\n  }\n\n  end (buf, enc) {\n    if (buf)\n      this.write(buf, enc)\n\n    this[_ended] = true\n\n    // synthetic after-write logic, where drain/finish live\n    if (!this[_writing] && !this[_queue].length &&\n        typeof this[_fd] === 'number')\n      this[_onwrite](null, 0)\n  }\n\n  write (buf, enc) {\n    if (typeof buf === 'string')\n      buf = new Buffer(buf, enc)\n\n    if (this[_ended]) {\n      this.emit('error', new Error('write() after end()'))\n      return false\n    }\n\n    if (this[_fd] === null || this[_writing] || this[_queue].length) {\n      this[_queue].push(buf)\n      this[_needDrain] = true\n      return false\n    }\n\n    this[_writing] = true\n    this[_write](buf)\n    return true\n  }\n\n  [_write] (buf) {\n    fs.write(this[_fd], buf, 0, buf.length, this[_pos], (er, bw) =>\n      this[_onwrite](er, bw))\n  }\n\n  [_onwrite] (er, bw) {\n    if (er)\n      this[_onerror](er)\n    else {\n      if (this[_pos] !== null)\n        this[_pos] += bw\n      if (this[_queue].length)\n        this[_flush]()\n      else {\n        this[_writing] = false\n\n        if (this[_ended] && !this[_finished]) {\n          this[_finished] = true\n          this[_close]()\n          this.emit('finish')\n        } else if (this[_needDrain]) {\n          this[_needDrain] = false\n          this.emit('drain')\n        }\n      }\n    }\n  }\n\n  [_flush] () {\n    if (this[_queue].length === 0) {\n      if (this[_ended])\n        this[_onwrite](null, 0)\n    } else if (this[_queue].length === 1)\n      this[_write](this[_queue].pop())\n    else {\n      const iovec = this[_queue]\n      this[_queue] = []\n      writev(this[_fd], iovec, this[_pos],\n        (er, bw) => this[_onwrite](er, bw))\n    }\n  }\n\n  [_close] () {\n    if (this[_autoClose] && typeof this[_fd] === 'number') {\n      fs.close(this[_fd], _ => this.emit('close'))\n      this[_fd] = null\n    }\n  }\n}\n\nclass WriteStreamSync extends WriteStream {\n  [_open] () {\n    let fd\n    try {\n      fd = fs.openSync(this[_path], this[_flags], this[_mode])\n    } catch (er) {\n      if (this[_defaultFlag] &&\n          this[_flags] === 'r+' &&\n          er && er.code === 'ENOENT') {\n        this[_flags] = 'w'\n        return this[_open]()\n      } else\n        throw er\n    }\n    this[_onopen](null, fd)\n  }\n\n  [_close] () {\n    if (this[_autoClose] && typeof this[_fd] === 'number') {\n      try {\n        fs.closeSync(this[_fd])\n      } catch (er) {}\n      this[_fd] = null\n      this.emit('close')\n    }\n  }\n\n  [_write] (buf) {\n    try {\n      this[_onwrite](null,\n        fs.writeSync(this[_fd], buf, 0, buf.length, this[_pos]))\n    } catch (er) {\n      this[_onwrite](er, 0)\n    }\n  }\n}\n\nconst writev = (fd, iovec, pos, cb) => {\n  const done = (er, bw) => cb(er, bw, iovec)\n  const req = new FSReqWrap()\n  req.oncomplete = done\n  binding.writeBuffers(fd, iovec, pos, req)\n}\n\nexports.ReadStream = ReadStream\nexports.ReadStreamSync = ReadStreamSync\n\nexports.WriteStream = WriteStream\nexports.WriteStreamSync = WriteStreamSync\n"]},"metadata":{},"sourceType":"script"}