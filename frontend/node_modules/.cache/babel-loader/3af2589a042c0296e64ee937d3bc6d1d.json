{"ast":null,"code":"'use strict';\n\nconst Buffer = require('./buffer.js'); // tar -r\n\n\nconst hlo = require('./high-level-opt.js');\n\nconst Pack = require('./pack.js');\n\nconst Parse = require('./parse.js');\n\nconst fs = require('fs');\n\nconst fsm = require('fs-minipass');\n\nconst t = require('./list.js');\n\nconst path = require('path'); // starting at the head of the file, read a Header\n// If the checksum is invalid, that's our position to start writing\n// If it is, jump forward by the specified size (round up to 512)\n// and try again.\n// Write the new Pack stream starting there.\n\n\nconst Header = require('./header.js');\n\nconst r = module.exports = (opt_, files, cb) => {\n  const opt = hlo(opt_);\n  if (!opt.file) throw new TypeError('file is required');\n  if (opt.gzip) throw new TypeError('cannot append to compressed archives');\n  if (!files || !Array.isArray(files) || !files.length) throw new TypeError('no files or directories specified');\n  files = Array.from(files);\n  return opt.sync ? replaceSync(opt, files) : replace(opt, files, cb);\n};\n\nconst replaceSync = (opt, files) => {\n  const p = new Pack.Sync(opt);\n  let threw = true;\n  let fd;\n  let position;\n\n  try {\n    try {\n      fd = fs.openSync(opt.file, 'r+');\n    } catch (er) {\n      if (er.code === 'ENOENT') fd = fs.openSync(opt.file, 'w+');else throw er;\n    }\n\n    const st = fs.fstatSync(fd);\n    const headBuf = Buffer.alloc(512);\n\n    POSITION: for (position = 0; position < st.size; position += 512) {\n      for (let bufPos = 0, bytes = 0; bufPos < 512; bufPos += bytes) {\n        bytes = fs.readSync(fd, headBuf, bufPos, headBuf.length - bufPos, position + bufPos);\n        if (position === 0 && headBuf[0] === 0x1f && headBuf[1] === 0x8b) throw new Error('cannot append to compressed archives');\n        if (!bytes) break POSITION;\n      }\n\n      let h = new Header(headBuf);\n      if (!h.cksumValid) break;\n      let entryBlockSize = 512 * Math.ceil(h.size / 512);\n      if (position + entryBlockSize + 512 > st.size) break; // the 512 for the header we just parsed will be added as well\n      // also jump ahead all the blocks for the body\n\n      position += entryBlockSize;\n      if (opt.mtimeCache) opt.mtimeCache.set(h.path, h.mtime);\n    }\n\n    threw = false;\n    streamSync(opt, p, position, fd, files);\n  } finally {\n    if (threw) try {\n      fs.closeSync(fd);\n    } catch (er) {}\n  }\n};\n\nconst streamSync = (opt, p, position, fd, files) => {\n  const stream = new fsm.WriteStreamSync(opt.file, {\n    fd: fd,\n    start: position\n  });\n  p.pipe(stream);\n  addFilesSync(p, files);\n};\n\nconst replace = (opt, files, cb) => {\n  files = Array.from(files);\n  const p = new Pack(opt);\n\n  const getPos = (fd, size, cb_) => {\n    const cb = (er, pos) => {\n      if (er) fs.close(fd, _ => cb_(er));else cb_(null, pos);\n    };\n\n    let position = 0;\n    if (size === 0) return cb(null, 0);\n    let bufPos = 0;\n    const headBuf = Buffer.alloc(512);\n\n    const onread = (er, bytes) => {\n      if (er) return cb(er);\n      bufPos += bytes;\n      if (bufPos < 512 && bytes) return fs.read(fd, headBuf, bufPos, headBuf.length - bufPos, position + bufPos, onread);\n      if (position === 0 && headBuf[0] === 0x1f && headBuf[1] === 0x8b) return cb(new Error('cannot append to compressed archives')); // truncated header\n\n      if (bufPos < 512) return cb(null, position);\n      const h = new Header(headBuf);\n      if (!h.cksumValid) return cb(null, position);\n      const entryBlockSize = 512 * Math.ceil(h.size / 512);\n      if (position + entryBlockSize + 512 > size) return cb(null, position);\n      position += entryBlockSize + 512;\n      if (position >= size) return cb(null, position);\n      if (opt.mtimeCache) opt.mtimeCache.set(h.path, h.mtime);\n      bufPos = 0;\n      fs.read(fd, headBuf, 0, 512, position, onread);\n    };\n\n    fs.read(fd, headBuf, 0, 512, position, onread);\n  };\n\n  const promise = new Promise((resolve, reject) => {\n    p.on('error', reject);\n    let flag = 'r+';\n\n    const onopen = (er, fd) => {\n      if (er && er.code === 'ENOENT' && flag === 'r+') {\n        flag = 'w+';\n        return fs.open(opt.file, flag, onopen);\n      }\n\n      if (er) return reject(er);\n      fs.fstat(fd, (er, st) => {\n        if (er) return reject(er);\n        getPos(fd, st.size, (er, position) => {\n          if (er) return reject(er);\n          const stream = new fsm.WriteStream(opt.file, {\n            fd: fd,\n            start: position\n          });\n          p.pipe(stream);\n          stream.on('error', reject);\n          stream.on('close', resolve);\n          addFilesAsync(p, files);\n        });\n      });\n    };\n\n    fs.open(opt.file, flag, onopen);\n  });\n  return cb ? promise.then(cb, cb) : promise;\n};\n\nconst addFilesSync = (p, files) => {\n  files.forEach(file => {\n    if (file.charAt(0) === '@') t({\n      file: path.resolve(p.cwd, file.substr(1)),\n      sync: true,\n      noResume: true,\n      onentry: entry => p.add(entry)\n    });else p.add(file);\n  });\n  p.end();\n};\n\nconst addFilesAsync = (p, files) => {\n  while (files.length) {\n    const file = files.shift();\n    if (file.charAt(0) === '@') return t({\n      file: path.resolve(p.cwd, file.substr(1)),\n      noResume: true,\n      onentry: entry => p.add(entry)\n    }).then(_ => addFilesAsync(p, files));else p.add(file);\n  }\n\n  p.end();\n};","map":{"version":3,"sources":["/home/n/React/loginpagedemo/frontend/node_modules/tar/lib/replace.js"],"names":["Buffer","require","hlo","Pack","Parse","fs","fsm","t","path","Header","r","module","exports","opt_","files","cb","opt","file","TypeError","gzip","Array","isArray","length","from","sync","replaceSync","replace","p","Sync","threw","fd","position","openSync","er","code","st","fstatSync","headBuf","alloc","POSITION","size","bufPos","bytes","readSync","Error","h","cksumValid","entryBlockSize","Math","ceil","mtimeCache","set","mtime","streamSync","closeSync","stream","WriteStreamSync","start","pipe","addFilesSync","getPos","cb_","pos","close","_","onread","read","promise","Promise","resolve","reject","on","flag","onopen","open","fstat","WriteStream","addFilesAsync","then","forEach","charAt","cwd","substr","noResume","onentry","entry","add","end","shift"],"mappings":"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","sourcesContent":["'use strict'\nconst Buffer = require('./buffer.js')\n\n// tar -r\nconst hlo = require('./high-level-opt.js')\nconst Pack = require('./pack.js')\nconst Parse = require('./parse.js')\nconst fs = require('fs')\nconst fsm = require('fs-minipass')\nconst t = require('./list.js')\nconst path = require('path')\n\n// starting at the head of the file, read a Header\n// If the checksum is invalid, that's our position to start writing\n// If it is, jump forward by the specified size (round up to 512)\n// and try again.\n// Write the new Pack stream starting there.\n\nconst Header = require('./header.js')\n\nconst r = module.exports = (opt_, files, cb) => {\n  const opt = hlo(opt_)\n\n  if (!opt.file)\n    throw new TypeError('file is required')\n\n  if (opt.gzip)\n    throw new TypeError('cannot append to compressed archives')\n\n  if (!files || !Array.isArray(files) || !files.length)\n    throw new TypeError('no files or directories specified')\n\n  files = Array.from(files)\n\n  return opt.sync ? replaceSync(opt, files)\n    : replace(opt, files, cb)\n}\n\nconst replaceSync = (opt, files) => {\n  const p = new Pack.Sync(opt)\n\n  let threw = true\n  let fd\n  let position\n\n  try {\n    try {\n      fd = fs.openSync(opt.file, 'r+')\n    } catch (er) {\n      if (er.code === 'ENOENT')\n        fd = fs.openSync(opt.file, 'w+')\n      else\n        throw er\n    }\n\n    const st = fs.fstatSync(fd)\n    const headBuf = Buffer.alloc(512)\n\n    POSITION: for (position = 0; position < st.size; position += 512) {\n      for (let bufPos = 0, bytes = 0; bufPos < 512; bufPos += bytes) {\n        bytes = fs.readSync(\n          fd, headBuf, bufPos, headBuf.length - bufPos, position + bufPos\n        )\n\n        if (position === 0 && headBuf[0] === 0x1f && headBuf[1] === 0x8b)\n          throw new Error('cannot append to compressed archives')\n\n        if (!bytes)\n          break POSITION\n      }\n\n      let h = new Header(headBuf)\n      if (!h.cksumValid)\n        break\n      let entryBlockSize = 512 * Math.ceil(h.size / 512)\n      if (position + entryBlockSize + 512 > st.size)\n        break\n      // the 512 for the header we just parsed will be added as well\n      // also jump ahead all the blocks for the body\n      position += entryBlockSize\n      if (opt.mtimeCache)\n        opt.mtimeCache.set(h.path, h.mtime)\n    }\n    threw = false\n\n    streamSync(opt, p, position, fd, files)\n  } finally {\n    if (threw)\n      try { fs.closeSync(fd) } catch (er) {}\n  }\n}\n\nconst streamSync = (opt, p, position, fd, files) => {\n  const stream = new fsm.WriteStreamSync(opt.file, {\n    fd: fd,\n    start: position\n  })\n  p.pipe(stream)\n  addFilesSync(p, files)\n}\n\nconst replace = (opt, files, cb) => {\n  files = Array.from(files)\n  const p = new Pack(opt)\n\n  const getPos = (fd, size, cb_) => {\n    const cb = (er, pos) => {\n      if (er)\n        fs.close(fd, _ => cb_(er))\n      else\n        cb_(null, pos)\n    }\n\n    let position = 0\n    if (size === 0)\n      return cb(null, 0)\n\n    let bufPos = 0\n    const headBuf = Buffer.alloc(512)\n    const onread = (er, bytes) => {\n      if (er)\n        return cb(er)\n      bufPos += bytes\n      if (bufPos < 512 && bytes)\n        return fs.read(\n          fd, headBuf, bufPos, headBuf.length - bufPos,\n          position + bufPos, onread\n        )\n\n      if (position === 0 && headBuf[0] === 0x1f && headBuf[1] === 0x8b)\n        return cb(new Error('cannot append to compressed archives'))\n\n      // truncated header\n      if (bufPos < 512)\n        return cb(null, position)\n\n      const h = new Header(headBuf)\n      if (!h.cksumValid)\n        return cb(null, position)\n\n      const entryBlockSize = 512 * Math.ceil(h.size / 512)\n      if (position + entryBlockSize + 512 > size)\n        return cb(null, position)\n\n      position += entryBlockSize + 512\n      if (position >= size)\n        return cb(null, position)\n\n      if (opt.mtimeCache)\n        opt.mtimeCache.set(h.path, h.mtime)\n      bufPos = 0\n      fs.read(fd, headBuf, 0, 512, position, onread)\n    }\n    fs.read(fd, headBuf, 0, 512, position, onread)\n  }\n\n  const promise = new Promise((resolve, reject) => {\n    p.on('error', reject)\n    let flag = 'r+'\n    const onopen = (er, fd) => {\n      if (er && er.code === 'ENOENT' && flag === 'r+') {\n        flag = 'w+'\n        return fs.open(opt.file, flag, onopen)\n      }\n\n      if (er)\n        return reject(er)\n\n      fs.fstat(fd, (er, st) => {\n        if (er)\n          return reject(er)\n        getPos(fd, st.size, (er, position) => {\n          if (er)\n            return reject(er)\n          const stream = new fsm.WriteStream(opt.file, {\n            fd: fd,\n            start: position\n          })\n          p.pipe(stream)\n          stream.on('error', reject)\n          stream.on('close', resolve)\n          addFilesAsync(p, files)\n        })\n      })\n    }\n    fs.open(opt.file, flag, onopen)\n  })\n\n  return cb ? promise.then(cb, cb) : promise\n}\n\nconst addFilesSync = (p, files) => {\n  files.forEach(file => {\n    if (file.charAt(0) === '@')\n      t({\n        file: path.resolve(p.cwd, file.substr(1)),\n        sync: true,\n        noResume: true,\n        onentry: entry => p.add(entry)\n      })\n    else\n      p.add(file)\n  })\n  p.end()\n}\n\nconst addFilesAsync = (p, files) => {\n  while (files.length) {\n    const file = files.shift()\n    if (file.charAt(0) === '@')\n      return t({\n        file: path.resolve(p.cwd, file.substr(1)),\n        noResume: true,\n        onentry: entry => p.add(entry)\n      }).then(_ => addFilesAsync(p, files))\n    else\n      p.add(file)\n  }\n  p.end()\n}\n"]},"metadata":{},"sourceType":"script"}