{"ast":null,"code":"'use strict';\n\nconst MiniPass = require('minipass');\n\nconst Pax = require('./pax.js');\n\nconst Header = require('./header.js');\n\nconst ReadEntry = require('./read-entry.js');\n\nconst fs = require('fs');\n\nconst path = require('path');\n\nconst types = require('./types.js');\n\nconst maxReadSize = 16 * 1024 * 1024;\nconst PROCESS = Symbol('process');\nconst FILE = Symbol('file');\nconst DIRECTORY = Symbol('directory');\nconst SYMLINK = Symbol('symlink');\nconst HARDLINK = Symbol('hardlink');\nconst HEADER = Symbol('header');\nconst READ = Symbol('read');\nconst LSTAT = Symbol('lstat');\nconst ONLSTAT = Symbol('onlstat');\nconst ONREAD = Symbol('onread');\nconst ONREADLINK = Symbol('onreadlink');\nconst OPENFILE = Symbol('openfile');\nconst ONOPENFILE = Symbol('onopenfile');\nconst CLOSE = Symbol('close');\nconst MODE = Symbol('mode');\n\nconst warner = require('./warn-mixin.js');\n\nconst winchars = require('./winchars.js');\n\nconst modeFix = require('./mode-fix.js');\n\nconst WriteEntry = warner(class WriteEntry extends MiniPass {\n  constructor(p, opt) {\n    opt = opt || {};\n    super(opt);\n    if (typeof p !== 'string') throw new TypeError('path is required');\n    this.path = p; // suppress atime, ctime, uid, gid, uname, gname\n\n    this.portable = !!opt.portable; // until node has builtin pwnam functions, this'll have to do\n\n    this.myuid = process.getuid && process.getuid();\n    this.myuser = process.env.USER || '';\n    this.maxReadSize = opt.maxReadSize || maxReadSize;\n    this.linkCache = opt.linkCache || new Map();\n    this.statCache = opt.statCache || new Map();\n    this.preservePaths = !!opt.preservePaths;\n    this.cwd = opt.cwd || process.cwd();\n    this.strict = !!opt.strict;\n    this.noPax = !!opt.noPax;\n    this.noMtime = !!opt.noMtime;\n    this.mtime = opt.mtime || null;\n    if (typeof opt.onwarn === 'function') this.on('warn', opt.onwarn);\n    let pathWarn = false;\n\n    if (!this.preservePaths && path.win32.isAbsolute(p)) {\n      // absolutes on posix are also absolutes on win32\n      // so we only need to test this one to get both\n      const parsed = path.win32.parse(p);\n      this.path = p.substr(parsed.root.length);\n      pathWarn = parsed.root;\n    }\n\n    this.win32 = !!opt.win32 || process.platform === 'win32';\n\n    if (this.win32) {\n      this.path = winchars.decode(this.path.replace(/\\\\/g, '/'));\n      p = p.replace(/\\\\/g, '/');\n    }\n\n    this.absolute = opt.absolute || path.resolve(this.cwd, p);\n    if (this.path === '') this.path = './';\n\n    if (pathWarn) {\n      this.warn('TAR_ENTRY_INFO', `stripping ${pathWarn} from absolute path`, {\n        entry: this,\n        path: pathWarn + this.path\n      });\n    }\n\n    if (this.statCache.has(this.absolute)) this[ONLSTAT](this.statCache.get(this.absolute));else this[LSTAT]();\n  }\n\n  [LSTAT]() {\n    fs.lstat(this.absolute, (er, stat) => {\n      if (er) return this.emit('error', er);\n      this[ONLSTAT](stat);\n    });\n  }\n\n  [ONLSTAT](stat) {\n    this.statCache.set(this.absolute, stat);\n    this.stat = stat;\n    if (!stat.isFile()) stat.size = 0;\n    this.type = getType(stat);\n    this.emit('stat', stat);\n    this[PROCESS]();\n  }\n\n  [PROCESS]() {\n    switch (this.type) {\n      case 'File':\n        return this[FILE]();\n\n      case 'Directory':\n        return this[DIRECTORY]();\n\n      case 'SymbolicLink':\n        return this[SYMLINK]();\n      // unsupported types are ignored.\n\n      default:\n        return this.end();\n    }\n  }\n\n  [MODE](mode) {\n    return modeFix(mode, this.type === 'Directory', this.portable);\n  }\n\n  [HEADER]() {\n    if (this.type === 'Directory' && this.portable) this.noMtime = true;\n    this.header = new Header({\n      path: this.path,\n      linkpath: this.linkpath,\n      // only the permissions and setuid/setgid/sticky bitflags\n      // not the higher-order bits that specify file type\n      mode: this[MODE](this.stat.mode),\n      uid: this.portable ? null : this.stat.uid,\n      gid: this.portable ? null : this.stat.gid,\n      size: this.stat.size,\n      mtime: this.noMtime ? null : this.mtime || this.stat.mtime,\n      type: this.type,\n      uname: this.portable ? null : this.stat.uid === this.myuid ? this.myuser : '',\n      atime: this.portable ? null : this.stat.atime,\n      ctime: this.portable ? null : this.stat.ctime\n    });\n    if (this.header.encode() && !this.noPax) this.write(new Pax({\n      atime: this.portable ? null : this.header.atime,\n      ctime: this.portable ? null : this.header.ctime,\n      gid: this.portable ? null : this.header.gid,\n      mtime: this.noMtime ? null : this.mtime || this.header.mtime,\n      path: this.path,\n      linkpath: this.linkpath,\n      size: this.header.size,\n      uid: this.portable ? null : this.header.uid,\n      uname: this.portable ? null : this.header.uname,\n      dev: this.portable ? null : this.stat.dev,\n      ino: this.portable ? null : this.stat.ino,\n      nlink: this.portable ? null : this.stat.nlink\n    }).encode());\n    this.write(this.header.block);\n  }\n\n  [DIRECTORY]() {\n    if (this.path.substr(-1) !== '/') this.path += '/';\n    this.stat.size = 0;\n    this[HEADER]();\n    this.end();\n  }\n\n  [SYMLINK]() {\n    fs.readlink(this.absolute, (er, linkpath) => {\n      if (er) return this.emit('error', er);\n      this[ONREADLINK](linkpath);\n    });\n  }\n\n  [ONREADLINK](linkpath) {\n    this.linkpath = linkpath.replace(/\\\\/g, '/');\n    this[HEADER]();\n    this.end();\n  }\n\n  [HARDLINK](linkpath) {\n    this.type = 'Link';\n    this.linkpath = path.relative(this.cwd, linkpath).replace(/\\\\/g, '/');\n    this.stat.size = 0;\n    this[HEADER]();\n    this.end();\n  }\n\n  [FILE]() {\n    if (this.stat.nlink > 1) {\n      const linkKey = this.stat.dev + ':' + this.stat.ino;\n\n      if (this.linkCache.has(linkKey)) {\n        const linkpath = this.linkCache.get(linkKey);\n        if (linkpath.indexOf(this.cwd) === 0) return this[HARDLINK](linkpath);\n      }\n\n      this.linkCache.set(linkKey, this.absolute);\n    }\n\n    this[HEADER]();\n    if (this.stat.size === 0) return this.end();\n    this[OPENFILE]();\n  }\n\n  [OPENFILE]() {\n    fs.open(this.absolute, 'r', (er, fd) => {\n      if (er) return this.emit('error', er);\n      this[ONOPENFILE](fd);\n    });\n  }\n\n  [ONOPENFILE](fd) {\n    const blockLen = 512 * Math.ceil(this.stat.size / 512);\n    const bufLen = Math.min(blockLen, this.maxReadSize);\n    const buf = Buffer.allocUnsafe(bufLen);\n    this[READ](fd, buf, 0, buf.length, 0, this.stat.size, blockLen);\n  }\n\n  [READ](fd, buf, offset, length, pos, remain, blockRemain) {\n    fs.read(fd, buf, offset, length, pos, (er, bytesRead) => {\n      if (er) {\n        // ignoring the error from close(2) is a bad practice, but at\n        // this point we already have an error, don't need another one\n        return this[CLOSE](fd, () => this.emit('error', er));\n      }\n\n      this[ONREAD](fd, buf, offset, length, pos, remain, blockRemain, bytesRead);\n    });\n  }\n\n  [CLOSE](fd, cb) {\n    fs.close(fd, cb);\n  }\n\n  [ONREAD](fd, buf, offset, length, pos, remain, blockRemain, bytesRead) {\n    if (bytesRead <= 0 && remain > 0) {\n      const er = new Error('encountered unexpected EOF');\n      er.path = this.absolute;\n      er.syscall = 'read';\n      er.code = 'EOF';\n      return this[CLOSE](fd, () => this.emit('error', er));\n    }\n\n    if (bytesRead > remain) {\n      const er = new Error('did not encounter expected EOF');\n      er.path = this.absolute;\n      er.syscall = 'read';\n      er.code = 'EOF';\n      return this[CLOSE](fd, () => this.emit('error', er));\n    } // null out the rest of the buffer, if we could fit the block padding\n\n\n    if (bytesRead === remain) {\n      for (let i = bytesRead; i < length && bytesRead < blockRemain; i++) {\n        buf[i + offset] = 0;\n        bytesRead++;\n        remain++;\n      }\n    }\n\n    const writeBuf = offset === 0 && bytesRead === buf.length ? buf : buf.slice(offset, offset + bytesRead);\n    remain -= bytesRead;\n    blockRemain -= bytesRead;\n    pos += bytesRead;\n    offset += bytesRead;\n    this.write(writeBuf);\n\n    if (!remain) {\n      if (blockRemain) this.write(Buffer.alloc(blockRemain));\n      return this[CLOSE](fd, er => er ? this.emit('error', er) : this.end());\n    }\n\n    if (offset >= length) {\n      buf = Buffer.allocUnsafe(length);\n      offset = 0;\n    }\n\n    length = buf.length - offset;\n    this[READ](fd, buf, offset, length, pos, remain, blockRemain);\n  }\n\n});\n\nclass WriteEntrySync extends WriteEntry {\n  constructor(path, opt) {\n    super(path, opt);\n  }\n\n  [LSTAT]() {\n    this[ONLSTAT](fs.lstatSync(this.absolute));\n  }\n\n  [SYMLINK]() {\n    this[ONREADLINK](fs.readlinkSync(this.absolute));\n  }\n\n  [OPENFILE]() {\n    this[ONOPENFILE](fs.openSync(this.absolute, 'r'));\n  }\n\n  [READ](fd, buf, offset, length, pos, remain, blockRemain) {\n    let threw = true;\n\n    try {\n      const bytesRead = fs.readSync(fd, buf, offset, length, pos);\n      this[ONREAD](fd, buf, offset, length, pos, remain, blockRemain, bytesRead);\n      threw = false;\n    } finally {\n      // ignoring the error from close(2) is a bad practice, but at\n      // this point we already have an error, don't need another one\n      if (threw) try {\n        this[CLOSE](fd, () => {});\n      } catch (er) {}\n    }\n  }\n\n  [CLOSE](fd, cb) {\n    fs.closeSync(fd);\n    cb();\n  }\n\n}\n\nconst WriteEntryTar = warner(class WriteEntryTar extends MiniPass {\n  constructor(readEntry, opt) {\n    opt = opt || {};\n    super(opt);\n    this.preservePaths = !!opt.preservePaths;\n    this.portable = !!opt.portable;\n    this.strict = !!opt.strict;\n    this.noPax = !!opt.noPax;\n    this.noMtime = !!opt.noMtime;\n    this.readEntry = readEntry;\n    this.type = readEntry.type;\n    if (this.type === 'Directory' && this.portable) this.noMtime = true;\n    this.path = readEntry.path;\n    this.mode = this[MODE](readEntry.mode);\n    this.uid = this.portable ? null : readEntry.uid;\n    this.gid = this.portable ? null : readEntry.gid;\n    this.uname = this.portable ? null : readEntry.uname;\n    this.gname = this.portable ? null : readEntry.gname;\n    this.size = readEntry.size;\n    this.mtime = this.noMtime ? null : opt.mtime || readEntry.mtime;\n    this.atime = this.portable ? null : readEntry.atime;\n    this.ctime = this.portable ? null : readEntry.ctime;\n    this.linkpath = readEntry.linkpath;\n    if (typeof opt.onwarn === 'function') this.on('warn', opt.onwarn);\n    let pathWarn = false;\n\n    if (path.isAbsolute(this.path) && !this.preservePaths) {\n      const parsed = path.parse(this.path);\n      pathWarn = parsed.root;\n      this.path = this.path.substr(parsed.root.length);\n    }\n\n    this.remain = readEntry.size;\n    this.blockRemain = readEntry.startBlockSize;\n    this.header = new Header({\n      path: this.path,\n      linkpath: this.linkpath,\n      // only the permissions and setuid/setgid/sticky bitflags\n      // not the higher-order bits that specify file type\n      mode: this.mode,\n      uid: this.portable ? null : this.uid,\n      gid: this.portable ? null : this.gid,\n      size: this.size,\n      mtime: this.noMtime ? null : this.mtime,\n      type: this.type,\n      uname: this.portable ? null : this.uname,\n      atime: this.portable ? null : this.atime,\n      ctime: this.portable ? null : this.ctime\n    });\n\n    if (pathWarn) {\n      this.warn('TAR_ENTRY_INFO', `stripping ${pathWarn} from absolute path`, {\n        entry: this,\n        path: pathWarn + this.path\n      });\n    }\n\n    if (this.header.encode() && !this.noPax) super.write(new Pax({\n      atime: this.portable ? null : this.atime,\n      ctime: this.portable ? null : this.ctime,\n      gid: this.portable ? null : this.gid,\n      mtime: this.noMtime ? null : this.mtime,\n      path: this.path,\n      linkpath: this.linkpath,\n      size: this.size,\n      uid: this.portable ? null : this.uid,\n      uname: this.portable ? null : this.uname,\n      dev: this.portable ? null : this.readEntry.dev,\n      ino: this.portable ? null : this.readEntry.ino,\n      nlink: this.portable ? null : this.readEntry.nlink\n    }).encode());\n    super.write(this.header.block);\n    readEntry.pipe(this);\n  }\n\n  [MODE](mode) {\n    return modeFix(mode, this.type === 'Directory', this.portable);\n  }\n\n  write(data) {\n    const writeLen = data.length;\n    if (writeLen > this.blockRemain) throw new Error('writing more to entry than is appropriate');\n    this.blockRemain -= writeLen;\n    return super.write(data);\n  }\n\n  end() {\n    if (this.blockRemain) this.write(Buffer.alloc(this.blockRemain));\n    return super.end();\n  }\n\n});\nWriteEntry.Sync = WriteEntrySync;\nWriteEntry.Tar = WriteEntryTar;\n\nconst getType = stat => stat.isFile() ? 'File' : stat.isDirectory() ? 'Directory' : stat.isSymbolicLink() ? 'SymbolicLink' : 'Unsupported';\n\nmodule.exports = WriteEntry;","map":{"version":3,"sources":["/home/n/React/loginpagedemo/frontend/node_modules/node-gyp/node_modules/tar/lib/write-entry.js"],"names":["MiniPass","require","Pax","Header","ReadEntry","fs","path","types","maxReadSize","PROCESS","Symbol","FILE","DIRECTORY","SYMLINK","HARDLINK","HEADER","READ","LSTAT","ONLSTAT","ONREAD","ONREADLINK","OPENFILE","ONOPENFILE","CLOSE","MODE","warner","winchars","modeFix","WriteEntry","constructor","p","opt","TypeError","portable","myuid","process","getuid","myuser","env","USER","linkCache","Map","statCache","preservePaths","cwd","strict","noPax","noMtime","mtime","onwarn","on","pathWarn","win32","isAbsolute","parsed","parse","substr","root","length","platform","decode","replace","absolute","resolve","warn","entry","has","get","lstat","er","stat","emit","set","isFile","size","type","getType","end","mode","header","linkpath","uid","gid","uname","atime","ctime","encode","write","dev","ino","nlink","block","readlink","relative","linkKey","indexOf","open","fd","blockLen","Math","ceil","bufLen","min","buf","Buffer","allocUnsafe","offset","pos","remain","blockRemain","read","bytesRead","cb","close","Error","syscall","code","i","writeBuf","slice","alloc","WriteEntrySync","lstatSync","readlinkSync","openSync","threw","readSync","closeSync","WriteEntryTar","readEntry","gname","startBlockSize","pipe","data","writeLen","Sync","Tar","isDirectory","isSymbolicLink","module","exports"],"mappings":"AAAA;;AACA,MAAMA,QAAQ,GAAGC,OAAO,CAAC,UAAD,CAAxB;;AACA,MAAMC,GAAG,GAAGD,OAAO,CAAC,UAAD,CAAnB;;AACA,MAAME,MAAM,GAAGF,OAAO,CAAC,aAAD,CAAtB;;AACA,MAAMG,SAAS,GAAGH,OAAO,CAAC,iBAAD,CAAzB;;AACA,MAAMI,EAAE,GAAGJ,OAAO,CAAC,IAAD,CAAlB;;AACA,MAAMK,IAAI,GAAGL,OAAO,CAAC,MAAD,CAApB;;AAEA,MAAMM,KAAK,GAAGN,OAAO,CAAC,YAAD,CAArB;;AACA,MAAMO,WAAW,GAAG,KAAK,IAAL,GAAY,IAAhC;AACA,MAAMC,OAAO,GAAGC,MAAM,CAAC,SAAD,CAAtB;AACA,MAAMC,IAAI,GAAGD,MAAM,CAAC,MAAD,CAAnB;AACA,MAAME,SAAS,GAAGF,MAAM,CAAC,WAAD,CAAxB;AACA,MAAMG,OAAO,GAAGH,MAAM,CAAC,SAAD,CAAtB;AACA,MAAMI,QAAQ,GAAGJ,MAAM,CAAC,UAAD,CAAvB;AACA,MAAMK,MAAM,GAAGL,MAAM,CAAC,QAAD,CAArB;AACA,MAAMM,IAAI,GAAGN,MAAM,CAAC,MAAD,CAAnB;AACA,MAAMO,KAAK,GAAGP,MAAM,CAAC,OAAD,CAApB;AACA,MAAMQ,OAAO,GAAGR,MAAM,CAAC,SAAD,CAAtB;AACA,MAAMS,MAAM,GAAGT,MAAM,CAAC,QAAD,CAArB;AACA,MAAMU,UAAU,GAAGV,MAAM,CAAC,YAAD,CAAzB;AACA,MAAMW,QAAQ,GAAGX,MAAM,CAAC,UAAD,CAAvB;AACA,MAAMY,UAAU,GAAGZ,MAAM,CAAC,YAAD,CAAzB;AACA,MAAMa,KAAK,GAAGb,MAAM,CAAC,OAAD,CAApB;AACA,MAAMc,IAAI,GAAGd,MAAM,CAAC,MAAD,CAAnB;;AACA,MAAMe,MAAM,GAAGxB,OAAO,CAAC,iBAAD,CAAtB;;AACA,MAAMyB,QAAQ,GAAGzB,OAAO,CAAC,eAAD,CAAxB;;AAEA,MAAM0B,OAAO,GAAG1B,OAAO,CAAC,eAAD,CAAvB;;AAEA,MAAM2B,UAAU,GAAGH,MAAM,CAAC,MAAMG,UAAN,SAAyB5B,QAAzB,CAAkC;AAC1D6B,EAAAA,WAAW,CAAEC,CAAF,EAAKC,GAAL,EAAU;AACnBA,IAAAA,GAAG,GAAGA,GAAG,IAAI,EAAb;AACA,UAAMA,GAAN;AACA,QAAI,OAAOD,CAAP,KAAa,QAAjB,EACE,MAAM,IAAIE,SAAJ,CAAc,kBAAd,CAAN;AACF,SAAK1B,IAAL,GAAYwB,CAAZ,CALmB,CAMnB;;AACA,SAAKG,QAAL,GAAgB,CAAC,CAACF,GAAG,CAACE,QAAtB,CAPmB,CAQnB;;AACA,SAAKC,KAAL,GAAaC,OAAO,CAACC,MAAR,IAAkBD,OAAO,CAACC,MAAR,EAA/B;AACA,SAAKC,MAAL,GAAcF,OAAO,CAACG,GAAR,CAAYC,IAAZ,IAAoB,EAAlC;AACA,SAAK/B,WAAL,GAAmBuB,GAAG,CAACvB,WAAJ,IAAmBA,WAAtC;AACA,SAAKgC,SAAL,GAAiBT,GAAG,CAACS,SAAJ,IAAiB,IAAIC,GAAJ,EAAlC;AACA,SAAKC,SAAL,GAAiBX,GAAG,CAACW,SAAJ,IAAiB,IAAID,GAAJ,EAAlC;AACA,SAAKE,aAAL,GAAqB,CAAC,CAACZ,GAAG,CAACY,aAA3B;AACA,SAAKC,GAAL,GAAWb,GAAG,CAACa,GAAJ,IAAWT,OAAO,CAACS,GAAR,EAAtB;AACA,SAAKC,MAAL,GAAc,CAAC,CAACd,GAAG,CAACc,MAApB;AACA,SAAKC,KAAL,GAAa,CAAC,CAACf,GAAG,CAACe,KAAnB;AACA,SAAKC,OAAL,GAAe,CAAC,CAAChB,GAAG,CAACgB,OAArB;AACA,SAAKC,KAAL,GAAajB,GAAG,CAACiB,KAAJ,IAAa,IAA1B;AAEA,QAAI,OAAOjB,GAAG,CAACkB,MAAX,KAAsB,UAA1B,EACE,KAAKC,EAAL,CAAQ,MAAR,EAAgBnB,GAAG,CAACkB,MAApB;AAEF,QAAIE,QAAQ,GAAG,KAAf;;AACA,QAAI,CAAC,KAAKR,aAAN,IAAuBrC,IAAI,CAAC8C,KAAL,CAAWC,UAAX,CAAsBvB,CAAtB,CAA3B,EAAqD;AACnD;AACA;AACA,YAAMwB,MAAM,GAAGhD,IAAI,CAAC8C,KAAL,CAAWG,KAAX,CAAiBzB,CAAjB,CAAf;AACA,WAAKxB,IAAL,GAAYwB,CAAC,CAAC0B,MAAF,CAASF,MAAM,CAACG,IAAP,CAAYC,MAArB,CAAZ;AACAP,MAAAA,QAAQ,GAAGG,MAAM,CAACG,IAAlB;AACD;;AAED,SAAKL,KAAL,GAAa,CAAC,CAACrB,GAAG,CAACqB,KAAN,IAAejB,OAAO,CAACwB,QAAR,KAAqB,OAAjD;;AACA,QAAI,KAAKP,KAAT,EAAgB;AACd,WAAK9C,IAAL,GAAYoB,QAAQ,CAACkC,MAAT,CAAgB,KAAKtD,IAAL,CAAUuD,OAAV,CAAkB,KAAlB,EAAyB,GAAzB,CAAhB,CAAZ;AACA/B,MAAAA,CAAC,GAAGA,CAAC,CAAC+B,OAAF,CAAU,KAAV,EAAiB,GAAjB,CAAJ;AACD;;AAED,SAAKC,QAAL,GAAgB/B,GAAG,CAAC+B,QAAJ,IAAgBxD,IAAI,CAACyD,OAAL,CAAa,KAAKnB,GAAlB,EAAuBd,CAAvB,CAAhC;AAEA,QAAI,KAAKxB,IAAL,KAAc,EAAlB,EACE,KAAKA,IAAL,GAAY,IAAZ;;AAEF,QAAI6C,QAAJ,EAAc;AACZ,WAAKa,IAAL,CAAU,gBAAV,EAA6B,aAAYb,QAAS,qBAAlD,EAAwE;AACtEc,QAAAA,KAAK,EAAE,IAD+D;AAEtE3D,QAAAA,IAAI,EAAE6C,QAAQ,GAAG,KAAK7C;AAFgD,OAAxE;AAID;;AAED,QAAI,KAAKoC,SAAL,CAAewB,GAAf,CAAmB,KAAKJ,QAAxB,CAAJ,EACE,KAAK5C,OAAL,EAAc,KAAKwB,SAAL,CAAeyB,GAAf,CAAmB,KAAKL,QAAxB,CAAd,EADF,KAGE,KAAK7C,KAAL;AACH;;AAED,GAACA,KAAD,IAAW;AACTZ,IAAAA,EAAE,CAAC+D,KAAH,CAAS,KAAKN,QAAd,EAAwB,CAACO,EAAD,EAAKC,IAAL,KAAc;AACpC,UAAID,EAAJ,EACE,OAAO,KAAKE,IAAL,CAAU,OAAV,EAAmBF,EAAnB,CAAP;AACF,WAAKnD,OAAL,EAAcoD,IAAd;AACD,KAJD;AAKD;;AAED,GAACpD,OAAD,EAAWoD,IAAX,EAAiB;AACf,SAAK5B,SAAL,CAAe8B,GAAf,CAAmB,KAAKV,QAAxB,EAAkCQ,IAAlC;AACA,SAAKA,IAAL,GAAYA,IAAZ;AACA,QAAI,CAACA,IAAI,CAACG,MAAL,EAAL,EACEH,IAAI,CAACI,IAAL,GAAY,CAAZ;AACF,SAAKC,IAAL,GAAYC,OAAO,CAACN,IAAD,CAAnB;AACA,SAAKC,IAAL,CAAU,MAAV,EAAkBD,IAAlB;AACA,SAAK7D,OAAL;AACD;;AAED,GAACA,OAAD,IAAa;AACX,YAAQ,KAAKkE,IAAb;AACE,WAAK,MAAL;AAAa,eAAO,KAAKhE,IAAL,GAAP;;AACb,WAAK,WAAL;AAAkB,eAAO,KAAKC,SAAL,GAAP;;AAClB,WAAK,cAAL;AAAqB,eAAO,KAAKC,OAAL,GAAP;AACrB;;AACA;AAAS,eAAO,KAAKgE,GAAL,EAAP;AALX;AAOD;;AAED,GAACrD,IAAD,EAAQsD,IAAR,EAAc;AACZ,WAAOnD,OAAO,CAACmD,IAAD,EAAO,KAAKH,IAAL,KAAc,WAArB,EAAkC,KAAK1C,QAAvC,CAAd;AACD;;AAED,GAAClB,MAAD,IAAY;AACV,QAAI,KAAK4D,IAAL,KAAc,WAAd,IAA6B,KAAK1C,QAAtC,EACE,KAAKc,OAAL,GAAe,IAAf;AAEF,SAAKgC,MAAL,GAAc,IAAI5E,MAAJ,CAAW;AACvBG,MAAAA,IAAI,EAAE,KAAKA,IADY;AAEvB0E,MAAAA,QAAQ,EAAE,KAAKA,QAFQ;AAGvB;AACA;AACAF,MAAAA,IAAI,EAAE,KAAKtD,IAAL,EAAW,KAAK8C,IAAL,CAAUQ,IAArB,CALiB;AAMvBG,MAAAA,GAAG,EAAE,KAAKhD,QAAL,GAAgB,IAAhB,GAAuB,KAAKqC,IAAL,CAAUW,GANf;AAOvBC,MAAAA,GAAG,EAAE,KAAKjD,QAAL,GAAgB,IAAhB,GAAuB,KAAKqC,IAAL,CAAUY,GAPf;AAQvBR,MAAAA,IAAI,EAAE,KAAKJ,IAAL,CAAUI,IARO;AASvB1B,MAAAA,KAAK,EAAE,KAAKD,OAAL,GAAe,IAAf,GAAsB,KAAKC,KAAL,IAAc,KAAKsB,IAAL,CAAUtB,KAT9B;AAUvB2B,MAAAA,IAAI,EAAE,KAAKA,IAVY;AAWvBQ,MAAAA,KAAK,EAAE,KAAKlD,QAAL,GAAgB,IAAhB,GACL,KAAKqC,IAAL,CAAUW,GAAV,KAAkB,KAAK/C,KAAvB,GAA+B,KAAKG,MAApC,GAA6C,EAZxB;AAavB+C,MAAAA,KAAK,EAAE,KAAKnD,QAAL,GAAgB,IAAhB,GAAuB,KAAKqC,IAAL,CAAUc,KAbjB;AAcvBC,MAAAA,KAAK,EAAE,KAAKpD,QAAL,GAAgB,IAAhB,GAAuB,KAAKqC,IAAL,CAAUe;AAdjB,KAAX,CAAd;AAiBA,QAAI,KAAKN,MAAL,CAAYO,MAAZ,MAAwB,CAAC,KAAKxC,KAAlC,EACE,KAAKyC,KAAL,CAAW,IAAIrF,GAAJ,CAAQ;AACjBkF,MAAAA,KAAK,EAAE,KAAKnD,QAAL,GAAgB,IAAhB,GAAuB,KAAK8C,MAAL,CAAYK,KADzB;AAEjBC,MAAAA,KAAK,EAAE,KAAKpD,QAAL,GAAgB,IAAhB,GAAuB,KAAK8C,MAAL,CAAYM,KAFzB;AAGjBH,MAAAA,GAAG,EAAE,KAAKjD,QAAL,GAAgB,IAAhB,GAAuB,KAAK8C,MAAL,CAAYG,GAHvB;AAIjBlC,MAAAA,KAAK,EAAE,KAAKD,OAAL,GAAe,IAAf,GAAsB,KAAKC,KAAL,IAAc,KAAK+B,MAAL,CAAY/B,KAJtC;AAKjB1C,MAAAA,IAAI,EAAE,KAAKA,IALM;AAMjB0E,MAAAA,QAAQ,EAAE,KAAKA,QANE;AAOjBN,MAAAA,IAAI,EAAE,KAAKK,MAAL,CAAYL,IAPD;AAQjBO,MAAAA,GAAG,EAAE,KAAKhD,QAAL,GAAgB,IAAhB,GAAuB,KAAK8C,MAAL,CAAYE,GARvB;AASjBE,MAAAA,KAAK,EAAE,KAAKlD,QAAL,GAAgB,IAAhB,GAAuB,KAAK8C,MAAL,CAAYI,KATzB;AAUjBK,MAAAA,GAAG,EAAE,KAAKvD,QAAL,GAAgB,IAAhB,GAAuB,KAAKqC,IAAL,CAAUkB,GAVrB;AAWjBC,MAAAA,GAAG,EAAE,KAAKxD,QAAL,GAAgB,IAAhB,GAAuB,KAAKqC,IAAL,CAAUmB,GAXrB;AAYjBC,MAAAA,KAAK,EAAE,KAAKzD,QAAL,GAAgB,IAAhB,GAAuB,KAAKqC,IAAL,CAAUoB;AAZvB,KAAR,EAaRJ,MAbQ,EAAX;AAcF,SAAKC,KAAL,CAAW,KAAKR,MAAL,CAAYY,KAAvB;AACD;;AAED,GAAC/E,SAAD,IAAe;AACb,QAAI,KAAKN,IAAL,CAAUkD,MAAV,CAAiB,CAAC,CAAlB,MAAyB,GAA7B,EACE,KAAKlD,IAAL,IAAa,GAAb;AACF,SAAKgE,IAAL,CAAUI,IAAV,GAAiB,CAAjB;AACA,SAAK3D,MAAL;AACA,SAAK8D,GAAL;AACD;;AAED,GAAChE,OAAD,IAAa;AACXR,IAAAA,EAAE,CAACuF,QAAH,CAAY,KAAK9B,QAAjB,EAA2B,CAACO,EAAD,EAAKW,QAAL,KAAkB;AAC3C,UAAIX,EAAJ,EACE,OAAO,KAAKE,IAAL,CAAU,OAAV,EAAmBF,EAAnB,CAAP;AACF,WAAKjD,UAAL,EAAiB4D,QAAjB;AACD,KAJD;AAKD;;AAED,GAAC5D,UAAD,EAAc4D,QAAd,EAAwB;AACtB,SAAKA,QAAL,GAAgBA,QAAQ,CAACnB,OAAT,CAAiB,KAAjB,EAAwB,GAAxB,CAAhB;AACA,SAAK9C,MAAL;AACA,SAAK8D,GAAL;AACD;;AAED,GAAC/D,QAAD,EAAYkE,QAAZ,EAAsB;AACpB,SAAKL,IAAL,GAAY,MAAZ;AACA,SAAKK,QAAL,GAAgB1E,IAAI,CAACuF,QAAL,CAAc,KAAKjD,GAAnB,EAAwBoC,QAAxB,EAAkCnB,OAAlC,CAA0C,KAA1C,EAAiD,GAAjD,CAAhB;AACA,SAAKS,IAAL,CAAUI,IAAV,GAAiB,CAAjB;AACA,SAAK3D,MAAL;AACA,SAAK8D,GAAL;AACD;;AAED,GAAClE,IAAD,IAAU;AACR,QAAI,KAAK2D,IAAL,CAAUoB,KAAV,GAAkB,CAAtB,EAAyB;AACvB,YAAMI,OAAO,GAAG,KAAKxB,IAAL,CAAUkB,GAAV,GAAgB,GAAhB,GAAsB,KAAKlB,IAAL,CAAUmB,GAAhD;;AACA,UAAI,KAAKjD,SAAL,CAAe0B,GAAf,CAAmB4B,OAAnB,CAAJ,EAAiC;AAC/B,cAAMd,QAAQ,GAAG,KAAKxC,SAAL,CAAe2B,GAAf,CAAmB2B,OAAnB,CAAjB;AACA,YAAId,QAAQ,CAACe,OAAT,CAAiB,KAAKnD,GAAtB,MAA+B,CAAnC,EACE,OAAO,KAAK9B,QAAL,EAAekE,QAAf,CAAP;AACH;;AACD,WAAKxC,SAAL,CAAegC,GAAf,CAAmBsB,OAAnB,EAA4B,KAAKhC,QAAjC;AACD;;AAED,SAAK/C,MAAL;AACA,QAAI,KAAKuD,IAAL,CAAUI,IAAV,KAAmB,CAAvB,EACE,OAAO,KAAKG,GAAL,EAAP;AAEF,SAAKxD,QAAL;AACD;;AAED,GAACA,QAAD,IAAc;AACZhB,IAAAA,EAAE,CAAC2F,IAAH,CAAQ,KAAKlC,QAAb,EAAuB,GAAvB,EAA4B,CAACO,EAAD,EAAK4B,EAAL,KAAY;AACtC,UAAI5B,EAAJ,EACE,OAAO,KAAKE,IAAL,CAAU,OAAV,EAAmBF,EAAnB,CAAP;AACF,WAAK/C,UAAL,EAAiB2E,EAAjB;AACD,KAJD;AAKD;;AAED,GAAC3E,UAAD,EAAc2E,EAAd,EAAkB;AAChB,UAAMC,QAAQ,GAAG,MAAMC,IAAI,CAACC,IAAL,CAAU,KAAK9B,IAAL,CAAUI,IAAV,GAAiB,GAA3B,CAAvB;AACA,UAAM2B,MAAM,GAAGF,IAAI,CAACG,GAAL,CAASJ,QAAT,EAAmB,KAAK1F,WAAxB,CAAf;AACA,UAAM+F,GAAG,GAAGC,MAAM,CAACC,WAAP,CAAmBJ,MAAnB,CAAZ;AACA,SAAKrF,IAAL,EAAWiF,EAAX,EAAeM,GAAf,EAAoB,CAApB,EAAuBA,GAAG,CAAC7C,MAA3B,EAAmC,CAAnC,EAAsC,KAAKY,IAAL,CAAUI,IAAhD,EAAsDwB,QAAtD;AACD;;AAED,GAAClF,IAAD,EAAQiF,EAAR,EAAYM,GAAZ,EAAiBG,MAAjB,EAAyBhD,MAAzB,EAAiCiD,GAAjC,EAAsCC,MAAtC,EAA8CC,WAA9C,EAA2D;AACzDxG,IAAAA,EAAE,CAACyG,IAAH,CAAQb,EAAR,EAAYM,GAAZ,EAAiBG,MAAjB,EAAyBhD,MAAzB,EAAiCiD,GAAjC,EAAsC,CAACtC,EAAD,EAAK0C,SAAL,KAAmB;AACvD,UAAI1C,EAAJ,EAAQ;AACN;AACA;AACA,eAAO,KAAK9C,KAAL,EAAY0E,EAAZ,EAAgB,MAAM,KAAK1B,IAAL,CAAU,OAAV,EAAmBF,EAAnB,CAAtB,CAAP;AACD;;AACD,WAAKlD,MAAL,EAAa8E,EAAb,EAAiBM,GAAjB,EAAsBG,MAAtB,EAA8BhD,MAA9B,EAAsCiD,GAAtC,EAA2CC,MAA3C,EAAmDC,WAAnD,EAAgEE,SAAhE;AACD,KAPD;AAQD;;AAED,GAACxF,KAAD,EAAS0E,EAAT,EAAae,EAAb,EAAiB;AACf3G,IAAAA,EAAE,CAAC4G,KAAH,CAAShB,EAAT,EAAae,EAAb;AACD;;AAED,GAAC7F,MAAD,EAAU8E,EAAV,EAAcM,GAAd,EAAmBG,MAAnB,EAA2BhD,MAA3B,EAAmCiD,GAAnC,EAAwCC,MAAxC,EAAgDC,WAAhD,EAA6DE,SAA7D,EAAwE;AACtE,QAAIA,SAAS,IAAI,CAAb,IAAkBH,MAAM,GAAG,CAA/B,EAAkC;AAChC,YAAMvC,EAAE,GAAG,IAAI6C,KAAJ,CAAU,4BAAV,CAAX;AACA7C,MAAAA,EAAE,CAAC/D,IAAH,GAAU,KAAKwD,QAAf;AACAO,MAAAA,EAAE,CAAC8C,OAAH,GAAa,MAAb;AACA9C,MAAAA,EAAE,CAAC+C,IAAH,GAAU,KAAV;AACA,aAAO,KAAK7F,KAAL,EAAY0E,EAAZ,EAAgB,MAAM,KAAK1B,IAAL,CAAU,OAAV,EAAmBF,EAAnB,CAAtB,CAAP;AACD;;AAED,QAAI0C,SAAS,GAAGH,MAAhB,EAAwB;AACtB,YAAMvC,EAAE,GAAG,IAAI6C,KAAJ,CAAU,gCAAV,CAAX;AACA7C,MAAAA,EAAE,CAAC/D,IAAH,GAAU,KAAKwD,QAAf;AACAO,MAAAA,EAAE,CAAC8C,OAAH,GAAa,MAAb;AACA9C,MAAAA,EAAE,CAAC+C,IAAH,GAAU,KAAV;AACA,aAAO,KAAK7F,KAAL,EAAY0E,EAAZ,EAAgB,MAAM,KAAK1B,IAAL,CAAU,OAAV,EAAmBF,EAAnB,CAAtB,CAAP;AACD,KAfqE,CAiBtE;;;AACA,QAAI0C,SAAS,KAAKH,MAAlB,EAA0B;AACxB,WAAK,IAAIS,CAAC,GAAGN,SAAb,EAAwBM,CAAC,GAAG3D,MAAJ,IAAcqD,SAAS,GAAGF,WAAlD,EAA+DQ,CAAC,EAAhE,EAAoE;AAClEd,QAAAA,GAAG,CAACc,CAAC,GAAGX,MAAL,CAAH,GAAkB,CAAlB;AACAK,QAAAA,SAAS;AACTH,QAAAA,MAAM;AACP;AACF;;AAED,UAAMU,QAAQ,GAAGZ,MAAM,KAAK,CAAX,IAAgBK,SAAS,KAAKR,GAAG,CAAC7C,MAAlC,GACf6C,GADe,GACTA,GAAG,CAACgB,KAAJ,CAAUb,MAAV,EAAkBA,MAAM,GAAGK,SAA3B,CADR;AAEAH,IAAAA,MAAM,IAAIG,SAAV;AACAF,IAAAA,WAAW,IAAIE,SAAf;AACAJ,IAAAA,GAAG,IAAII,SAAP;AACAL,IAAAA,MAAM,IAAIK,SAAV;AAEA,SAAKxB,KAAL,CAAW+B,QAAX;;AAEA,QAAI,CAACV,MAAL,EAAa;AACX,UAAIC,WAAJ,EACE,KAAKtB,KAAL,CAAWiB,MAAM,CAACgB,KAAP,CAAaX,WAAb,CAAX;AACF,aAAO,KAAKtF,KAAL,EAAY0E,EAAZ,EAAgB5B,EAAE,IAAIA,EAAE,GAAG,KAAKE,IAAL,CAAU,OAAV,EAAmBF,EAAnB,CAAH,GAA4B,KAAKQ,GAAL,EAApD,CAAP;AACD;;AAED,QAAI6B,MAAM,IAAIhD,MAAd,EAAsB;AACpB6C,MAAAA,GAAG,GAAGC,MAAM,CAACC,WAAP,CAAmB/C,MAAnB,CAAN;AACAgD,MAAAA,MAAM,GAAG,CAAT;AACD;;AACDhD,IAAAA,MAAM,GAAG6C,GAAG,CAAC7C,MAAJ,GAAagD,MAAtB;AACA,SAAK1F,IAAL,EAAWiF,EAAX,EAAeM,GAAf,EAAoBG,MAApB,EAA4BhD,MAA5B,EAAoCiD,GAApC,EAAyCC,MAAzC,EAAiDC,WAAjD;AACD;;AA9PyD,CAAnC,CAAzB;;AAiQA,MAAMY,cAAN,SAA6B7F,UAA7B,CAAwC;AACtCC,EAAAA,WAAW,CAAEvB,IAAF,EAAQyB,GAAR,EAAa;AACtB,UAAMzB,IAAN,EAAYyB,GAAZ;AACD;;AAED,GAACd,KAAD,IAAW;AACT,SAAKC,OAAL,EAAcb,EAAE,CAACqH,SAAH,CAAa,KAAK5D,QAAlB,CAAd;AACD;;AAED,GAACjD,OAAD,IAAa;AACX,SAAKO,UAAL,EAAiBf,EAAE,CAACsH,YAAH,CAAgB,KAAK7D,QAArB,CAAjB;AACD;;AAED,GAACzC,QAAD,IAAc;AACZ,SAAKC,UAAL,EAAiBjB,EAAE,CAACuH,QAAH,CAAY,KAAK9D,QAAjB,EAA2B,GAA3B,CAAjB;AACD;;AAED,GAAC9C,IAAD,EAAQiF,EAAR,EAAYM,GAAZ,EAAiBG,MAAjB,EAAyBhD,MAAzB,EAAiCiD,GAAjC,EAAsCC,MAAtC,EAA8CC,WAA9C,EAA2D;AACzD,QAAIgB,KAAK,GAAG,IAAZ;;AACA,QAAI;AACF,YAAMd,SAAS,GAAG1G,EAAE,CAACyH,QAAH,CAAY7B,EAAZ,EAAgBM,GAAhB,EAAqBG,MAArB,EAA6BhD,MAA7B,EAAqCiD,GAArC,CAAlB;AACA,WAAKxF,MAAL,EAAa8E,EAAb,EAAiBM,GAAjB,EAAsBG,MAAtB,EAA8BhD,MAA9B,EAAsCiD,GAAtC,EAA2CC,MAA3C,EAAmDC,WAAnD,EAAgEE,SAAhE;AACAc,MAAAA,KAAK,GAAG,KAAR;AACD,KAJD,SAIU;AACR;AACA;AACA,UAAIA,KAAJ,EACE,IAAI;AAAE,aAAKtG,KAAL,EAAY0E,EAAZ,EAAgB,MAAM,CAAE,CAAxB;AAA2B,OAAjC,CAAkC,OAAO5B,EAAP,EAAW,CAAE;AAClD;AACF;;AAED,GAAC9C,KAAD,EAAS0E,EAAT,EAAae,EAAb,EAAiB;AACf3G,IAAAA,EAAE,CAAC0H,SAAH,CAAa9B,EAAb;AACAe,IAAAA,EAAE;AACH;;AAlCqC;;AAqCxC,MAAMgB,aAAa,GAAGvG,MAAM,CAAC,MAAMuG,aAAN,SAA4BhI,QAA5B,CAAqC;AAChE6B,EAAAA,WAAW,CAAEoG,SAAF,EAAalG,GAAb,EAAkB;AAC3BA,IAAAA,GAAG,GAAGA,GAAG,IAAI,EAAb;AACA,UAAMA,GAAN;AACA,SAAKY,aAAL,GAAqB,CAAC,CAACZ,GAAG,CAACY,aAA3B;AACA,SAAKV,QAAL,GAAgB,CAAC,CAACF,GAAG,CAACE,QAAtB;AACA,SAAKY,MAAL,GAAc,CAAC,CAACd,GAAG,CAACc,MAApB;AACA,SAAKC,KAAL,GAAa,CAAC,CAACf,GAAG,CAACe,KAAnB;AACA,SAAKC,OAAL,GAAe,CAAC,CAAChB,GAAG,CAACgB,OAArB;AAEA,SAAKkF,SAAL,GAAiBA,SAAjB;AACA,SAAKtD,IAAL,GAAYsD,SAAS,CAACtD,IAAtB;AACA,QAAI,KAAKA,IAAL,KAAc,WAAd,IAA6B,KAAK1C,QAAtC,EACE,KAAKc,OAAL,GAAe,IAAf;AAEF,SAAKzC,IAAL,GAAY2H,SAAS,CAAC3H,IAAtB;AACA,SAAKwE,IAAL,GAAY,KAAKtD,IAAL,EAAWyG,SAAS,CAACnD,IAArB,CAAZ;AACA,SAAKG,GAAL,GAAW,KAAKhD,QAAL,GAAgB,IAAhB,GAAuBgG,SAAS,CAAChD,GAA5C;AACA,SAAKC,GAAL,GAAW,KAAKjD,QAAL,GAAgB,IAAhB,GAAuBgG,SAAS,CAAC/C,GAA5C;AACA,SAAKC,KAAL,GAAa,KAAKlD,QAAL,GAAgB,IAAhB,GAAuBgG,SAAS,CAAC9C,KAA9C;AACA,SAAK+C,KAAL,GAAa,KAAKjG,QAAL,GAAgB,IAAhB,GAAuBgG,SAAS,CAACC,KAA9C;AACA,SAAKxD,IAAL,GAAYuD,SAAS,CAACvD,IAAtB;AACA,SAAK1B,KAAL,GAAa,KAAKD,OAAL,GAAe,IAAf,GAAsBhB,GAAG,CAACiB,KAAJ,IAAaiF,SAAS,CAACjF,KAA1D;AACA,SAAKoC,KAAL,GAAa,KAAKnD,QAAL,GAAgB,IAAhB,GAAuBgG,SAAS,CAAC7C,KAA9C;AACA,SAAKC,KAAL,GAAa,KAAKpD,QAAL,GAAgB,IAAhB,GAAuBgG,SAAS,CAAC5C,KAA9C;AACA,SAAKL,QAAL,GAAgBiD,SAAS,CAACjD,QAA1B;AAEA,QAAI,OAAOjD,GAAG,CAACkB,MAAX,KAAsB,UAA1B,EACE,KAAKC,EAAL,CAAQ,MAAR,EAAgBnB,GAAG,CAACkB,MAApB;AAEF,QAAIE,QAAQ,GAAG,KAAf;;AACA,QAAI7C,IAAI,CAAC+C,UAAL,CAAgB,KAAK/C,IAArB,KAA8B,CAAC,KAAKqC,aAAxC,EAAuD;AACrD,YAAMW,MAAM,GAAGhD,IAAI,CAACiD,KAAL,CAAW,KAAKjD,IAAhB,CAAf;AACA6C,MAAAA,QAAQ,GAAGG,MAAM,CAACG,IAAlB;AACA,WAAKnD,IAAL,GAAY,KAAKA,IAAL,CAAUkD,MAAV,CAAiBF,MAAM,CAACG,IAAP,CAAYC,MAA7B,CAAZ;AACD;;AAED,SAAKkD,MAAL,GAAcqB,SAAS,CAACvD,IAAxB;AACA,SAAKmC,WAAL,GAAmBoB,SAAS,CAACE,cAA7B;AAEA,SAAKpD,MAAL,GAAc,IAAI5E,MAAJ,CAAW;AACvBG,MAAAA,IAAI,EAAE,KAAKA,IADY;AAEvB0E,MAAAA,QAAQ,EAAE,KAAKA,QAFQ;AAGvB;AACA;AACAF,MAAAA,IAAI,EAAE,KAAKA,IALY;AAMvBG,MAAAA,GAAG,EAAE,KAAKhD,QAAL,GAAgB,IAAhB,GAAuB,KAAKgD,GANV;AAOvBC,MAAAA,GAAG,EAAE,KAAKjD,QAAL,GAAgB,IAAhB,GAAuB,KAAKiD,GAPV;AAQvBR,MAAAA,IAAI,EAAE,KAAKA,IARY;AASvB1B,MAAAA,KAAK,EAAE,KAAKD,OAAL,GAAe,IAAf,GAAsB,KAAKC,KATX;AAUvB2B,MAAAA,IAAI,EAAE,KAAKA,IAVY;AAWvBQ,MAAAA,KAAK,EAAE,KAAKlD,QAAL,GAAgB,IAAhB,GAAuB,KAAKkD,KAXZ;AAYvBC,MAAAA,KAAK,EAAE,KAAKnD,QAAL,GAAgB,IAAhB,GAAuB,KAAKmD,KAZZ;AAavBC,MAAAA,KAAK,EAAE,KAAKpD,QAAL,GAAgB,IAAhB,GAAuB,KAAKoD;AAbZ,KAAX,CAAd;;AAgBA,QAAIlC,QAAJ,EAAc;AACZ,WAAKa,IAAL,CAAU,gBAAV,EAA6B,aAAYb,QAAS,qBAAlD,EAAwE;AACtEc,QAAAA,KAAK,EAAE,IAD+D;AAEtE3D,QAAAA,IAAI,EAAE6C,QAAQ,GAAG,KAAK7C;AAFgD,OAAxE;AAID;;AAED,QAAI,KAAKyE,MAAL,CAAYO,MAAZ,MAAwB,CAAC,KAAKxC,KAAlC,EACE,MAAMyC,KAAN,CAAY,IAAIrF,GAAJ,CAAQ;AAClBkF,MAAAA,KAAK,EAAE,KAAKnD,QAAL,GAAgB,IAAhB,GAAuB,KAAKmD,KADjB;AAElBC,MAAAA,KAAK,EAAE,KAAKpD,QAAL,GAAgB,IAAhB,GAAuB,KAAKoD,KAFjB;AAGlBH,MAAAA,GAAG,EAAE,KAAKjD,QAAL,GAAgB,IAAhB,GAAuB,KAAKiD,GAHf;AAIlBlC,MAAAA,KAAK,EAAE,KAAKD,OAAL,GAAe,IAAf,GAAsB,KAAKC,KAJhB;AAKlB1C,MAAAA,IAAI,EAAE,KAAKA,IALO;AAMlB0E,MAAAA,QAAQ,EAAE,KAAKA,QANG;AAOlBN,MAAAA,IAAI,EAAE,KAAKA,IAPO;AAQlBO,MAAAA,GAAG,EAAE,KAAKhD,QAAL,GAAgB,IAAhB,GAAuB,KAAKgD,GARf;AASlBE,MAAAA,KAAK,EAAE,KAAKlD,QAAL,GAAgB,IAAhB,GAAuB,KAAKkD,KATjB;AAUlBK,MAAAA,GAAG,EAAE,KAAKvD,QAAL,GAAgB,IAAhB,GAAuB,KAAKgG,SAAL,CAAezC,GAVzB;AAWlBC,MAAAA,GAAG,EAAE,KAAKxD,QAAL,GAAgB,IAAhB,GAAuB,KAAKgG,SAAL,CAAexC,GAXzB;AAYlBC,MAAAA,KAAK,EAAE,KAAKzD,QAAL,GAAgB,IAAhB,GAAuB,KAAKgG,SAAL,CAAevC;AAZ3B,KAAR,EAaTJ,MAbS,EAAZ;AAeF,UAAMC,KAAN,CAAY,KAAKR,MAAL,CAAYY,KAAxB;AACAsC,IAAAA,SAAS,CAACG,IAAV,CAAe,IAAf;AACD;;AAED,GAAC5G,IAAD,EAAQsD,IAAR,EAAc;AACZ,WAAOnD,OAAO,CAACmD,IAAD,EAAO,KAAKH,IAAL,KAAc,WAArB,EAAkC,KAAK1C,QAAvC,CAAd;AACD;;AAEDsD,EAAAA,KAAK,CAAE8C,IAAF,EAAQ;AACX,UAAMC,QAAQ,GAAGD,IAAI,CAAC3E,MAAtB;AACA,QAAI4E,QAAQ,GAAG,KAAKzB,WAApB,EACE,MAAM,IAAIK,KAAJ,CAAU,2CAAV,CAAN;AACF,SAAKL,WAAL,IAAoByB,QAApB;AACA,WAAO,MAAM/C,KAAN,CAAY8C,IAAZ,CAAP;AACD;;AAEDxD,EAAAA,GAAG,GAAI;AACL,QAAI,KAAKgC,WAAT,EACE,KAAKtB,KAAL,CAAWiB,MAAM,CAACgB,KAAP,CAAa,KAAKX,WAAlB,CAAX;AACF,WAAO,MAAMhC,GAAN,EAAP;AACD;;AAnG+D,CAAtC,CAA5B;AAsGAjD,UAAU,CAAC2G,IAAX,GAAkBd,cAAlB;AACA7F,UAAU,CAAC4G,GAAX,GAAiBR,aAAjB;;AAEA,MAAMpD,OAAO,GAAGN,IAAI,IAClBA,IAAI,CAACG,MAAL,KAAgB,MAAhB,GACEH,IAAI,CAACmE,WAAL,KAAqB,WAArB,GACAnE,IAAI,CAACoE,cAAL,KAAwB,cAAxB,GACA,aAJJ;;AAMAC,MAAM,CAACC,OAAP,GAAiBhH,UAAjB","sourcesContent":["'use strict'\nconst MiniPass = require('minipass')\nconst Pax = require('./pax.js')\nconst Header = require('./header.js')\nconst ReadEntry = require('./read-entry.js')\nconst fs = require('fs')\nconst path = require('path')\n\nconst types = require('./types.js')\nconst maxReadSize = 16 * 1024 * 1024\nconst PROCESS = Symbol('process')\nconst FILE = Symbol('file')\nconst DIRECTORY = Symbol('directory')\nconst SYMLINK = Symbol('symlink')\nconst HARDLINK = Symbol('hardlink')\nconst HEADER = Symbol('header')\nconst READ = Symbol('read')\nconst LSTAT = Symbol('lstat')\nconst ONLSTAT = Symbol('onlstat')\nconst ONREAD = Symbol('onread')\nconst ONREADLINK = Symbol('onreadlink')\nconst OPENFILE = Symbol('openfile')\nconst ONOPENFILE = Symbol('onopenfile')\nconst CLOSE = Symbol('close')\nconst MODE = Symbol('mode')\nconst warner = require('./warn-mixin.js')\nconst winchars = require('./winchars.js')\n\nconst modeFix = require('./mode-fix.js')\n\nconst WriteEntry = warner(class WriteEntry extends MiniPass {\n  constructor (p, opt) {\n    opt = opt || {}\n    super(opt)\n    if (typeof p !== 'string')\n      throw new TypeError('path is required')\n    this.path = p\n    // suppress atime, ctime, uid, gid, uname, gname\n    this.portable = !!opt.portable\n    // until node has builtin pwnam functions, this'll have to do\n    this.myuid = process.getuid && process.getuid()\n    this.myuser = process.env.USER || ''\n    this.maxReadSize = opt.maxReadSize || maxReadSize\n    this.linkCache = opt.linkCache || new Map()\n    this.statCache = opt.statCache || new Map()\n    this.preservePaths = !!opt.preservePaths\n    this.cwd = opt.cwd || process.cwd()\n    this.strict = !!opt.strict\n    this.noPax = !!opt.noPax\n    this.noMtime = !!opt.noMtime\n    this.mtime = opt.mtime || null\n\n    if (typeof opt.onwarn === 'function')\n      this.on('warn', opt.onwarn)\n\n    let pathWarn = false\n    if (!this.preservePaths && path.win32.isAbsolute(p)) {\n      // absolutes on posix are also absolutes on win32\n      // so we only need to test this one to get both\n      const parsed = path.win32.parse(p)\n      this.path = p.substr(parsed.root.length)\n      pathWarn = parsed.root\n    }\n\n    this.win32 = !!opt.win32 || process.platform === 'win32'\n    if (this.win32) {\n      this.path = winchars.decode(this.path.replace(/\\\\/g, '/'))\n      p = p.replace(/\\\\/g, '/')\n    }\n\n    this.absolute = opt.absolute || path.resolve(this.cwd, p)\n\n    if (this.path === '')\n      this.path = './'\n\n    if (pathWarn) {\n      this.warn('TAR_ENTRY_INFO', `stripping ${pathWarn} from absolute path`, {\n        entry: this,\n        path: pathWarn + this.path,\n      })\n    }\n\n    if (this.statCache.has(this.absolute))\n      this[ONLSTAT](this.statCache.get(this.absolute))\n    else\n      this[LSTAT]()\n  }\n\n  [LSTAT] () {\n    fs.lstat(this.absolute, (er, stat) => {\n      if (er)\n        return this.emit('error', er)\n      this[ONLSTAT](stat)\n    })\n  }\n\n  [ONLSTAT] (stat) {\n    this.statCache.set(this.absolute, stat)\n    this.stat = stat\n    if (!stat.isFile())\n      stat.size = 0\n    this.type = getType(stat)\n    this.emit('stat', stat)\n    this[PROCESS]()\n  }\n\n  [PROCESS] () {\n    switch (this.type) {\n      case 'File': return this[FILE]()\n      case 'Directory': return this[DIRECTORY]()\n      case 'SymbolicLink': return this[SYMLINK]()\n      // unsupported types are ignored.\n      default: return this.end()\n    }\n  }\n\n  [MODE] (mode) {\n    return modeFix(mode, this.type === 'Directory', this.portable)\n  }\n\n  [HEADER] () {\n    if (this.type === 'Directory' && this.portable)\n      this.noMtime = true\n\n    this.header = new Header({\n      path: this.path,\n      linkpath: this.linkpath,\n      // only the permissions and setuid/setgid/sticky bitflags\n      // not the higher-order bits that specify file type\n      mode: this[MODE](this.stat.mode),\n      uid: this.portable ? null : this.stat.uid,\n      gid: this.portable ? null : this.stat.gid,\n      size: this.stat.size,\n      mtime: this.noMtime ? null : this.mtime || this.stat.mtime,\n      type: this.type,\n      uname: this.portable ? null :\n        this.stat.uid === this.myuid ? this.myuser : '',\n      atime: this.portable ? null : this.stat.atime,\n      ctime: this.portable ? null : this.stat.ctime\n    })\n\n    if (this.header.encode() && !this.noPax)\n      this.write(new Pax({\n        atime: this.portable ? null : this.header.atime,\n        ctime: this.portable ? null : this.header.ctime,\n        gid: this.portable ? null : this.header.gid,\n        mtime: this.noMtime ? null : this.mtime || this.header.mtime,\n        path: this.path,\n        linkpath: this.linkpath,\n        size: this.header.size,\n        uid: this.portable ? null : this.header.uid,\n        uname: this.portable ? null : this.header.uname,\n        dev: this.portable ? null : this.stat.dev,\n        ino: this.portable ? null : this.stat.ino,\n        nlink: this.portable ? null : this.stat.nlink\n      }).encode())\n    this.write(this.header.block)\n  }\n\n  [DIRECTORY] () {\n    if (this.path.substr(-1) !== '/')\n      this.path += '/'\n    this.stat.size = 0\n    this[HEADER]()\n    this.end()\n  }\n\n  [SYMLINK] () {\n    fs.readlink(this.absolute, (er, linkpath) => {\n      if (er)\n        return this.emit('error', er)\n      this[ONREADLINK](linkpath)\n    })\n  }\n\n  [ONREADLINK] (linkpath) {\n    this.linkpath = linkpath.replace(/\\\\/g, '/')\n    this[HEADER]()\n    this.end()\n  }\n\n  [HARDLINK] (linkpath) {\n    this.type = 'Link'\n    this.linkpath = path.relative(this.cwd, linkpath).replace(/\\\\/g, '/')\n    this.stat.size = 0\n    this[HEADER]()\n    this.end()\n  }\n\n  [FILE] () {\n    if (this.stat.nlink > 1) {\n      const linkKey = this.stat.dev + ':' + this.stat.ino\n      if (this.linkCache.has(linkKey)) {\n        const linkpath = this.linkCache.get(linkKey)\n        if (linkpath.indexOf(this.cwd) === 0)\n          return this[HARDLINK](linkpath)\n      }\n      this.linkCache.set(linkKey, this.absolute)\n    }\n\n    this[HEADER]()\n    if (this.stat.size === 0)\n      return this.end()\n\n    this[OPENFILE]()\n  }\n\n  [OPENFILE] () {\n    fs.open(this.absolute, 'r', (er, fd) => {\n      if (er)\n        return this.emit('error', er)\n      this[ONOPENFILE](fd)\n    })\n  }\n\n  [ONOPENFILE] (fd) {\n    const blockLen = 512 * Math.ceil(this.stat.size / 512)\n    const bufLen = Math.min(blockLen, this.maxReadSize)\n    const buf = Buffer.allocUnsafe(bufLen)\n    this[READ](fd, buf, 0, buf.length, 0, this.stat.size, blockLen)\n  }\n\n  [READ] (fd, buf, offset, length, pos, remain, blockRemain) {\n    fs.read(fd, buf, offset, length, pos, (er, bytesRead) => {\n      if (er) {\n        // ignoring the error from close(2) is a bad practice, but at\n        // this point we already have an error, don't need another one\n        return this[CLOSE](fd, () => this.emit('error', er))\n      }\n      this[ONREAD](fd, buf, offset, length, pos, remain, blockRemain, bytesRead)\n    })\n  }\n\n  [CLOSE] (fd, cb) {\n    fs.close(fd, cb)\n  }\n\n  [ONREAD] (fd, buf, offset, length, pos, remain, blockRemain, bytesRead) {\n    if (bytesRead <= 0 && remain > 0) {\n      const er = new Error('encountered unexpected EOF')\n      er.path = this.absolute\n      er.syscall = 'read'\n      er.code = 'EOF'\n      return this[CLOSE](fd, () => this.emit('error', er))\n    }\n\n    if (bytesRead > remain) {\n      const er = new Error('did not encounter expected EOF')\n      er.path = this.absolute\n      er.syscall = 'read'\n      er.code = 'EOF'\n      return this[CLOSE](fd, () => this.emit('error', er))\n    }\n\n    // null out the rest of the buffer, if we could fit the block padding\n    if (bytesRead === remain) {\n      for (let i = bytesRead; i < length && bytesRead < blockRemain; i++) {\n        buf[i + offset] = 0\n        bytesRead ++\n        remain ++\n      }\n    }\n\n    const writeBuf = offset === 0 && bytesRead === buf.length ?\n      buf : buf.slice(offset, offset + bytesRead)\n    remain -= bytesRead\n    blockRemain -= bytesRead\n    pos += bytesRead\n    offset += bytesRead\n\n    this.write(writeBuf)\n\n    if (!remain) {\n      if (blockRemain)\n        this.write(Buffer.alloc(blockRemain))\n      return this[CLOSE](fd, er => er ? this.emit('error', er) : this.end())\n    }\n\n    if (offset >= length) {\n      buf = Buffer.allocUnsafe(length)\n      offset = 0\n    }\n    length = buf.length - offset\n    this[READ](fd, buf, offset, length, pos, remain, blockRemain)\n  }\n})\n\nclass WriteEntrySync extends WriteEntry {\n  constructor (path, opt) {\n    super(path, opt)\n  }\n\n  [LSTAT] () {\n    this[ONLSTAT](fs.lstatSync(this.absolute))\n  }\n\n  [SYMLINK] () {\n    this[ONREADLINK](fs.readlinkSync(this.absolute))\n  }\n\n  [OPENFILE] () {\n    this[ONOPENFILE](fs.openSync(this.absolute, 'r'))\n  }\n\n  [READ] (fd, buf, offset, length, pos, remain, blockRemain) {\n    let threw = true\n    try {\n      const bytesRead = fs.readSync(fd, buf, offset, length, pos)\n      this[ONREAD](fd, buf, offset, length, pos, remain, blockRemain, bytesRead)\n      threw = false\n    } finally {\n      // ignoring the error from close(2) is a bad practice, but at\n      // this point we already have an error, don't need another one\n      if (threw)\n        try { this[CLOSE](fd, () => {}) } catch (er) {}\n    }\n  }\n\n  [CLOSE] (fd, cb) {\n    fs.closeSync(fd)\n    cb()\n  }\n}\n\nconst WriteEntryTar = warner(class WriteEntryTar extends MiniPass {\n  constructor (readEntry, opt) {\n    opt = opt || {}\n    super(opt)\n    this.preservePaths = !!opt.preservePaths\n    this.portable = !!opt.portable\n    this.strict = !!opt.strict\n    this.noPax = !!opt.noPax\n    this.noMtime = !!opt.noMtime\n\n    this.readEntry = readEntry\n    this.type = readEntry.type\n    if (this.type === 'Directory' && this.portable)\n      this.noMtime = true\n\n    this.path = readEntry.path\n    this.mode = this[MODE](readEntry.mode)\n    this.uid = this.portable ? null : readEntry.uid\n    this.gid = this.portable ? null : readEntry.gid\n    this.uname = this.portable ? null : readEntry.uname\n    this.gname = this.portable ? null : readEntry.gname\n    this.size = readEntry.size\n    this.mtime = this.noMtime ? null : opt.mtime || readEntry.mtime\n    this.atime = this.portable ? null : readEntry.atime\n    this.ctime = this.portable ? null : readEntry.ctime\n    this.linkpath = readEntry.linkpath\n\n    if (typeof opt.onwarn === 'function')\n      this.on('warn', opt.onwarn)\n\n    let pathWarn = false\n    if (path.isAbsolute(this.path) && !this.preservePaths) {\n      const parsed = path.parse(this.path)\n      pathWarn = parsed.root\n      this.path = this.path.substr(parsed.root.length)\n    }\n\n    this.remain = readEntry.size\n    this.blockRemain = readEntry.startBlockSize\n\n    this.header = new Header({\n      path: this.path,\n      linkpath: this.linkpath,\n      // only the permissions and setuid/setgid/sticky bitflags\n      // not the higher-order bits that specify file type\n      mode: this.mode,\n      uid: this.portable ? null : this.uid,\n      gid: this.portable ? null : this.gid,\n      size: this.size,\n      mtime: this.noMtime ? null : this.mtime,\n      type: this.type,\n      uname: this.portable ? null : this.uname,\n      atime: this.portable ? null : this.atime,\n      ctime: this.portable ? null : this.ctime\n    })\n\n    if (pathWarn) {\n      this.warn('TAR_ENTRY_INFO', `stripping ${pathWarn} from absolute path`, {\n        entry: this,\n        path: pathWarn + this.path,\n      })\n    }\n\n    if (this.header.encode() && !this.noPax)\n      super.write(new Pax({\n        atime: this.portable ? null : this.atime,\n        ctime: this.portable ? null : this.ctime,\n        gid: this.portable ? null : this.gid,\n        mtime: this.noMtime ? null : this.mtime,\n        path: this.path,\n        linkpath: this.linkpath,\n        size: this.size,\n        uid: this.portable ? null : this.uid,\n        uname: this.portable ? null : this.uname,\n        dev: this.portable ? null : this.readEntry.dev,\n        ino: this.portable ? null : this.readEntry.ino,\n        nlink: this.portable ? null : this.readEntry.nlink\n      }).encode())\n\n    super.write(this.header.block)\n    readEntry.pipe(this)\n  }\n\n  [MODE] (mode) {\n    return modeFix(mode, this.type === 'Directory', this.portable)\n  }\n\n  write (data) {\n    const writeLen = data.length\n    if (writeLen > this.blockRemain)\n      throw new Error('writing more to entry than is appropriate')\n    this.blockRemain -= writeLen\n    return super.write(data)\n  }\n\n  end () {\n    if (this.blockRemain)\n      this.write(Buffer.alloc(this.blockRemain))\n    return super.end()\n  }\n})\n\nWriteEntry.Sync = WriteEntrySync\nWriteEntry.Tar = WriteEntryTar\n\nconst getType = stat =>\n  stat.isFile() ? 'File'\n  : stat.isDirectory() ? 'Directory'\n  : stat.isSymbolicLink() ? 'SymbolicLink'\n  : 'Unsupported'\n\nmodule.exports = WriteEntry\n"]},"metadata":{},"sourceType":"script"}