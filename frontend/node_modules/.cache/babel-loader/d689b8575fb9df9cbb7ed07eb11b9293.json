{"ast":null,"code":"'use strict';\n\nconst fs = require('fs');\n\nconst path = require('path');\n\nconst EE = require('events').EventEmitter;\n\nconst Minimatch = require('minimatch').Minimatch;\n\nclass Walker extends EE {\n  constructor(opts) {\n    opts = opts || {};\n    super(opts);\n    this.path = opts.path || process.cwd();\n    this.basename = path.basename(this.path);\n    this.ignoreFiles = opts.ignoreFiles || ['.ignore'];\n    this.ignoreRules = {};\n    this.parent = opts.parent || null;\n    this.includeEmpty = !!opts.includeEmpty;\n    this.root = this.parent ? this.parent.root : this.path;\n    this.follow = !!opts.follow;\n    this.result = this.parent ? this.parent.result : new Set();\n    this.entries = null;\n    this.sawError = false;\n  }\n\n  sort(a, b) {\n    return a.localeCompare(b);\n  }\n\n  emit(ev, data) {\n    let ret = false;\n\n    if (!(this.sawError && ev === 'error')) {\n      if (ev === 'error') this.sawError = true;else if (ev === 'done' && !this.parent) {\n        data = Array.from(data).map(e => /^@/.test(e) ? `./${e}` : e).sort(this.sort);\n        this.result = data;\n      }\n      if (ev === 'error' && this.parent) ret = this.parent.emit('error', data);else ret = super.emit(ev, data);\n    }\n\n    return ret;\n  }\n\n  start() {\n    fs.readdir(this.path, (er, entries) => er ? this.emit('error', er) : this.onReaddir(entries));\n    return this;\n  }\n\n  isIgnoreFile(e) {\n    return e !== \".\" && e !== \"..\" && -1 !== this.ignoreFiles.indexOf(e);\n  }\n\n  onReaddir(entries) {\n    this.entries = entries;\n\n    if (entries.length === 0) {\n      if (this.includeEmpty) this.result.add(this.path.substr(this.root.length + 1));\n      this.emit('done', this.result);\n    } else {\n      const hasIg = this.entries.some(e => this.isIgnoreFile(e));\n      if (hasIg) this.addIgnoreFiles();else this.filterEntries();\n    }\n  }\n\n  addIgnoreFiles() {\n    const newIg = this.entries.filter(e => this.isIgnoreFile(e));\n    let igCount = newIg.length;\n\n    const then = _ => {\n      if (--igCount === 0) this.filterEntries();\n    };\n\n    newIg.forEach(e => this.addIgnoreFile(e, then));\n  }\n\n  addIgnoreFile(file, then) {\n    const ig = path.resolve(this.path, file);\n    fs.readFile(ig, 'utf8', (er, data) => er ? this.emit('error', er) : this.onReadIgnoreFile(file, data, then));\n  }\n\n  onReadIgnoreFile(file, data, then) {\n    const mmopt = {\n      matchBase: true,\n      dot: true,\n      flipNegate: true,\n      nocase: true\n    };\n    const rules = data.split(/\\r?\\n/).filter(line => !/^#|^$/.test(line.trim())).map(r => new Minimatch(r, mmopt));\n    this.ignoreRules[file] = rules;\n    then();\n  }\n\n  filterEntries() {\n    // at this point we either have ignore rules, or just inheriting\n    // this exclusion is at the point where we know the list of\n    // entries in the dir, but don't know what they are.  since\n    // some of them *might* be directories, we have to run the\n    // match in dir-mode as well, so that we'll pick up partials\n    // of files that will be included later.  Anything included\n    // at this point will be checked again later once we know\n    // what it is.\n    const filtered = this.entries.map(entry => {\n      // at this point, we don't know if it's a dir or not.\n      const passFile = this.filterEntry(entry);\n      const passDir = this.filterEntry(entry, true);\n      return passFile || passDir ? [entry, passFile, passDir] : false;\n    }).filter(e => e); // now we stat them all\n    // if it's a dir, and passes as a dir, then recurse\n    // if it's not a dir, but passes as a file, add to set\n\n    let entryCount = filtered.length;\n\n    if (entryCount === 0) {\n      this.emit('done', this.result);\n    } else {\n      const then = _ => {\n        if (--entryCount === 0) this.emit('done', this.result);\n      };\n\n      filtered.forEach(filt => {\n        const entry = filt[0];\n        const file = filt[1];\n        const dir = filt[2];\n        this.stat(entry, file, dir, then);\n      });\n    }\n  }\n\n  onstat(st, entry, file, dir, then) {\n    const abs = this.path + '/' + entry;\n\n    if (!st.isDirectory()) {\n      if (file) this.result.add(abs.substr(this.root.length + 1));\n      then();\n    } else {\n      // is a directory\n      if (dir) this.walker(entry, then);else then();\n    }\n  }\n\n  stat(entry, file, dir, then) {\n    const abs = this.path + '/' + entry;\n    fs[this.follow ? 'stat' : 'lstat'](abs, (er, st) => {\n      if (er) this.emit('error', er);else this.onstat(st, entry, file, dir, then);\n    });\n  }\n\n  walkerOpt(entry) {\n    return {\n      path: this.path + '/' + entry,\n      parent: this,\n      ignoreFiles: this.ignoreFiles,\n      follow: this.follow,\n      includeEmpty: this.includeEmpty\n    };\n  }\n\n  walker(entry, then) {\n    new Walker(this.walkerOpt(entry)).on('done', then).start();\n  }\n\n  filterEntry(entry, partial) {\n    let included = true; // this = /a/b/c\n    // entry = d\n    // parent /a/b sees c/d\n\n    if (this.parent && this.parent.filterEntry) {\n      var pt = this.basename + \"/\" + entry;\n      included = this.parent.filterEntry(pt, partial);\n    }\n\n    this.ignoreFiles.forEach(f => {\n      if (this.ignoreRules[f]) {\n        this.ignoreRules[f].forEach(rule => {\n          // negation means inclusion\n          // so if it's negated, and already included, no need to check\n          // likewise if it's neither negated nor included\n          if (rule.negate !== included) {\n            // first, match against /foo/bar\n            // then, against foo/bar\n            // then, in the case of partials, match with a /\n            const match = rule.match('/' + entry) || rule.match(entry) || !!partial && (rule.match('/' + entry + '/') || rule.match(entry + '/')) || !!partial && rule.negate && (rule.match('/' + entry, true) || rule.match(entry, true));\n            if (match) included = rule.negate;\n          }\n        });\n      }\n    });\n    return included;\n  }\n\n}\n\nclass WalkerSync extends Walker {\n  constructor(opt) {\n    super(opt);\n  }\n\n  start() {\n    this.onReaddir(fs.readdirSync(this.path));\n    return this;\n  }\n\n  addIgnoreFile(file, then) {\n    const ig = path.resolve(this.path, file);\n    this.onReadIgnoreFile(file, fs.readFileSync(ig, 'utf8'), then);\n  }\n\n  stat(entry, file, dir, then) {\n    const abs = this.path + '/' + entry;\n    const st = fs[this.follow ? 'statSync' : 'lstatSync'](abs);\n    this.onstat(st, entry, file, dir, then);\n  }\n\n  walker(entry, then) {\n    new WalkerSync(this.walkerOpt(entry)).start();\n    then();\n  }\n\n}\n\nconst walk = (options, callback) => {\n  const p = new Promise((resolve, reject) => {\n    new Walker(options).on('done', resolve).on('error', reject).start();\n  });\n  return callback ? p.then(res => callback(null, res), callback) : p;\n};\n\nconst walkSync = options => {\n  return new WalkerSync(options).start().result;\n};\n\nmodule.exports = walk;\nwalk.sync = walkSync;\nwalk.Walker = Walker;\nwalk.WalkerSync = WalkerSync;","map":{"version":3,"sources":["/home/n/React/loginpagedemo/frontend/node_modules/ignore-walk/index.js"],"names":["fs","require","path","EE","EventEmitter","Minimatch","Walker","constructor","opts","process","cwd","basename","ignoreFiles","ignoreRules","parent","includeEmpty","root","follow","result","Set","entries","sawError","sort","a","b","localeCompare","emit","ev","data","ret","Array","from","map","e","test","start","readdir","er","onReaddir","isIgnoreFile","indexOf","length","add","substr","hasIg","some","addIgnoreFiles","filterEntries","newIg","filter","igCount","then","_","forEach","addIgnoreFile","file","ig","resolve","readFile","onReadIgnoreFile","mmopt","matchBase","dot","flipNegate","nocase","rules","split","line","trim","r","filtered","entry","passFile","filterEntry","passDir","entryCount","filt","dir","stat","onstat","st","abs","isDirectory","walker","walkerOpt","on","partial","included","pt","f","rule","negate","match","WalkerSync","opt","readdirSync","readFileSync","walk","options","callback","p","Promise","reject","res","walkSync","module","exports","sync"],"mappings":"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","sourcesContent":["'use strict'\n\nconst fs = require('fs')\nconst path = require('path')\nconst EE = require('events').EventEmitter\nconst Minimatch = require('minimatch').Minimatch\n\nclass Walker extends EE {\n  constructor (opts) {\n    opts = opts || {}\n    super(opts)\n    this.path = opts.path || process.cwd()\n    this.basename = path.basename(this.path)\n    this.ignoreFiles = opts.ignoreFiles || [ '.ignore' ]\n    this.ignoreRules = {}\n    this.parent = opts.parent || null\n    this.includeEmpty = !!opts.includeEmpty\n    this.root = this.parent ? this.parent.root : this.path\n    this.follow = !!opts.follow\n    this.result = this.parent ? this.parent.result : new Set()\n    this.entries = null\n    this.sawError = false\n  }\n\n  sort (a, b) {\n    return a.localeCompare(b)\n  }\n\n  emit (ev, data) {\n    let ret = false\n    if (!(this.sawError && ev === 'error')) {\n      if (ev === 'error')\n        this.sawError = true\n      else if (ev === 'done' && !this.parent) {\n        data = Array.from(data)\n          .map(e => /^@/.test(e) ? `./${e}` : e).sort(this.sort)\n        this.result = data\n      }\n\n      if (ev === 'error' && this.parent)\n        ret = this.parent.emit('error', data)\n      else\n        ret = super.emit(ev, data)\n    }\n    return ret\n  }\n\n  start () {\n    fs.readdir(this.path, (er, entries) =>\n      er ? this.emit('error', er) : this.onReaddir(entries))\n    return this\n  }\n\n  isIgnoreFile (e) {\n    return e !== \".\" &&\n      e !== \"..\" &&\n      -1 !== this.ignoreFiles.indexOf(e)\n  }\n\n  onReaddir (entries) {\n    this.entries = entries\n    if (entries.length === 0) {\n      if (this.includeEmpty)\n        this.result.add(this.path.substr(this.root.length + 1))\n      this.emit('done', this.result)\n    } else {\n      const hasIg = this.entries.some(e =>\n        this.isIgnoreFile(e))\n\n      if (hasIg)\n        this.addIgnoreFiles()\n      else\n        this.filterEntries()\n    }\n  }\n\n  addIgnoreFiles () {\n    const newIg = this.entries\n      .filter(e => this.isIgnoreFile(e))\n\n    let igCount = newIg.length\n    const then = _ => {\n      if (--igCount === 0)\n        this.filterEntries()\n    }\n\n    newIg.forEach(e => this.addIgnoreFile(e, then))\n  }\n\n  addIgnoreFile (file, then) {\n    const ig = path.resolve(this.path, file)\n    fs.readFile(ig, 'utf8', (er, data) =>\n      er ? this.emit('error', er) : this.onReadIgnoreFile(file, data, then))\n  }\n\n  onReadIgnoreFile (file, data, then) {\n    const mmopt = {\n      matchBase: true,\n      dot: true,\n      flipNegate: true,\n      nocase: true\n    }\n    const rules = data.split(/\\r?\\n/)\n      .filter(line => !/^#|^$/.test(line.trim()))\n      .map(r => new Minimatch(r, mmopt))\n\n    this.ignoreRules[file] = rules\n\n    then()\n  }\n\n  filterEntries () {\n    // at this point we either have ignore rules, or just inheriting\n    // this exclusion is at the point where we know the list of\n    // entries in the dir, but don't know what they are.  since\n    // some of them *might* be directories, we have to run the\n    // match in dir-mode as well, so that we'll pick up partials\n    // of files that will be included later.  Anything included\n    // at this point will be checked again later once we know\n    // what it is.\n    const filtered = this.entries.map(entry => {\n      // at this point, we don't know if it's a dir or not.\n      const passFile = this.filterEntry(entry)\n      const passDir = this.filterEntry(entry, true)\n      return (passFile || passDir) ? [entry, passFile, passDir] : false\n    }).filter(e => e)\n\n    // now we stat them all\n    // if it's a dir, and passes as a dir, then recurse\n    // if it's not a dir, but passes as a file, add to set\n    let entryCount = filtered.length\n    if (entryCount === 0) {\n      this.emit('done', this.result)\n    } else {\n      const then = _ => {\n        if (-- entryCount === 0)\n          this.emit('done', this.result)\n      }\n      filtered.forEach(filt => {\n        const entry = filt[0]\n        const file = filt[1]\n        const dir = filt[2]\n        this.stat(entry, file, dir, then)\n      })\n    }\n  }\n\n  onstat (st, entry, file, dir, then) {\n    const abs = this.path + '/' + entry\n    if (!st.isDirectory()) {\n      if (file)\n        this.result.add(abs.substr(this.root.length + 1))\n      then()\n    } else {\n      // is a directory\n      if (dir)\n        this.walker(entry, then)\n      else\n        then()\n    }\n  }\n\n  stat (entry, file, dir, then) {\n    const abs = this.path + '/' + entry\n    fs[this.follow ? 'stat' : 'lstat'](abs, (er, st) => {\n      if (er)\n        this.emit('error', er)\n      else\n        this.onstat(st, entry, file, dir, then)\n    })\n  }\n\n  walkerOpt (entry) {\n    return {\n      path: this.path + '/' + entry,\n      parent: this,\n      ignoreFiles: this.ignoreFiles,\n      follow: this.follow,\n      includeEmpty: this.includeEmpty\n    }\n  }\n\n  walker (entry, then) {\n    new Walker(this.walkerOpt(entry)).on('done', then).start()\n  }\n\n  filterEntry (entry, partial) {\n    let included = true\n\n    // this = /a/b/c\n    // entry = d\n    // parent /a/b sees c/d\n    if (this.parent && this.parent.filterEntry) {\n      var pt = this.basename + \"/\" + entry\n      included = this.parent.filterEntry(pt, partial)\n    }\n\n    this.ignoreFiles.forEach(f => {\n      if (this.ignoreRules[f]) {\n        this.ignoreRules[f].forEach(rule => {\n          // negation means inclusion\n          // so if it's negated, and already included, no need to check\n          // likewise if it's neither negated nor included\n          if (rule.negate !== included) {\n            // first, match against /foo/bar\n            // then, against foo/bar\n            // then, in the case of partials, match with a /\n            const match = rule.match('/' + entry) ||\n              rule.match(entry) ||\n              (!!partial && (\n                rule.match('/' + entry + '/') ||\n                rule.match(entry + '/'))) ||\n              (!!partial && rule.negate && (\n                rule.match('/' + entry, true) ||\n                rule.match(entry, true)))\n\n            if (match)\n              included = rule.negate\n          }\n        })\n      }\n    })\n\n    return included\n  }\n}\n\nclass WalkerSync extends Walker {\n  constructor (opt) {\n    super(opt)\n  }\n\n  start () {\n    this.onReaddir(fs.readdirSync(this.path))\n    return this\n  }\n\n  addIgnoreFile (file, then) {\n    const ig = path.resolve(this.path, file)\n    this.onReadIgnoreFile(file, fs.readFileSync(ig, 'utf8'), then)\n  }\n\n  stat (entry, file, dir, then) {\n    const abs = this.path + '/' + entry\n    const st = fs[this.follow ? 'statSync' : 'lstatSync'](abs)\n    this.onstat(st, entry, file, dir, then)\n  }\n\n  walker (entry, then) {\n    new WalkerSync(this.walkerOpt(entry)).start()\n    then()\n  }\n}\n\nconst walk = (options, callback) => {\n  const p = new Promise((resolve, reject) => {\n    new Walker(options).on('done', resolve).on('error', reject).start()\n  })\n  return callback ? p.then(res => callback(null, res), callback) : p\n}\n\nconst walkSync = options => {\n  return new WalkerSync(options).start().result\n}\n\nmodule.exports = walk\nwalk.sync = walkSync\nwalk.Walker = Walker\nwalk.WalkerSync = WalkerSync\n"]},"metadata":{},"sourceType":"script"}