{"ast":null,"code":"'use strict';\n\nconst Buffer = require('./buffer.js');\n\nconst MiniPass = require('minipass');\n\nconst Pax = require('./pax.js');\n\nconst Header = require('./header.js');\n\nconst ReadEntry = require('./read-entry.js');\n\nconst fs = require('fs');\n\nconst path = require('path');\n\nconst types = require('./types.js');\n\nconst maxReadSize = 16 * 1024 * 1024;\nconst PROCESS = Symbol('process');\nconst FILE = Symbol('file');\nconst DIRECTORY = Symbol('directory');\nconst SYMLINK = Symbol('symlink');\nconst HARDLINK = Symbol('hardlink');\nconst HEADER = Symbol('header');\nconst READ = Symbol('read');\nconst LSTAT = Symbol('lstat');\nconst ONLSTAT = Symbol('onlstat');\nconst ONREAD = Symbol('onread');\nconst ONREADLINK = Symbol('onreadlink');\nconst OPENFILE = Symbol('openfile');\nconst ONOPENFILE = Symbol('onopenfile');\nconst CLOSE = Symbol('close');\nconst MODE = Symbol('mode');\n\nconst warner = require('./warn-mixin.js');\n\nconst winchars = require('./winchars.js');\n\nconst modeFix = require('./mode-fix.js');\n\nconst WriteEntry = warner(class WriteEntry extends MiniPass {\n  constructor(p, opt) {\n    opt = opt || {};\n    super(opt);\n    if (typeof p !== 'string') throw new TypeError('path is required');\n    this.path = p; // suppress atime, ctime, uid, gid, uname, gname\n\n    this.portable = !!opt.portable; // until node has builtin pwnam functions, this'll have to do\n\n    this.myuid = process.getuid && process.getuid();\n    this.myuser = process.env.USER || '';\n    this.maxReadSize = opt.maxReadSize || maxReadSize;\n    this.linkCache = opt.linkCache || new Map();\n    this.statCache = opt.statCache || new Map();\n    this.preservePaths = !!opt.preservePaths;\n    this.cwd = opt.cwd || process.cwd();\n    this.strict = !!opt.strict;\n    this.noPax = !!opt.noPax;\n    this.noMtime = !!opt.noMtime;\n    this.mtime = opt.mtime || null;\n    if (typeof opt.onwarn === 'function') this.on('warn', opt.onwarn);\n\n    if (!this.preservePaths && path.win32.isAbsolute(p)) {\n      // absolutes on posix are also absolutes on win32\n      // so we only need to test this one to get both\n      const parsed = path.win32.parse(p);\n      this.warn('stripping ' + parsed.root + ' from absolute path', p);\n      this.path = p.substr(parsed.root.length);\n    }\n\n    this.win32 = !!opt.win32 || process.platform === 'win32';\n\n    if (this.win32) {\n      this.path = winchars.decode(this.path.replace(/\\\\/g, '/'));\n      p = p.replace(/\\\\/g, '/');\n    }\n\n    this.absolute = opt.absolute || path.resolve(this.cwd, p);\n    if (this.path === '') this.path = './';\n    if (this.statCache.has(this.absolute)) this[ONLSTAT](this.statCache.get(this.absolute));else this[LSTAT]();\n  }\n\n  [LSTAT]() {\n    fs.lstat(this.absolute, (er, stat) => {\n      if (er) return this.emit('error', er);\n      this[ONLSTAT](stat);\n    });\n  }\n\n  [ONLSTAT](stat) {\n    this.statCache.set(this.absolute, stat);\n    this.stat = stat;\n    if (!stat.isFile()) stat.size = 0;\n    this.type = getType(stat);\n    this.emit('stat', stat);\n    this[PROCESS]();\n  }\n\n  [PROCESS]() {\n    switch (this.type) {\n      case 'File':\n        return this[FILE]();\n\n      case 'Directory':\n        return this[DIRECTORY]();\n\n      case 'SymbolicLink':\n        return this[SYMLINK]();\n      // unsupported types are ignored.\n\n      default:\n        return this.end();\n    }\n  }\n\n  [MODE](mode) {\n    return modeFix(mode, this.type === 'Directory');\n  }\n\n  [HEADER]() {\n    if (this.type === 'Directory' && this.portable) this.noMtime = true;\n    this.header = new Header({\n      path: this.path,\n      linkpath: this.linkpath,\n      // only the permissions and setuid/setgid/sticky bitflags\n      // not the higher-order bits that specify file type\n      mode: this[MODE](this.stat.mode),\n      uid: this.portable ? null : this.stat.uid,\n      gid: this.portable ? null : this.stat.gid,\n      size: this.stat.size,\n      mtime: this.noMtime ? null : this.mtime || this.stat.mtime,\n      type: this.type,\n      uname: this.portable ? null : this.stat.uid === this.myuid ? this.myuser : '',\n      atime: this.portable ? null : this.stat.atime,\n      ctime: this.portable ? null : this.stat.ctime\n    });\n    if (this.header.encode() && !this.noPax) this.write(new Pax({\n      atime: this.portable ? null : this.header.atime,\n      ctime: this.portable ? null : this.header.ctime,\n      gid: this.portable ? null : this.header.gid,\n      mtime: this.noMtime ? null : this.mtime || this.header.mtime,\n      path: this.path,\n      linkpath: this.linkpath,\n      size: this.header.size,\n      uid: this.portable ? null : this.header.uid,\n      uname: this.portable ? null : this.header.uname,\n      dev: this.portable ? null : this.stat.dev,\n      ino: this.portable ? null : this.stat.ino,\n      nlink: this.portable ? null : this.stat.nlink\n    }).encode());\n    this.write(this.header.block);\n  }\n\n  [DIRECTORY]() {\n    if (this.path.substr(-1) !== '/') this.path += '/';\n    this.stat.size = 0;\n    this[HEADER]();\n    this.end();\n  }\n\n  [SYMLINK]() {\n    fs.readlink(this.absolute, (er, linkpath) => {\n      if (er) return this.emit('error', er);\n      this[ONREADLINK](linkpath);\n    });\n  }\n\n  [ONREADLINK](linkpath) {\n    this.linkpath = linkpath;\n    this[HEADER]();\n    this.end();\n  }\n\n  [HARDLINK](linkpath) {\n    this.type = 'Link';\n    this.linkpath = path.relative(this.cwd, linkpath);\n    this.stat.size = 0;\n    this[HEADER]();\n    this.end();\n  }\n\n  [FILE]() {\n    if (this.stat.nlink > 1) {\n      const linkKey = this.stat.dev + ':' + this.stat.ino;\n\n      if (this.linkCache.has(linkKey)) {\n        const linkpath = this.linkCache.get(linkKey);\n        if (linkpath.indexOf(this.cwd) === 0) return this[HARDLINK](linkpath);\n      }\n\n      this.linkCache.set(linkKey, this.absolute);\n    }\n\n    this[HEADER]();\n    if (this.stat.size === 0) return this.end();\n    this[OPENFILE]();\n  }\n\n  [OPENFILE]() {\n    fs.open(this.absolute, 'r', (er, fd) => {\n      if (er) return this.emit('error', er);\n      this[ONOPENFILE](fd);\n    });\n  }\n\n  [ONOPENFILE](fd) {\n    const blockLen = 512 * Math.ceil(this.stat.size / 512);\n    const bufLen = Math.min(blockLen, this.maxReadSize);\n    const buf = Buffer.allocUnsafe(bufLen);\n    this[READ](fd, buf, 0, buf.length, 0, this.stat.size, blockLen);\n  }\n\n  [READ](fd, buf, offset, length, pos, remain, blockRemain) {\n    fs.read(fd, buf, offset, length, pos, (er, bytesRead) => {\n      if (er) return this[CLOSE](fd, _ => this.emit('error', er));\n      this[ONREAD](fd, buf, offset, length, pos, remain, blockRemain, bytesRead);\n    });\n  }\n\n  [CLOSE](fd, cb) {\n    fs.close(fd, cb);\n  }\n\n  [ONREAD](fd, buf, offset, length, pos, remain, blockRemain, bytesRead) {\n    if (bytesRead <= 0 && remain > 0) {\n      const er = new Error('encountered unexpected EOF');\n      er.path = this.absolute;\n      er.syscall = 'read';\n      er.code = 'EOF';\n      this[CLOSE](fd, _ => _);\n      return this.emit('error', er);\n    }\n\n    if (bytesRead > remain) {\n      const er = new Error('did not encounter expected EOF');\n      er.path = this.absolute;\n      er.syscall = 'read';\n      er.code = 'EOF';\n      this[CLOSE](fd, _ => _);\n      return this.emit('error', er);\n    } // null out the rest of the buffer, if we could fit the block padding\n\n\n    if (bytesRead === remain) {\n      for (let i = bytesRead; i < length && bytesRead < blockRemain; i++) {\n        buf[i + offset] = 0;\n        bytesRead++;\n        remain++;\n      }\n    }\n\n    const writeBuf = offset === 0 && bytesRead === buf.length ? buf : buf.slice(offset, offset + bytesRead);\n    remain -= bytesRead;\n    blockRemain -= bytesRead;\n    pos += bytesRead;\n    offset += bytesRead;\n    this.write(writeBuf);\n\n    if (!remain) {\n      if (blockRemain) this.write(Buffer.alloc(blockRemain));\n      this.end();\n      this[CLOSE](fd, _ => _);\n      return;\n    }\n\n    if (offset >= length) {\n      buf = Buffer.allocUnsafe(length);\n      offset = 0;\n    }\n\n    length = buf.length - offset;\n    this[READ](fd, buf, offset, length, pos, remain, blockRemain);\n  }\n\n});\n\nclass WriteEntrySync extends WriteEntry {\n  constructor(path, opt) {\n    super(path, opt);\n  }\n\n  [LSTAT]() {\n    this[ONLSTAT](fs.lstatSync(this.absolute));\n  }\n\n  [SYMLINK]() {\n    this[ONREADLINK](fs.readlinkSync(this.absolute));\n  }\n\n  [OPENFILE]() {\n    this[ONOPENFILE](fs.openSync(this.absolute, 'r'));\n  }\n\n  [READ](fd, buf, offset, length, pos, remain, blockRemain) {\n    let threw = true;\n\n    try {\n      const bytesRead = fs.readSync(fd, buf, offset, length, pos);\n      this[ONREAD](fd, buf, offset, length, pos, remain, blockRemain, bytesRead);\n      threw = false;\n    } finally {\n      if (threw) try {\n        this[CLOSE](fd);\n      } catch (er) {}\n    }\n  }\n\n  [CLOSE](fd) {\n    fs.closeSync(fd);\n  }\n\n}\n\nconst WriteEntryTar = warner(class WriteEntryTar extends MiniPass {\n  constructor(readEntry, opt) {\n    opt = opt || {};\n    super(opt);\n    this.preservePaths = !!opt.preservePaths;\n    this.portable = !!opt.portable;\n    this.strict = !!opt.strict;\n    this.noPax = !!opt.noPax;\n    this.noMtime = !!opt.noMtime;\n    this.readEntry = readEntry;\n    this.type = readEntry.type;\n    if (this.type === 'Directory' && this.portable) this.noMtime = true;\n    this.path = readEntry.path;\n    this.mode = this[MODE](readEntry.mode);\n    this.uid = this.portable ? null : readEntry.uid;\n    this.gid = this.portable ? null : readEntry.gid;\n    this.uname = this.portable ? null : readEntry.uname;\n    this.gname = this.portable ? null : readEntry.gname;\n    this.size = readEntry.size;\n    this.mtime = this.noMtime ? null : opt.mtime || readEntry.mtime;\n    this.atime = this.portable ? null : readEntry.atime;\n    this.ctime = this.portable ? null : readEntry.ctime;\n    this.linkpath = readEntry.linkpath;\n    if (typeof opt.onwarn === 'function') this.on('warn', opt.onwarn);\n\n    if (path.isAbsolute(this.path) && !this.preservePaths) {\n      const parsed = path.parse(this.path);\n      this.warn('stripping ' + parsed.root + ' from absolute path', this.path);\n      this.path = this.path.substr(parsed.root.length);\n    }\n\n    this.remain = readEntry.size;\n    this.blockRemain = readEntry.startBlockSize;\n    this.header = new Header({\n      path: this.path,\n      linkpath: this.linkpath,\n      // only the permissions and setuid/setgid/sticky bitflags\n      // not the higher-order bits that specify file type\n      mode: this.mode,\n      uid: this.portable ? null : this.uid,\n      gid: this.portable ? null : this.gid,\n      size: this.size,\n      mtime: this.noMtime ? null : this.mtime,\n      type: this.type,\n      uname: this.portable ? null : this.uname,\n      atime: this.portable ? null : this.atime,\n      ctime: this.portable ? null : this.ctime\n    });\n    if (this.header.encode() && !this.noPax) super.write(new Pax({\n      atime: this.portable ? null : this.atime,\n      ctime: this.portable ? null : this.ctime,\n      gid: this.portable ? null : this.gid,\n      mtime: this.noMtime ? null : this.mtime,\n      path: this.path,\n      linkpath: this.linkpath,\n      size: this.size,\n      uid: this.portable ? null : this.uid,\n      uname: this.portable ? null : this.uname,\n      dev: this.portable ? null : this.readEntry.dev,\n      ino: this.portable ? null : this.readEntry.ino,\n      nlink: this.portable ? null : this.readEntry.nlink\n    }).encode());\n    super.write(this.header.block);\n    readEntry.pipe(this);\n  }\n\n  [MODE](mode) {\n    return modeFix(mode, this.type === 'Directory');\n  }\n\n  write(data) {\n    const writeLen = data.length;\n    if (writeLen > this.blockRemain) throw new Error('writing more to entry than is appropriate');\n    this.blockRemain -= writeLen;\n    return super.write(data);\n  }\n\n  end() {\n    if (this.blockRemain) this.write(Buffer.alloc(this.blockRemain));\n    return super.end();\n  }\n\n});\nWriteEntry.Sync = WriteEntrySync;\nWriteEntry.Tar = WriteEntryTar;\n\nconst getType = stat => stat.isFile() ? 'File' : stat.isDirectory() ? 'Directory' : stat.isSymbolicLink() ? 'SymbolicLink' : 'Unsupported';\n\nmodule.exports = WriteEntry;","map":{"version":3,"sources":["/home/n/React/loginpagedemo/frontend/node_modules/tar/lib/write-entry.js"],"names":["Buffer","require","MiniPass","Pax","Header","ReadEntry","fs","path","types","maxReadSize","PROCESS","Symbol","FILE","DIRECTORY","SYMLINK","HARDLINK","HEADER","READ","LSTAT","ONLSTAT","ONREAD","ONREADLINK","OPENFILE","ONOPENFILE","CLOSE","MODE","warner","winchars","modeFix","WriteEntry","constructor","p","opt","TypeError","portable","myuid","process","getuid","myuser","env","USER","linkCache","Map","statCache","preservePaths","cwd","strict","noPax","noMtime","mtime","onwarn","on","win32","isAbsolute","parsed","parse","warn","root","substr","length","platform","decode","replace","absolute","resolve","has","get","lstat","er","stat","emit","set","isFile","size","type","getType","end","mode","header","linkpath","uid","gid","uname","atime","ctime","encode","write","dev","ino","nlink","block","readlink","relative","linkKey","indexOf","open","fd","blockLen","Math","ceil","bufLen","min","buf","allocUnsafe","offset","pos","remain","blockRemain","read","bytesRead","_","cb","close","Error","syscall","code","i","writeBuf","slice","alloc","WriteEntrySync","lstatSync","readlinkSync","openSync","threw","readSync","closeSync","WriteEntryTar","readEntry","gname","startBlockSize","pipe","data","writeLen","Sync","Tar","isDirectory","isSymbolicLink","module","exports"],"mappings":"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","sourcesContent":["'use strict'\nconst Buffer = require('./buffer.js')\nconst MiniPass = require('minipass')\nconst Pax = require('./pax.js')\nconst Header = require('./header.js')\nconst ReadEntry = require('./read-entry.js')\nconst fs = require('fs')\nconst path = require('path')\n\nconst types = require('./types.js')\nconst maxReadSize = 16 * 1024 * 1024\nconst PROCESS = Symbol('process')\nconst FILE = Symbol('file')\nconst DIRECTORY = Symbol('directory')\nconst SYMLINK = Symbol('symlink')\nconst HARDLINK = Symbol('hardlink')\nconst HEADER = Symbol('header')\nconst READ = Symbol('read')\nconst LSTAT = Symbol('lstat')\nconst ONLSTAT = Symbol('onlstat')\nconst ONREAD = Symbol('onread')\nconst ONREADLINK = Symbol('onreadlink')\nconst OPENFILE = Symbol('openfile')\nconst ONOPENFILE = Symbol('onopenfile')\nconst CLOSE = Symbol('close')\nconst MODE = Symbol('mode')\nconst warner = require('./warn-mixin.js')\nconst winchars = require('./winchars.js')\n\nconst modeFix = require('./mode-fix.js')\n\nconst WriteEntry = warner(class WriteEntry extends MiniPass {\n  constructor (p, opt) {\n    opt = opt || {}\n    super(opt)\n    if (typeof p !== 'string')\n      throw new TypeError('path is required')\n    this.path = p\n    // suppress atime, ctime, uid, gid, uname, gname\n    this.portable = !!opt.portable\n    // until node has builtin pwnam functions, this'll have to do\n    this.myuid = process.getuid && process.getuid()\n    this.myuser = process.env.USER || ''\n    this.maxReadSize = opt.maxReadSize || maxReadSize\n    this.linkCache = opt.linkCache || new Map()\n    this.statCache = opt.statCache || new Map()\n    this.preservePaths = !!opt.preservePaths\n    this.cwd = opt.cwd || process.cwd()\n    this.strict = !!opt.strict\n    this.noPax = !!opt.noPax\n    this.noMtime = !!opt.noMtime\n    this.mtime = opt.mtime || null\n\n    if (typeof opt.onwarn === 'function')\n      this.on('warn', opt.onwarn)\n\n    if (!this.preservePaths && path.win32.isAbsolute(p)) {\n      // absolutes on posix are also absolutes on win32\n      // so we only need to test this one to get both\n      const parsed = path.win32.parse(p)\n      this.warn('stripping ' + parsed.root + ' from absolute path', p)\n      this.path = p.substr(parsed.root.length)\n    }\n\n    this.win32 = !!opt.win32 || process.platform === 'win32'\n    if (this.win32) {\n      this.path = winchars.decode(this.path.replace(/\\\\/g, '/'))\n      p = p.replace(/\\\\/g, '/')\n    }\n\n    this.absolute = opt.absolute || path.resolve(this.cwd, p)\n\n    if (this.path === '')\n      this.path = './'\n\n    if (this.statCache.has(this.absolute))\n      this[ONLSTAT](this.statCache.get(this.absolute))\n    else\n      this[LSTAT]()\n  }\n\n  [LSTAT] () {\n    fs.lstat(this.absolute, (er, stat) => {\n      if (er)\n        return this.emit('error', er)\n      this[ONLSTAT](stat)\n    })\n  }\n\n  [ONLSTAT] (stat) {\n    this.statCache.set(this.absolute, stat)\n    this.stat = stat\n    if (!stat.isFile())\n      stat.size = 0\n    this.type = getType(stat)\n    this.emit('stat', stat)\n    this[PROCESS]()\n  }\n\n  [PROCESS] () {\n    switch (this.type) {\n      case 'File': return this[FILE]()\n      case 'Directory': return this[DIRECTORY]()\n      case 'SymbolicLink': return this[SYMLINK]()\n      // unsupported types are ignored.\n      default: return this.end()\n    }\n  }\n\n  [MODE] (mode) {\n    return modeFix(mode, this.type === 'Directory')\n  }\n\n  [HEADER] () {\n    if (this.type === 'Directory' && this.portable)\n      this.noMtime = true\n\n    this.header = new Header({\n      path: this.path,\n      linkpath: this.linkpath,\n      // only the permissions and setuid/setgid/sticky bitflags\n      // not the higher-order bits that specify file type\n      mode: this[MODE](this.stat.mode),\n      uid: this.portable ? null : this.stat.uid,\n      gid: this.portable ? null : this.stat.gid,\n      size: this.stat.size,\n      mtime: this.noMtime ? null : this.mtime || this.stat.mtime,\n      type: this.type,\n      uname: this.portable ? null :\n        this.stat.uid === this.myuid ? this.myuser : '',\n      atime: this.portable ? null : this.stat.atime,\n      ctime: this.portable ? null : this.stat.ctime\n    })\n\n    if (this.header.encode() && !this.noPax)\n      this.write(new Pax({\n        atime: this.portable ? null : this.header.atime,\n        ctime: this.portable ? null : this.header.ctime,\n        gid: this.portable ? null : this.header.gid,\n        mtime: this.noMtime ? null : this.mtime || this.header.mtime,\n        path: this.path,\n        linkpath: this.linkpath,\n        size: this.header.size,\n        uid: this.portable ? null : this.header.uid,\n        uname: this.portable ? null : this.header.uname,\n        dev: this.portable ? null : this.stat.dev,\n        ino: this.portable ? null : this.stat.ino,\n        nlink: this.portable ? null : this.stat.nlink\n      }).encode())\n    this.write(this.header.block)\n  }\n\n  [DIRECTORY] () {\n    if (this.path.substr(-1) !== '/')\n      this.path += '/'\n    this.stat.size = 0\n    this[HEADER]()\n    this.end()\n  }\n\n  [SYMLINK] () {\n    fs.readlink(this.absolute, (er, linkpath) => {\n      if (er)\n        return this.emit('error', er)\n      this[ONREADLINK](linkpath)\n    })\n  }\n\n  [ONREADLINK] (linkpath) {\n    this.linkpath = linkpath\n    this[HEADER]()\n    this.end()\n  }\n\n  [HARDLINK] (linkpath) {\n    this.type = 'Link'\n    this.linkpath = path.relative(this.cwd, linkpath)\n    this.stat.size = 0\n    this[HEADER]()\n    this.end()\n  }\n\n  [FILE] () {\n    if (this.stat.nlink > 1) {\n      const linkKey = this.stat.dev + ':' + this.stat.ino\n      if (this.linkCache.has(linkKey)) {\n        const linkpath = this.linkCache.get(linkKey)\n        if (linkpath.indexOf(this.cwd) === 0)\n          return this[HARDLINK](linkpath)\n      }\n      this.linkCache.set(linkKey, this.absolute)\n    }\n\n    this[HEADER]()\n    if (this.stat.size === 0)\n      return this.end()\n\n    this[OPENFILE]()\n  }\n\n  [OPENFILE] () {\n    fs.open(this.absolute, 'r', (er, fd) => {\n      if (er)\n        return this.emit('error', er)\n      this[ONOPENFILE](fd)\n    })\n  }\n\n  [ONOPENFILE] (fd) {\n    const blockLen = 512 * Math.ceil(this.stat.size / 512)\n    const bufLen = Math.min(blockLen, this.maxReadSize)\n    const buf = Buffer.allocUnsafe(bufLen)\n    this[READ](fd, buf, 0, buf.length, 0, this.stat.size, blockLen)\n  }\n\n  [READ] (fd, buf, offset, length, pos, remain, blockRemain) {\n    fs.read(fd, buf, offset, length, pos, (er, bytesRead) => {\n      if (er)\n        return this[CLOSE](fd, _ => this.emit('error', er))\n      this[ONREAD](fd, buf, offset, length, pos, remain, blockRemain, bytesRead)\n    })\n  }\n\n  [CLOSE] (fd, cb) {\n    fs.close(fd, cb)\n  }\n\n  [ONREAD] (fd, buf, offset, length, pos, remain, blockRemain, bytesRead) {\n    if (bytesRead <= 0 && remain > 0) {\n      const er = new Error('encountered unexpected EOF')\n      er.path = this.absolute\n      er.syscall = 'read'\n      er.code = 'EOF'\n      this[CLOSE](fd, _ => _)\n      return this.emit('error', er)\n    }\n\n    if (bytesRead > remain) {\n      const er = new Error('did not encounter expected EOF')\n      er.path = this.absolute\n      er.syscall = 'read'\n      er.code = 'EOF'\n      this[CLOSE](fd, _ => _)\n      return this.emit('error', er)\n    }\n\n    // null out the rest of the buffer, if we could fit the block padding\n    if (bytesRead === remain) {\n      for (let i = bytesRead; i < length && bytesRead < blockRemain; i++) {\n        buf[i + offset] = 0\n        bytesRead ++\n        remain ++\n      }\n    }\n\n    const writeBuf = offset === 0 && bytesRead === buf.length ?\n      buf : buf.slice(offset, offset + bytesRead)\n    remain -= bytesRead\n    blockRemain -= bytesRead\n    pos += bytesRead\n    offset += bytesRead\n\n    this.write(writeBuf)\n\n    if (!remain) {\n      if (blockRemain)\n        this.write(Buffer.alloc(blockRemain))\n      this.end()\n      this[CLOSE](fd, _ => _)\n      return\n    }\n\n    if (offset >= length) {\n      buf = Buffer.allocUnsafe(length)\n      offset = 0\n    }\n    length = buf.length - offset\n    this[READ](fd, buf, offset, length, pos, remain, blockRemain)\n  }\n})\n\nclass WriteEntrySync extends WriteEntry {\n  constructor (path, opt) {\n    super(path, opt)\n  }\n\n  [LSTAT] () {\n    this[ONLSTAT](fs.lstatSync(this.absolute))\n  }\n\n  [SYMLINK] () {\n    this[ONREADLINK](fs.readlinkSync(this.absolute))\n  }\n\n  [OPENFILE] () {\n    this[ONOPENFILE](fs.openSync(this.absolute, 'r'))\n  }\n\n  [READ] (fd, buf, offset, length, pos, remain, blockRemain) {\n    let threw = true\n    try {\n      const bytesRead = fs.readSync(fd, buf, offset, length, pos)\n      this[ONREAD](fd, buf, offset, length, pos, remain, blockRemain, bytesRead)\n      threw = false\n    } finally {\n      if (threw)\n        try { this[CLOSE](fd) } catch (er) {}\n    }\n  }\n\n  [CLOSE] (fd) {\n    fs.closeSync(fd)\n  }\n}\n\nconst WriteEntryTar = warner(class WriteEntryTar extends MiniPass {\n  constructor (readEntry, opt) {\n    opt = opt || {}\n    super(opt)\n    this.preservePaths = !!opt.preservePaths\n    this.portable = !!opt.portable\n    this.strict = !!opt.strict\n    this.noPax = !!opt.noPax\n    this.noMtime = !!opt.noMtime\n\n    this.readEntry = readEntry\n    this.type = readEntry.type\n    if (this.type === 'Directory' && this.portable)\n      this.noMtime = true\n\n    this.path = readEntry.path\n    this.mode = this[MODE](readEntry.mode)\n    this.uid = this.portable ? null : readEntry.uid\n    this.gid = this.portable ? null : readEntry.gid\n    this.uname = this.portable ? null : readEntry.uname\n    this.gname = this.portable ? null : readEntry.gname\n    this.size = readEntry.size\n    this.mtime = this.noMtime ? null : opt.mtime || readEntry.mtime\n    this.atime = this.portable ? null : readEntry.atime\n    this.ctime = this.portable ? null : readEntry.ctime\n    this.linkpath = readEntry.linkpath\n\n    if (typeof opt.onwarn === 'function')\n      this.on('warn', opt.onwarn)\n\n    if (path.isAbsolute(this.path) && !this.preservePaths) {\n      const parsed = path.parse(this.path)\n      this.warn(\n        'stripping ' + parsed.root + ' from absolute path',\n        this.path\n      )\n      this.path = this.path.substr(parsed.root.length)\n    }\n\n    this.remain = readEntry.size\n    this.blockRemain = readEntry.startBlockSize\n\n    this.header = new Header({\n      path: this.path,\n      linkpath: this.linkpath,\n      // only the permissions and setuid/setgid/sticky bitflags\n      // not the higher-order bits that specify file type\n      mode: this.mode,\n      uid: this.portable ? null : this.uid,\n      gid: this.portable ? null : this.gid,\n      size: this.size,\n      mtime: this.noMtime ? null : this.mtime,\n      type: this.type,\n      uname: this.portable ? null : this.uname,\n      atime: this.portable ? null : this.atime,\n      ctime: this.portable ? null : this.ctime\n    })\n\n    if (this.header.encode() && !this.noPax)\n      super.write(new Pax({\n        atime: this.portable ? null : this.atime,\n        ctime: this.portable ? null : this.ctime,\n        gid: this.portable ? null : this.gid,\n        mtime: this.noMtime ? null : this.mtime,\n        path: this.path,\n        linkpath: this.linkpath,\n        size: this.size,\n        uid: this.portable ? null : this.uid,\n        uname: this.portable ? null : this.uname,\n        dev: this.portable ? null : this.readEntry.dev,\n        ino: this.portable ? null : this.readEntry.ino,\n        nlink: this.portable ? null : this.readEntry.nlink\n      }).encode())\n\n    super.write(this.header.block)\n    readEntry.pipe(this)\n  }\n\n  [MODE] (mode) {\n    return modeFix(mode, this.type === 'Directory')\n  }\n\n  write (data) {\n    const writeLen = data.length\n    if (writeLen > this.blockRemain)\n      throw new Error('writing more to entry than is appropriate')\n    this.blockRemain -= writeLen\n    return super.write(data)\n  }\n\n  end () {\n    if (this.blockRemain)\n      this.write(Buffer.alloc(this.blockRemain))\n    return super.end()\n  }\n})\n\nWriteEntry.Sync = WriteEntrySync\nWriteEntry.Tar = WriteEntryTar\n\nconst getType = stat =>\n  stat.isFile() ? 'File'\n  : stat.isDirectory() ? 'Directory'\n  : stat.isSymbolicLink() ? 'SymbolicLink'\n  : 'Unsupported'\n\nmodule.exports = WriteEntry\n"]},"metadata":{},"sourceType":"script"}