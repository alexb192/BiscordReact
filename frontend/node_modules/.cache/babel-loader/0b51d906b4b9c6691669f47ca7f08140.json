{"ast":null,"code":"'use strict'; // walk the tree of deps starting from the top level list of bundled deps\n// Any deps at the top level that are depended on by a bundled dep that\n// does not have that dep in its own node_modules folder are considered\n// bundled deps as well.  This list of names can be passed to npm-packlist\n// as the \"bundled\" argument.  Additionally, packageJsonCache is shared so\n// packlist doesn't have to re-read files already consumed in this pass\n\nconst fs = require('fs');\n\nconst path = require('path');\n\nconst EE = require('events').EventEmitter; // we don't care about the package bins, but we share a pj cache\n// with other modules that DO care about it, so keep it nice.\n\n\nconst normalizePackageBin = require('npm-normalize-package-bin');\n\nclass BundleWalker extends EE {\n  constructor(opt) {\n    opt = opt || {};\n    super(opt);\n    this.path = path.resolve(opt.path || process.cwd());\n    this.parent = opt.parent || null;\n\n    if (this.parent) {\n      this.result = this.parent.result; // only collect results in node_modules folders at the top level\n      // since the node_modules in a bundled dep is included always\n\n      if (!this.parent.parent) {\n        const base = path.basename(this.path);\n        const scope = path.basename(path.dirname(this.path));\n        this.result.add(/^@/.test(scope) ? scope + '/' + base : base);\n      }\n\n      this.root = this.parent.root;\n      this.packageJsonCache = this.parent.packageJsonCache;\n    } else {\n      this.result = new Set();\n      this.root = this.path;\n      this.packageJsonCache = opt.packageJsonCache || new Map();\n    }\n\n    this.seen = new Set();\n    this.didDone = false;\n    this.children = 0;\n    this.node_modules = [];\n    this.package = null;\n    this.bundle = null;\n  }\n\n  addListener(ev, fn) {\n    return this.on(ev, fn);\n  }\n\n  on(ev, fn) {\n    const ret = super.on(ev, fn);\n\n    if (ev === 'done' && this.didDone) {\n      this.emit('done', this.result);\n    }\n\n    return ret;\n  }\n\n  done() {\n    if (!this.didDone) {\n      this.didDone = true;\n\n      if (!this.parent) {\n        const res = Array.from(this.result);\n        this.result = res;\n        this.emit('done', res);\n      } else {\n        this.emit('done');\n      }\n    }\n  }\n\n  start() {\n    const pj = path.resolve(this.path, 'package.json');\n    if (this.packageJsonCache.has(pj)) this.onPackage(this.packageJsonCache.get(pj));else this.readPackageJson(pj);\n    return this;\n  }\n\n  readPackageJson(pj) {\n    fs.readFile(pj, (er, data) => er ? this.done() : this.onPackageJson(pj, data));\n  }\n\n  onPackageJson(pj, data) {\n    try {\n      this.package = normalizePackageBin(JSON.parse(data + ''));\n    } catch (er) {\n      return this.done();\n    }\n\n    this.packageJsonCache.set(pj, this.package);\n    this.onPackage(this.package);\n  }\n\n  allDepsBundled(pkg) {\n    return Object.keys(pkg.dependencies || {}).concat(Object.keys(pkg.optionalDependencies || {}));\n  }\n\n  onPackage(pkg) {\n    // all deps are bundled if we got here as a child.\n    // otherwise, only bundle bundledDeps\n    // Get a unique-ified array with a short-lived Set\n    const bdRaw = this.parent ? this.allDepsBundled(pkg) : pkg.bundleDependencies || pkg.bundledDependencies || [];\n    const bd = Array.from(new Set(Array.isArray(bdRaw) ? bdRaw : bdRaw === true ? this.allDepsBundled(pkg) : Object.keys(bdRaw)));\n    if (!bd.length) return this.done();\n    this.bundle = bd;\n    const nm = this.path + '/node_modules';\n    this.readModules();\n  }\n\n  readModules() {\n    readdirNodeModules(this.path + '/node_modules', (er, nm) => er ? this.onReaddir([]) : this.onReaddir(nm));\n  }\n\n  onReaddir(nm) {\n    // keep track of what we have, in case children need it\n    this.node_modules = nm;\n    this.bundle.forEach(dep => this.childDep(dep));\n    if (this.children === 0) this.done();\n  }\n\n  childDep(dep) {\n    if (this.node_modules.indexOf(dep) !== -1 && !this.seen.has(dep)) {\n      this.seen.add(dep);\n      this.child(dep);\n    } else if (this.parent) {\n      this.parent.childDep(dep);\n    }\n  }\n\n  child(dep) {\n    const p = this.path + '/node_modules/' + dep;\n    this.children += 1;\n    const child = new BundleWalker({\n      path: p,\n      parent: this\n    });\n    child.on('done', _ => {\n      if (--this.children === 0) this.done();\n    });\n    child.start();\n  }\n\n}\n\nclass BundleWalkerSync extends BundleWalker {\n  constructor(opt) {\n    super(opt);\n  }\n\n  start() {\n    super.start();\n    this.done();\n    return this;\n  }\n\n  readPackageJson(pj) {\n    try {\n      this.onPackageJson(pj, fs.readFileSync(pj));\n    } catch (er) {}\n\n    return this;\n  }\n\n  readModules() {\n    try {\n      this.onReaddir(readdirNodeModulesSync(this.path + '/node_modules'));\n    } catch (er) {\n      this.onReaddir([]);\n    }\n  }\n\n  child(dep) {\n    new BundleWalkerSync({\n      path: this.path + '/node_modules/' + dep,\n      parent: this\n    }).start();\n  }\n\n}\n\nconst readdirNodeModules = (nm, cb) => {\n  fs.readdir(nm, (er, set) => {\n    if (er) cb(er);else {\n      const scopes = set.filter(f => /^@/.test(f));\n      if (!scopes.length) cb(null, set);else {\n        const unscoped = set.filter(f => !/^@/.test(f));\n        let count = scopes.length;\n        scopes.forEach(scope => {\n          fs.readdir(nm + '/' + scope, (er, pkgs) => {\n            if (er || !pkgs.length) unscoped.push(scope);else unscoped.push.apply(unscoped, pkgs.map(p => scope + '/' + p));\n            if (--count === 0) cb(null, unscoped);\n          });\n        });\n      }\n    }\n  });\n};\n\nconst readdirNodeModulesSync = nm => {\n  const set = fs.readdirSync(nm);\n  const unscoped = set.filter(f => !/^@/.test(f));\n  const scopes = set.filter(f => /^@/.test(f)).map(scope => {\n    try {\n      const pkgs = fs.readdirSync(nm + '/' + scope);\n      return pkgs.length ? pkgs.map(p => scope + '/' + p) : [scope];\n    } catch (er) {\n      return [scope];\n    }\n  }).reduce((a, b) => a.concat(b), []);\n  return unscoped.concat(scopes);\n};\n\nconst walk = (options, callback) => {\n  const p = new Promise((resolve, reject) => {\n    new BundleWalker(options).on('done', resolve).on('error', reject).start();\n  });\n  return callback ? p.then(res => callback(null, res), callback) : p;\n};\n\nconst walkSync = options => {\n  return new BundleWalkerSync(options).start().result;\n};\n\nmodule.exports = walk;\nwalk.sync = walkSync;\nwalk.BundleWalker = BundleWalker;\nwalk.BundleWalkerSync = BundleWalkerSync;","map":{"version":3,"sources":["/home/n/React/loginpagedemo/frontend/node_modules/npm-bundled/index.js"],"names":["fs","require","path","EE","EventEmitter","normalizePackageBin","BundleWalker","constructor","opt","resolve","process","cwd","parent","result","base","basename","scope","dirname","add","test","root","packageJsonCache","Set","Map","seen","didDone","children","node_modules","package","bundle","addListener","ev","fn","on","ret","emit","done","res","Array","from","start","pj","has","onPackage","get","readPackageJson","readFile","er","data","onPackageJson","JSON","parse","set","allDepsBundled","pkg","Object","keys","dependencies","concat","optionalDependencies","bdRaw","bundleDependencies","bundledDependencies","bd","isArray","length","nm","readModules","readdirNodeModules","onReaddir","forEach","dep","childDep","indexOf","child","p","_","BundleWalkerSync","readFileSync","readdirNodeModulesSync","cb","readdir","scopes","filter","f","unscoped","count","pkgs","push","apply","map","readdirSync","reduce","a","b","walk","options","callback","Promise","reject","then","walkSync","module","exports","sync"],"mappings":"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","sourcesContent":["'use strict'\n\n// walk the tree of deps starting from the top level list of bundled deps\n// Any deps at the top level that are depended on by a bundled dep that\n// does not have that dep in its own node_modules folder are considered\n// bundled deps as well.  This list of names can be passed to npm-packlist\n// as the \"bundled\" argument.  Additionally, packageJsonCache is shared so\n// packlist doesn't have to re-read files already consumed in this pass\n\nconst fs = require('fs')\nconst path = require('path')\nconst EE = require('events').EventEmitter\n// we don't care about the package bins, but we share a pj cache\n// with other modules that DO care about it, so keep it nice.\nconst normalizePackageBin = require('npm-normalize-package-bin')\n\nclass BundleWalker extends EE {\n  constructor (opt) {\n    opt = opt || {}\n    super(opt)\n    this.path = path.resolve(opt.path || process.cwd())\n\n    this.parent = opt.parent || null\n    if (this.parent) {\n      this.result = this.parent.result\n      // only collect results in node_modules folders at the top level\n      // since the node_modules in a bundled dep is included always\n      if (!this.parent.parent) {\n        const base = path.basename(this.path)\n        const scope = path.basename(path.dirname(this.path))\n        this.result.add(/^@/.test(scope) ? scope + '/' + base : base)\n      }\n      this.root = this.parent.root\n      this.packageJsonCache = this.parent.packageJsonCache\n    } else {\n      this.result = new Set()\n      this.root = this.path\n      this.packageJsonCache = opt.packageJsonCache || new Map()\n    }\n\n    this.seen = new Set()\n    this.didDone = false\n    this.children = 0\n    this.node_modules = []\n    this.package = null\n    this.bundle = null\n  }\n\n  addListener (ev, fn) {\n    return this.on(ev, fn)\n  }\n\n  on (ev, fn) {\n    const ret = super.on(ev, fn)\n    if (ev === 'done' && this.didDone) {\n      this.emit('done', this.result)\n    }\n    return ret\n  }\n\n  done () {\n    if (!this.didDone) {\n      this.didDone = true\n      if (!this.parent) {\n        const res = Array.from(this.result)\n        this.result = res\n        this.emit('done', res)\n      } else {\n        this.emit('done')\n      }\n    }\n  }\n\n  start () {\n    const pj = path.resolve(this.path, 'package.json')\n    if (this.packageJsonCache.has(pj))\n      this.onPackage(this.packageJsonCache.get(pj))\n    else\n      this.readPackageJson(pj)\n    return this\n  }\n\n  readPackageJson (pj) {\n    fs.readFile(pj, (er, data) =>\n      er ? this.done() : this.onPackageJson(pj, data))\n  }\n\n  onPackageJson (pj, data) {\n    try {\n      this.package = normalizePackageBin(JSON.parse(data + ''))\n    } catch (er) {\n      return this.done()\n    }\n    this.packageJsonCache.set(pj, this.package)\n    this.onPackage(this.package)\n  }\n\n  allDepsBundled (pkg) {\n    return Object.keys(pkg.dependencies || {}).concat(\n      Object.keys(pkg.optionalDependencies || {}))\n  }\n\n  onPackage (pkg) {\n    // all deps are bundled if we got here as a child.\n    // otherwise, only bundle bundledDeps\n    // Get a unique-ified array with a short-lived Set\n    const bdRaw = this.parent ? this.allDepsBundled(pkg)\n      : pkg.bundleDependencies || pkg.bundledDependencies || []\n\n    const bd = Array.from(new Set(\n      Array.isArray(bdRaw) ? bdRaw\n      : bdRaw === true ? this.allDepsBundled(pkg)\n      : Object.keys(bdRaw)))\n\n    if (!bd.length)\n      return this.done()\n\n    this.bundle = bd\n    const nm = this.path + '/node_modules'\n    this.readModules()\n  }\n\n  readModules () {\n    readdirNodeModules(this.path + '/node_modules', (er, nm) =>\n      er ? this.onReaddir([]) : this.onReaddir(nm))\n  }\n\n  onReaddir (nm) {\n    // keep track of what we have, in case children need it\n    this.node_modules = nm\n\n    this.bundle.forEach(dep => this.childDep(dep))\n    if (this.children === 0)\n      this.done()\n  }\n\n  childDep (dep) {\n    if (this.node_modules.indexOf(dep) !== -1 && !this.seen.has(dep)) {\n      this.seen.add(dep)\n      this.child(dep)\n    } else if (this.parent) {\n      this.parent.childDep(dep)\n    }\n  }\n\n  child (dep) {\n    const p = this.path + '/node_modules/' + dep\n    this.children += 1\n    const child = new BundleWalker({\n      path: p,\n      parent: this\n    })\n    child.on('done', _ => {\n      if (--this.children === 0)\n        this.done()\n    })\n    child.start()\n  }\n}\n\nclass BundleWalkerSync extends BundleWalker {\n  constructor (opt) {\n    super(opt)\n  }\n\n  start () {\n    super.start()\n    this.done()\n    return this\n  }\n\n  readPackageJson (pj) {\n    try {\n      this.onPackageJson(pj, fs.readFileSync(pj))\n    } catch (er) {}\n    return this\n  }\n\n  readModules () {\n    try {\n      this.onReaddir(readdirNodeModulesSync(this.path + '/node_modules'))\n    } catch (er) {\n      this.onReaddir([])\n    }\n  }\n\n  child (dep) {\n    new BundleWalkerSync({\n      path: this.path + '/node_modules/' + dep,\n      parent: this\n    }).start()\n  }\n}\n\nconst readdirNodeModules = (nm, cb) => {\n  fs.readdir(nm, (er, set) => {\n    if (er)\n      cb(er)\n    else {\n      const scopes = set.filter(f => /^@/.test(f))\n      if (!scopes.length)\n        cb(null, set)\n      else {\n        const unscoped = set.filter(f => !/^@/.test(f))\n        let count = scopes.length\n        scopes.forEach(scope => {\n          fs.readdir(nm + '/' + scope, (er, pkgs) => {\n            if (er || !pkgs.length)\n              unscoped.push(scope)\n            else\n              unscoped.push.apply(unscoped, pkgs.map(p => scope + '/' + p))\n            if (--count === 0)\n              cb(null, unscoped)\n          })\n        })\n      }\n    }\n  })\n}\n\nconst readdirNodeModulesSync = nm => {\n  const set = fs.readdirSync(nm)\n  const unscoped = set.filter(f => !/^@/.test(f))\n  const scopes = set.filter(f => /^@/.test(f)).map(scope => {\n    try {\n      const pkgs = fs.readdirSync(nm + '/' + scope)\n      return pkgs.length ? pkgs.map(p => scope + '/' + p) : [scope]\n    } catch (er) {\n      return [scope]\n    }\n  }).reduce((a, b) => a.concat(b), [])\n  return unscoped.concat(scopes)\n}\n\nconst walk = (options, callback) => {\n  const p = new Promise((resolve, reject) => {\n    new BundleWalker(options).on('done', resolve).on('error', reject).start()\n  })\n  return callback ? p.then(res => callback(null, res), callback) : p\n}\n\nconst walkSync = options => {\n  return new BundleWalkerSync(options).start().result\n}\n\nmodule.exports = walk\nwalk.sync = walkSync\nwalk.BundleWalker = BundleWalker\nwalk.BundleWalkerSync = BundleWalkerSync\n"]},"metadata":{},"sourceType":"script"}