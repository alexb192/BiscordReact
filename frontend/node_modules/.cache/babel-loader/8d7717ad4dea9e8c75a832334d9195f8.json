{"ast":null,"code":"'use strict';\n\nconst assert = require('assert');\n\nconst EE = require('events').EventEmitter;\n\nconst Parser = require('./parse.js');\n\nconst fs = require('fs');\n\nconst fsm = require('fs-minipass');\n\nconst path = require('path');\n\nconst mkdir = require('./mkdir.js');\n\nconst mkdirSync = mkdir.sync;\n\nconst wc = require('./winchars.js');\n\nconst ONENTRY = Symbol('onEntry');\nconst CHECKFS = Symbol('checkFs');\nconst ISREUSABLE = Symbol('isReusable');\nconst MAKEFS = Symbol('makeFs');\nconst FILE = Symbol('file');\nconst DIRECTORY = Symbol('directory');\nconst LINK = Symbol('link');\nconst SYMLINK = Symbol('symlink');\nconst HARDLINK = Symbol('hardlink');\nconst UNSUPPORTED = Symbol('unsupported');\nconst UNKNOWN = Symbol('unknown');\nconst CHECKPATH = Symbol('checkPath');\nconst MKDIR = Symbol('mkdir');\nconst ONERROR = Symbol('onError');\nconst PENDING = Symbol('pending');\nconst PEND = Symbol('pend');\nconst UNPEND = Symbol('unpend');\nconst ENDED = Symbol('ended');\nconst MAYBECLOSE = Symbol('maybeClose');\nconst SKIP = Symbol('skip');\nconst DOCHOWN = Symbol('doChown');\nconst UID = Symbol('uid');\nconst GID = Symbol('gid');\n\nconst crypto = require('crypto'); // Unlinks on Windows are not atomic.\n//\n// This means that if you have a file entry, followed by another\n// file entry with an identical name, and you cannot re-use the file\n// (because it's a hardlink, or because unlink:true is set, or it's\n// Windows, which does not have useful nlink values), then the unlink\n// will be committed to the disk AFTER the new file has been written\n// over the old one, deleting the new file.\n//\n// To work around this, on Windows systems, we rename the file and then\n// delete the renamed file.  It's a sloppy kludge, but frankly, I do not\n// know of a better way to do this, given windows' non-atomic unlink\n// semantics.\n//\n// See: https://github.com/npm/node-tar/issues/183\n\n/* istanbul ignore next */\n\n\nconst unlinkFile = (path, cb) => {\n  if (process.platform !== 'win32') return fs.unlink(path, cb);\n  const name = path + '.DELETE.' + crypto.randomBytes(16).toString('hex');\n  fs.rename(path, name, er => {\n    if (er) return cb(er);\n    fs.unlink(name, cb);\n  });\n};\n/* istanbul ignore next */\n\n\nconst unlinkFileSync = path => {\n  if (process.platform !== 'win32') return fs.unlinkSync(path);\n  const name = path + '.DELETE.' + crypto.randomBytes(16).toString('hex');\n  fs.renameSync(path, name);\n  fs.unlinkSync(name);\n}; // this.gid, entry.gid, this.processUid\n\n\nconst uint32 = (a, b, c) => a === a >>> 0 ? a : b === b >>> 0 ? b : c;\n\nclass Unpack extends Parser {\n  constructor(opt) {\n    if (!opt) opt = {};\n\n    opt.ondone = _ => {\n      this[ENDED] = true;\n      this[MAYBECLOSE]();\n    };\n\n    super(opt);\n    this.transform = typeof opt.transform === 'function' ? opt.transform : null;\n    this.writable = true;\n    this.readable = false;\n    this[PENDING] = 0;\n    this[ENDED] = false;\n    this.dirCache = opt.dirCache || new Map();\n\n    if (typeof opt.uid === 'number' || typeof opt.gid === 'number') {\n      // need both or neither\n      if (typeof opt.uid !== 'number' || typeof opt.gid !== 'number') throw new TypeError('cannot set owner without number uid and gid');\n      if (opt.preserveOwner) throw new TypeError('cannot preserve owner in archive and also set owner explicitly');\n      this.uid = opt.uid;\n      this.gid = opt.gid;\n      this.setOwner = true;\n    } else {\n      this.uid = null;\n      this.gid = null;\n      this.setOwner = false;\n    } // default true for root\n\n\n    if (opt.preserveOwner === undefined && typeof opt.uid !== 'number') this.preserveOwner = process.getuid && process.getuid() === 0;else this.preserveOwner = !!opt.preserveOwner;\n    this.processUid = (this.preserveOwner || this.setOwner) && process.getuid ? process.getuid() : null;\n    this.processGid = (this.preserveOwner || this.setOwner) && process.getgid ? process.getgid() : null; // mostly just for testing, but useful in some cases.\n    // Forcibly trigger a chown on every entry, no matter what\n\n    this.forceChown = opt.forceChown === true; // turn ><?| in filenames into 0xf000-higher encoded forms\n\n    this.win32 = !!opt.win32 || process.platform === 'win32'; // do not unpack over files that are newer than what's in the archive\n\n    this.newer = !!opt.newer; // do not unpack over ANY files\n\n    this.keep = !!opt.keep; // do not set mtime/atime of extracted entries\n\n    this.noMtime = !!opt.noMtime; // allow .., absolute path entries, and unpacking through symlinks\n    // without this, warn and skip .., relativize absolutes, and error\n    // on symlinks in extraction path\n\n    this.preservePaths = !!opt.preservePaths; // unlink files and links before writing. This breaks existing hard\n    // links, and removes symlink directories rather than erroring\n\n    this.unlink = !!opt.unlink;\n    this.cwd = path.resolve(opt.cwd || process.cwd());\n    this.strip = +opt.strip || 0;\n    this.processUmask = process.umask();\n    this.umask = typeof opt.umask === 'number' ? opt.umask : this.processUmask; // default mode for dirs created as parents\n\n    this.dmode = opt.dmode || 0o0777 & ~this.umask;\n    this.fmode = opt.fmode || 0o0666 & ~this.umask;\n    this.on('entry', entry => this[ONENTRY](entry));\n  }\n\n  [MAYBECLOSE]() {\n    if (this[ENDED] && this[PENDING] === 0) {\n      this.emit('prefinish');\n      this.emit('finish');\n      this.emit('end');\n      this.emit('close');\n    }\n  }\n\n  [CHECKPATH](entry) {\n    if (this.strip) {\n      const parts = entry.path.split(/\\/|\\\\/);\n      if (parts.length < this.strip) return false;\n      entry.path = parts.slice(this.strip).join('/');\n\n      if (entry.type === 'Link') {\n        const linkparts = entry.linkpath.split(/\\/|\\\\/);\n        if (linkparts.length >= this.strip) entry.linkpath = linkparts.slice(this.strip).join('/');\n      }\n    }\n\n    if (!this.preservePaths) {\n      const p = entry.path;\n\n      if (p.match(/(^|\\/|\\\\)\\.\\.(\\\\|\\/|$)/)) {\n        this.warn('path contains \\'..\\'', p);\n        return false;\n      } // absolutes on posix are also absolutes on win32\n      // so we only need to test this one to get both\n\n\n      if (path.win32.isAbsolute(p)) {\n        const parsed = path.win32.parse(p);\n        this.warn('stripping ' + parsed.root + ' from absolute path', p);\n        entry.path = p.substr(parsed.root.length);\n      }\n    } // only encode : chars that aren't drive letter indicators\n\n\n    if (this.win32) {\n      const parsed = path.win32.parse(entry.path);\n      entry.path = parsed.root === '' ? wc.encode(entry.path) : parsed.root + wc.encode(entry.path.substr(parsed.root.length));\n    }\n\n    if (path.isAbsolute(entry.path)) entry.absolute = entry.path;else entry.absolute = path.resolve(this.cwd, entry.path);\n    return true;\n  }\n\n  [ONENTRY](entry) {\n    if (!this[CHECKPATH](entry)) return entry.resume();\n    assert.equal(typeof entry.absolute, 'string');\n\n    switch (entry.type) {\n      case 'Directory':\n      case 'GNUDumpDir':\n        if (entry.mode) entry.mode = entry.mode | 0o700;\n\n      case 'File':\n      case 'OldFile':\n      case 'ContiguousFile':\n      case 'Link':\n      case 'SymbolicLink':\n        return this[CHECKFS](entry);\n\n      case 'CharacterDevice':\n      case 'BlockDevice':\n      case 'FIFO':\n        return this[UNSUPPORTED](entry);\n    }\n  }\n\n  [ONERROR](er, entry) {\n    // Cwd has to exist, or else nothing works. That's serious.\n    // Other errors are warnings, which raise the error in strict\n    // mode, but otherwise continue on.\n    if (er.name === 'CwdError') this.emit('error', er);else {\n      this.warn(er.message, er);\n      this[UNPEND]();\n      entry.resume();\n    }\n  }\n\n  [MKDIR](dir, mode, cb) {\n    mkdir(dir, {\n      uid: this.uid,\n      gid: this.gid,\n      processUid: this.processUid,\n      processGid: this.processGid,\n      umask: this.processUmask,\n      preserve: this.preservePaths,\n      unlink: this.unlink,\n      cache: this.dirCache,\n      cwd: this.cwd,\n      mode: mode\n    }, cb);\n  }\n\n  [DOCHOWN](entry) {\n    // in preserve owner mode, chown if the entry doesn't match process\n    // in set owner mode, chown if setting doesn't match process\n    return this.forceChown || this.preserveOwner && (typeof entry.uid === 'number' && entry.uid !== this.processUid || typeof entry.gid === 'number' && entry.gid !== this.processGid) || typeof this.uid === 'number' && this.uid !== this.processUid || typeof this.gid === 'number' && this.gid !== this.processGid;\n  }\n\n  [UID](entry) {\n    return uint32(this.uid, entry.uid, this.processUid);\n  }\n\n  [GID](entry) {\n    return uint32(this.gid, entry.gid, this.processGid);\n  }\n\n  [FILE](entry) {\n    const mode = entry.mode & 0o7777 || this.fmode;\n    const stream = new fsm.WriteStream(entry.absolute, {\n      mode: mode,\n      autoClose: false\n    });\n    stream.on('error', er => this[ONERROR](er, entry));\n    let actions = 1;\n\n    const done = er => {\n      if (er) return this[ONERROR](er, entry);\n      if (--actions === 0) fs.close(stream.fd, _ => this[UNPEND]());\n    };\n\n    stream.on('finish', _ => {\n      // if futimes fails, try utimes\n      // if utimes fails, fail with the original error\n      // same for fchown/chown\n      const abs = entry.absolute;\n      const fd = stream.fd;\n\n      if (entry.mtime && !this.noMtime) {\n        actions++;\n        const atime = entry.atime || new Date();\n        const mtime = entry.mtime;\n        fs.futimes(fd, atime, mtime, er => er ? fs.utimes(abs, atime, mtime, er2 => done(er2 && er)) : done());\n      }\n\n      if (this[DOCHOWN](entry)) {\n        actions++;\n        const uid = this[UID](entry);\n        const gid = this[GID](entry);\n        fs.fchown(fd, uid, gid, er => er ? fs.chown(abs, uid, gid, er2 => done(er2 && er)) : done());\n      }\n\n      done();\n    });\n    const tx = this.transform ? this.transform(entry) || entry : entry;\n\n    if (tx !== entry) {\n      tx.on('error', er => this[ONERROR](er, entry));\n      entry.pipe(tx);\n    }\n\n    tx.pipe(stream);\n  }\n\n  [DIRECTORY](entry) {\n    const mode = entry.mode & 0o7777 || this.dmode;\n    this[MKDIR](entry.absolute, mode, er => {\n      if (er) return this[ONERROR](er, entry);\n      let actions = 1;\n\n      const done = _ => {\n        if (--actions === 0) {\n          this[UNPEND]();\n          entry.resume();\n        }\n      };\n\n      if (entry.mtime && !this.noMtime) {\n        actions++;\n        fs.utimes(entry.absolute, entry.atime || new Date(), entry.mtime, done);\n      }\n\n      if (this[DOCHOWN](entry)) {\n        actions++;\n        fs.chown(entry.absolute, this[UID](entry), this[GID](entry), done);\n      }\n\n      done();\n    });\n  }\n\n  [UNSUPPORTED](entry) {\n    this.warn('unsupported entry type: ' + entry.type, entry);\n    entry.resume();\n  }\n\n  [SYMLINK](entry) {\n    this[LINK](entry, entry.linkpath, 'symlink');\n  }\n\n  [HARDLINK](entry) {\n    this[LINK](entry, path.resolve(this.cwd, entry.linkpath), 'link');\n  }\n\n  [PEND]() {\n    this[PENDING]++;\n  }\n\n  [UNPEND]() {\n    this[PENDING]--;\n    this[MAYBECLOSE]();\n  }\n\n  [SKIP](entry) {\n    this[UNPEND]();\n    entry.resume();\n  } // Check if we can reuse an existing filesystem entry safely and\n  // overwrite it, rather than unlinking and recreating\n  // Windows doesn't report a useful nlink, so we just never reuse entries\n\n\n  [ISREUSABLE](entry, st) {\n    return entry.type === 'File' && !this.unlink && st.isFile() && st.nlink <= 1 && process.platform !== 'win32';\n  } // check if a thing is there, and if so, try to clobber it\n\n\n  [CHECKFS](entry) {\n    this[PEND]();\n    this[MKDIR](path.dirname(entry.absolute), this.dmode, er => {\n      if (er) return this[ONERROR](er, entry);\n      fs.lstat(entry.absolute, (er, st) => {\n        if (st && (this.keep || this.newer && st.mtime > entry.mtime)) this[SKIP](entry);else if (er || this[ISREUSABLE](entry, st)) this[MAKEFS](null, entry);else if (st.isDirectory()) {\n          if (entry.type === 'Directory') {\n            if (!entry.mode || (st.mode & 0o7777) === entry.mode) this[MAKEFS](null, entry);else fs.chmod(entry.absolute, entry.mode, er => this[MAKEFS](er, entry));\n          } else fs.rmdir(entry.absolute, er => this[MAKEFS](er, entry));\n        } else unlinkFile(entry.absolute, er => this[MAKEFS](er, entry));\n      });\n    });\n  }\n\n  [MAKEFS](er, entry) {\n    if (er) return this[ONERROR](er, entry);\n\n    switch (entry.type) {\n      case 'File':\n      case 'OldFile':\n      case 'ContiguousFile':\n        return this[FILE](entry);\n\n      case 'Link':\n        return this[HARDLINK](entry);\n\n      case 'SymbolicLink':\n        return this[SYMLINK](entry);\n\n      case 'Directory':\n      case 'GNUDumpDir':\n        return this[DIRECTORY](entry);\n    }\n  }\n\n  [LINK](entry, linkpath, link) {\n    // XXX: get the type ('file' or 'dir') for windows\n    fs[link](linkpath, entry.absolute, er => {\n      if (er) return this[ONERROR](er, entry);\n      this[UNPEND]();\n      entry.resume();\n    });\n  }\n\n}\n\nclass UnpackSync extends Unpack {\n  constructor(opt) {\n    super(opt);\n  }\n\n  [CHECKFS](entry) {\n    const er = this[MKDIR](path.dirname(entry.absolute), this.dmode);\n    if (er) return this[ONERROR](er, entry);\n\n    try {\n      const st = fs.lstatSync(entry.absolute);\n      if (this.keep || this.newer && st.mtime > entry.mtime) return this[SKIP](entry);else if (this[ISREUSABLE](entry, st)) return this[MAKEFS](null, entry);else {\n        try {\n          if (st.isDirectory()) {\n            if (entry.type === 'Directory') {\n              if (entry.mode && (st.mode & 0o7777) !== entry.mode) fs.chmodSync(entry.absolute, entry.mode);\n            } else fs.rmdirSync(entry.absolute);\n          } else unlinkFileSync(entry.absolute);\n\n          return this[MAKEFS](null, entry);\n        } catch (er) {\n          return this[ONERROR](er, entry);\n        }\n      }\n    } catch (er) {\n      return this[MAKEFS](null, entry);\n    }\n  }\n\n  [FILE](entry) {\n    const mode = entry.mode & 0o7777 || this.fmode;\n\n    const oner = er => {\n      try {\n        fs.closeSync(fd);\n      } catch (_) {}\n\n      if (er) this[ONERROR](er, entry);\n    };\n\n    let stream;\n    let fd;\n\n    try {\n      fd = fs.openSync(entry.absolute, 'w', mode);\n    } catch (er) {\n      return oner(er);\n    }\n\n    const tx = this.transform ? this.transform(entry) || entry : entry;\n\n    if (tx !== entry) {\n      tx.on('error', er => this[ONERROR](er, entry));\n      entry.pipe(tx);\n    }\n\n    tx.on('data', chunk => {\n      try {\n        fs.writeSync(fd, chunk, 0, chunk.length);\n      } catch (er) {\n        oner(er);\n      }\n    });\n    tx.on('end', _ => {\n      let er = null; // try both, falling futimes back to utimes\n      // if either fails, handle the first error\n\n      if (entry.mtime && !this.noMtime) {\n        const atime = entry.atime || new Date();\n        const mtime = entry.mtime;\n\n        try {\n          fs.futimesSync(fd, atime, mtime);\n        } catch (futimeser) {\n          try {\n            fs.utimesSync(entry.absolute, atime, mtime);\n          } catch (utimeser) {\n            er = futimeser;\n          }\n        }\n      }\n\n      if (this[DOCHOWN](entry)) {\n        const uid = this[UID](entry);\n        const gid = this[GID](entry);\n\n        try {\n          fs.fchownSync(fd, uid, gid);\n        } catch (fchowner) {\n          try {\n            fs.chownSync(entry.absolute, uid, gid);\n          } catch (chowner) {\n            er = er || fchowner;\n          }\n        }\n      }\n\n      oner(er);\n    });\n  }\n\n  [DIRECTORY](entry) {\n    const mode = entry.mode & 0o7777 || this.dmode;\n    const er = this[MKDIR](entry.absolute, mode);\n    if (er) return this[ONERROR](er, entry);\n\n    if (entry.mtime && !this.noMtime) {\n      try {\n        fs.utimesSync(entry.absolute, entry.atime || new Date(), entry.mtime);\n      } catch (er) {}\n    }\n\n    if (this[DOCHOWN](entry)) {\n      try {\n        fs.chownSync(entry.absolute, this[UID](entry), this[GID](entry));\n      } catch (er) {}\n    }\n\n    entry.resume();\n  }\n\n  [MKDIR](dir, mode) {\n    try {\n      return mkdir.sync(dir, {\n        uid: this.uid,\n        gid: this.gid,\n        processUid: this.processUid,\n        processGid: this.processGid,\n        umask: this.processUmask,\n        preserve: this.preservePaths,\n        unlink: this.unlink,\n        cache: this.dirCache,\n        cwd: this.cwd,\n        mode: mode\n      });\n    } catch (er) {\n      return er;\n    }\n  }\n\n  [LINK](entry, linkpath, link) {\n    try {\n      fs[link + 'Sync'](linkpath, entry.absolute);\n      entry.resume();\n    } catch (er) {\n      return this[ONERROR](er, entry);\n    }\n  }\n\n}\n\nUnpack.Sync = UnpackSync;\nmodule.exports = Unpack;","map":{"version":3,"sources":["/home/n/React/loginpagedemo/frontend/node_modules/tar/lib/unpack.js"],"names":["assert","require","EE","EventEmitter","Parser","fs","fsm","path","mkdir","mkdirSync","sync","wc","ONENTRY","Symbol","CHECKFS","ISREUSABLE","MAKEFS","FILE","DIRECTORY","LINK","SYMLINK","HARDLINK","UNSUPPORTED","UNKNOWN","CHECKPATH","MKDIR","ONERROR","PENDING","PEND","UNPEND","ENDED","MAYBECLOSE","SKIP","DOCHOWN","UID","GID","crypto","unlinkFile","cb","process","platform","unlink","name","randomBytes","toString","rename","er","unlinkFileSync","unlinkSync","renameSync","uint32","a","b","c","Unpack","constructor","opt","ondone","_","transform","writable","readable","dirCache","Map","uid","gid","TypeError","preserveOwner","setOwner","undefined","getuid","processUid","processGid","getgid","forceChown","win32","newer","keep","noMtime","preservePaths","cwd","resolve","strip","processUmask","umask","dmode","fmode","on","entry","emit","parts","split","length","slice","join","type","linkparts","linkpath","p","match","warn","isAbsolute","parsed","parse","root","substr","encode","absolute","resume","equal","mode","message","dir","preserve","cache","stream","WriteStream","autoClose","actions","done","close","fd","abs","mtime","atime","Date","futimes","utimes","er2","fchown","chown","tx","pipe","st","isFile","nlink","dirname","lstat","isDirectory","chmod","rmdir","link","UnpackSync","lstatSync","chmodSync","rmdirSync","oner","closeSync","openSync","chunk","writeSync","futimesSync","futimeser","utimesSync","utimeser","fchownSync","fchowner","chownSync","chowner","Sync","module","exports"],"mappings":"AAAA;;AAEA,MAAMA,MAAM,GAAGC,OAAO,CAAC,QAAD,CAAtB;;AACA,MAAMC,EAAE,GAAGD,OAAO,CAAC,QAAD,CAAP,CAAkBE,YAA7B;;AACA,MAAMC,MAAM,GAAGH,OAAO,CAAC,YAAD,CAAtB;;AACA,MAAMI,EAAE,GAAGJ,OAAO,CAAC,IAAD,CAAlB;;AACA,MAAMK,GAAG,GAAGL,OAAO,CAAC,aAAD,CAAnB;;AACA,MAAMM,IAAI,GAAGN,OAAO,CAAC,MAAD,CAApB;;AACA,MAAMO,KAAK,GAAGP,OAAO,CAAC,YAAD,CAArB;;AACA,MAAMQ,SAAS,GAAGD,KAAK,CAACE,IAAxB;;AACA,MAAMC,EAAE,GAAGV,OAAO,CAAC,eAAD,CAAlB;;AAEA,MAAMW,OAAO,GAAGC,MAAM,CAAC,SAAD,CAAtB;AACA,MAAMC,OAAO,GAAGD,MAAM,CAAC,SAAD,CAAtB;AACA,MAAME,UAAU,GAAGF,MAAM,CAAC,YAAD,CAAzB;AACA,MAAMG,MAAM,GAAGH,MAAM,CAAC,QAAD,CAArB;AACA,MAAMI,IAAI,GAAGJ,MAAM,CAAC,MAAD,CAAnB;AACA,MAAMK,SAAS,GAAGL,MAAM,CAAC,WAAD,CAAxB;AACA,MAAMM,IAAI,GAAGN,MAAM,CAAC,MAAD,CAAnB;AACA,MAAMO,OAAO,GAAGP,MAAM,CAAC,SAAD,CAAtB;AACA,MAAMQ,QAAQ,GAAGR,MAAM,CAAC,UAAD,CAAvB;AACA,MAAMS,WAAW,GAAGT,MAAM,CAAC,aAAD,CAA1B;AACA,MAAMU,OAAO,GAAGV,MAAM,CAAC,SAAD,CAAtB;AACA,MAAMW,SAAS,GAAGX,MAAM,CAAC,WAAD,CAAxB;AACA,MAAMY,KAAK,GAAGZ,MAAM,CAAC,OAAD,CAApB;AACA,MAAMa,OAAO,GAAGb,MAAM,CAAC,SAAD,CAAtB;AACA,MAAMc,OAAO,GAAGd,MAAM,CAAC,SAAD,CAAtB;AACA,MAAMe,IAAI,GAAGf,MAAM,CAAC,MAAD,CAAnB;AACA,MAAMgB,MAAM,GAAGhB,MAAM,CAAC,QAAD,CAArB;AACA,MAAMiB,KAAK,GAAGjB,MAAM,CAAC,OAAD,CAApB;AACA,MAAMkB,UAAU,GAAGlB,MAAM,CAAC,YAAD,CAAzB;AACA,MAAMmB,IAAI,GAAGnB,MAAM,CAAC,MAAD,CAAnB;AACA,MAAMoB,OAAO,GAAGpB,MAAM,CAAC,SAAD,CAAtB;AACA,MAAMqB,GAAG,GAAGrB,MAAM,CAAC,KAAD,CAAlB;AACA,MAAMsB,GAAG,GAAGtB,MAAM,CAAC,KAAD,CAAlB;;AACA,MAAMuB,MAAM,GAAGnC,OAAO,CAAC,QAAD,CAAtB,C,CAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA;;;AACA,MAAMoC,UAAU,GAAG,CAAC9B,IAAD,EAAO+B,EAAP,KAAc;AAC/B,MAAIC,OAAO,CAACC,QAAR,KAAqB,OAAzB,EACE,OAAOnC,EAAE,CAACoC,MAAH,CAAUlC,IAAV,EAAgB+B,EAAhB,CAAP;AAEF,QAAMI,IAAI,GAAGnC,IAAI,GAAG,UAAP,GAAoB6B,MAAM,CAACO,WAAP,CAAmB,EAAnB,EAAuBC,QAAvB,CAAgC,KAAhC,CAAjC;AACAvC,EAAAA,EAAE,CAACwC,MAAH,CAAUtC,IAAV,EAAgBmC,IAAhB,EAAsBI,EAAE,IAAI;AAC1B,QAAIA,EAAJ,EACE,OAAOR,EAAE,CAACQ,EAAD,CAAT;AACFzC,IAAAA,EAAE,CAACoC,MAAH,CAAUC,IAAV,EAAgBJ,EAAhB;AACD,GAJD;AAKD,CAVD;AAYA;;;AACA,MAAMS,cAAc,GAAGxC,IAAI,IAAI;AAC7B,MAAIgC,OAAO,CAACC,QAAR,KAAqB,OAAzB,EACE,OAAOnC,EAAE,CAAC2C,UAAH,CAAczC,IAAd,CAAP;AAEF,QAAMmC,IAAI,GAAGnC,IAAI,GAAG,UAAP,GAAoB6B,MAAM,CAACO,WAAP,CAAmB,EAAnB,EAAuBC,QAAvB,CAAgC,KAAhC,CAAjC;AACAvC,EAAAA,EAAE,CAAC4C,UAAH,CAAc1C,IAAd,EAAoBmC,IAApB;AACArC,EAAAA,EAAE,CAAC2C,UAAH,CAAcN,IAAd;AACD,CAPD,C,CASA;;;AACA,MAAMQ,MAAM,GAAG,CAACC,CAAD,EAAIC,CAAJ,EAAOC,CAAP,KACbF,CAAC,KAAKA,CAAC,KAAK,CAAZ,GAAgBA,CAAhB,GACEC,CAAC,KAAKA,CAAC,KAAK,CAAZ,GAAgBA,CAAhB,GACAC,CAHJ;;AAKA,MAAMC,MAAN,SAAqBlD,MAArB,CAA4B;AAC1BmD,EAAAA,WAAW,CAAEC,GAAF,EAAO;AAChB,QAAI,CAACA,GAAL,EACEA,GAAG,GAAG,EAAN;;AAEFA,IAAAA,GAAG,CAACC,MAAJ,GAAaC,CAAC,IAAI;AAChB,WAAK5B,KAAL,IAAc,IAAd;AACA,WAAKC,UAAL;AACD,KAHD;;AAKA,UAAMyB,GAAN;AAEA,SAAKG,SAAL,GAAiB,OAAOH,GAAG,CAACG,SAAX,KAAyB,UAAzB,GAAsCH,GAAG,CAACG,SAA1C,GAAsD,IAAvE;AAEA,SAAKC,QAAL,GAAgB,IAAhB;AACA,SAAKC,QAAL,GAAgB,KAAhB;AAEA,SAAKlC,OAAL,IAAgB,CAAhB;AACA,SAAKG,KAAL,IAAc,KAAd;AAEA,SAAKgC,QAAL,GAAgBN,GAAG,CAACM,QAAJ,IAAgB,IAAIC,GAAJ,EAAhC;;AAEA,QAAI,OAAOP,GAAG,CAACQ,GAAX,KAAmB,QAAnB,IAA+B,OAAOR,GAAG,CAACS,GAAX,KAAmB,QAAtD,EAAgE;AAC9D;AACA,UAAI,OAAOT,GAAG,CAACQ,GAAX,KAAmB,QAAnB,IAA+B,OAAOR,GAAG,CAACS,GAAX,KAAmB,QAAtD,EACE,MAAM,IAAIC,SAAJ,CAAc,6CAAd,CAAN;AACF,UAAIV,GAAG,CAACW,aAAR,EACE,MAAM,IAAID,SAAJ,CACJ,gEADI,CAAN;AAEF,WAAKF,GAAL,GAAWR,GAAG,CAACQ,GAAf;AACA,WAAKC,GAAL,GAAWT,GAAG,CAACS,GAAf;AACA,WAAKG,QAAL,GAAgB,IAAhB;AACD,KAVD,MAUO;AACL,WAAKJ,GAAL,GAAW,IAAX;AACA,WAAKC,GAAL,GAAW,IAAX;AACA,WAAKG,QAAL,GAAgB,KAAhB;AACD,KAnCe,CAqChB;;;AACA,QAAIZ,GAAG,CAACW,aAAJ,KAAsBE,SAAtB,IAAmC,OAAOb,GAAG,CAACQ,GAAX,KAAmB,QAA1D,EACE,KAAKG,aAAL,GAAqB5B,OAAO,CAAC+B,MAAR,IAAkB/B,OAAO,CAAC+B,MAAR,OAAqB,CAA5D,CADF,KAGE,KAAKH,aAAL,GAAqB,CAAC,CAACX,GAAG,CAACW,aAA3B;AAEF,SAAKI,UAAL,GAAkB,CAAC,KAAKJ,aAAL,IAAsB,KAAKC,QAA5B,KAAyC7B,OAAO,CAAC+B,MAAjD,GAChB/B,OAAO,CAAC+B,MAAR,EADgB,GACG,IADrB;AAEA,SAAKE,UAAL,GAAkB,CAAC,KAAKL,aAAL,IAAsB,KAAKC,QAA5B,KAAyC7B,OAAO,CAACkC,MAAjD,GAChBlC,OAAO,CAACkC,MAAR,EADgB,GACG,IADrB,CA7CgB,CAgDhB;AACA;;AACA,SAAKC,UAAL,GAAkBlB,GAAG,CAACkB,UAAJ,KAAmB,IAArC,CAlDgB,CAoDhB;;AACA,SAAKC,KAAL,GAAa,CAAC,CAACnB,GAAG,CAACmB,KAAN,IAAepC,OAAO,CAACC,QAAR,KAAqB,OAAjD,CArDgB,CAuDhB;;AACA,SAAKoC,KAAL,GAAa,CAAC,CAACpB,GAAG,CAACoB,KAAnB,CAxDgB,CA0DhB;;AACA,SAAKC,IAAL,GAAY,CAAC,CAACrB,GAAG,CAACqB,IAAlB,CA3DgB,CA6DhB;;AACA,SAAKC,OAAL,GAAe,CAAC,CAACtB,GAAG,CAACsB,OAArB,CA9DgB,CAgEhB;AACA;AACA;;AACA,SAAKC,aAAL,GAAqB,CAAC,CAACvB,GAAG,CAACuB,aAA3B,CAnEgB,CAqEhB;AACA;;AACA,SAAKtC,MAAL,GAAc,CAAC,CAACe,GAAG,CAACf,MAApB;AAEA,SAAKuC,GAAL,GAAWzE,IAAI,CAAC0E,OAAL,CAAazB,GAAG,CAACwB,GAAJ,IAAWzC,OAAO,CAACyC,GAAR,EAAxB,CAAX;AACA,SAAKE,KAAL,GAAa,CAAC1B,GAAG,CAAC0B,KAAL,IAAc,CAA3B;AACA,SAAKC,YAAL,GAAoB5C,OAAO,CAAC6C,KAAR,EAApB;AACA,SAAKA,KAAL,GAAa,OAAO5B,GAAG,CAAC4B,KAAX,KAAqB,QAArB,GAAgC5B,GAAG,CAAC4B,KAApC,GAA4C,KAAKD,YAA9D,CA5EgB,CA6EhB;;AACA,SAAKE,KAAL,GAAa7B,GAAG,CAAC6B,KAAJ,IAAc,SAAU,CAAC,KAAKD,KAA3C;AACA,SAAKE,KAAL,GAAa9B,GAAG,CAAC8B,KAAJ,IAAc,SAAU,CAAC,KAAKF,KAA3C;AACA,SAAKG,EAAL,CAAQ,OAAR,EAAiBC,KAAK,IAAI,KAAK5E,OAAL,EAAc4E,KAAd,CAA1B;AACD;;AAED,GAACzD,UAAD,IAAgB;AACd,QAAI,KAAKD,KAAL,KAAe,KAAKH,OAAL,MAAkB,CAArC,EAAwC;AACtC,WAAK8D,IAAL,CAAU,WAAV;AACA,WAAKA,IAAL,CAAU,QAAV;AACA,WAAKA,IAAL,CAAU,KAAV;AACA,WAAKA,IAAL,CAAU,OAAV;AACD;AACF;;AAED,GAACjE,SAAD,EAAagE,KAAb,EAAoB;AAClB,QAAI,KAAKN,KAAT,EAAgB;AACd,YAAMQ,KAAK,GAAGF,KAAK,CAACjF,IAAN,CAAWoF,KAAX,CAAiB,OAAjB,CAAd;AACA,UAAID,KAAK,CAACE,MAAN,GAAe,KAAKV,KAAxB,EACE,OAAO,KAAP;AACFM,MAAAA,KAAK,CAACjF,IAAN,GAAamF,KAAK,CAACG,KAAN,CAAY,KAAKX,KAAjB,EAAwBY,IAAxB,CAA6B,GAA7B,CAAb;;AAEA,UAAIN,KAAK,CAACO,IAAN,KAAe,MAAnB,EAA2B;AACzB,cAAMC,SAAS,GAAGR,KAAK,CAACS,QAAN,CAAeN,KAAf,CAAqB,OAArB,CAAlB;AACA,YAAIK,SAAS,CAACJ,MAAV,IAAoB,KAAKV,KAA7B,EACEM,KAAK,CAACS,QAAN,GAAiBD,SAAS,CAACH,KAAV,CAAgB,KAAKX,KAArB,EAA4BY,IAA5B,CAAiC,GAAjC,CAAjB;AACH;AACF;;AAED,QAAI,CAAC,KAAKf,aAAV,EAAyB;AACvB,YAAMmB,CAAC,GAAGV,KAAK,CAACjF,IAAhB;;AACA,UAAI2F,CAAC,CAACC,KAAF,CAAQ,wBAAR,CAAJ,EAAuC;AACrC,aAAKC,IAAL,CAAU,sBAAV,EAAkCF,CAAlC;AACA,eAAO,KAAP;AACD,OALsB,CAOvB;AACA;;;AACA,UAAI3F,IAAI,CAACoE,KAAL,CAAW0B,UAAX,CAAsBH,CAAtB,CAAJ,EAA8B;AAC5B,cAAMI,MAAM,GAAG/F,IAAI,CAACoE,KAAL,CAAW4B,KAAX,CAAiBL,CAAjB,CAAf;AACA,aAAKE,IAAL,CAAU,eAAeE,MAAM,CAACE,IAAtB,GAA6B,qBAAvC,EAA8DN,CAA9D;AACAV,QAAAA,KAAK,CAACjF,IAAN,GAAa2F,CAAC,CAACO,MAAF,CAASH,MAAM,CAACE,IAAP,CAAYZ,MAArB,CAAb;AACD;AACF,KA5BiB,CA8BlB;;;AACA,QAAI,KAAKjB,KAAT,EAAgB;AACd,YAAM2B,MAAM,GAAG/F,IAAI,CAACoE,KAAL,CAAW4B,KAAX,CAAiBf,KAAK,CAACjF,IAAvB,CAAf;AACAiF,MAAAA,KAAK,CAACjF,IAAN,GAAa+F,MAAM,CAACE,IAAP,KAAgB,EAAhB,GAAqB7F,EAAE,CAAC+F,MAAH,CAAUlB,KAAK,CAACjF,IAAhB,CAArB,GACT+F,MAAM,CAACE,IAAP,GAAc7F,EAAE,CAAC+F,MAAH,CAAUlB,KAAK,CAACjF,IAAN,CAAWkG,MAAX,CAAkBH,MAAM,CAACE,IAAP,CAAYZ,MAA9B,CAAV,CADlB;AAED;;AAED,QAAIrF,IAAI,CAAC8F,UAAL,CAAgBb,KAAK,CAACjF,IAAtB,CAAJ,EACEiF,KAAK,CAACmB,QAAN,GAAiBnB,KAAK,CAACjF,IAAvB,CADF,KAGEiF,KAAK,CAACmB,QAAN,GAAiBpG,IAAI,CAAC0E,OAAL,CAAa,KAAKD,GAAlB,EAAuBQ,KAAK,CAACjF,IAA7B,CAAjB;AAEF,WAAO,IAAP;AACD;;AAED,GAACK,OAAD,EAAW4E,KAAX,EAAkB;AAChB,QAAI,CAAC,KAAKhE,SAAL,EAAgBgE,KAAhB,CAAL,EACE,OAAOA,KAAK,CAACoB,MAAN,EAAP;AAEF5G,IAAAA,MAAM,CAAC6G,KAAP,CAAa,OAAOrB,KAAK,CAACmB,QAA1B,EAAoC,QAApC;;AAEA,YAAQnB,KAAK,CAACO,IAAd;AACE,WAAK,WAAL;AACA,WAAK,YAAL;AACE,YAAIP,KAAK,CAACsB,IAAV,EACEtB,KAAK,CAACsB,IAAN,GAAatB,KAAK,CAACsB,IAAN,GAAa,KAA1B;;AAEJ,WAAK,MAAL;AACA,WAAK,SAAL;AACA,WAAK,gBAAL;AACA,WAAK,MAAL;AACA,WAAK,cAAL;AACE,eAAO,KAAKhG,OAAL,EAAc0E,KAAd,CAAP;;AAEF,WAAK,iBAAL;AACA,WAAK,aAAL;AACA,WAAK,MAAL;AACE,eAAO,KAAKlE,WAAL,EAAkBkE,KAAlB,CAAP;AAhBJ;AAkBD;;AAED,GAAC9D,OAAD,EAAWoB,EAAX,EAAe0C,KAAf,EAAsB;AACpB;AACA;AACA;AACA,QAAI1C,EAAE,CAACJ,IAAH,KAAY,UAAhB,EACE,KAAK+C,IAAL,CAAU,OAAV,EAAmB3C,EAAnB,EADF,KAEK;AACH,WAAKsD,IAAL,CAAUtD,EAAE,CAACiE,OAAb,EAAsBjE,EAAtB;AACA,WAAKjB,MAAL;AACA2D,MAAAA,KAAK,CAACoB,MAAN;AACD;AACF;;AAED,GAACnF,KAAD,EAASuF,GAAT,EAAcF,IAAd,EAAoBxE,EAApB,EAAwB;AACtB9B,IAAAA,KAAK,CAACwG,GAAD,EAAM;AACThD,MAAAA,GAAG,EAAE,KAAKA,GADD;AAETC,MAAAA,GAAG,EAAE,KAAKA,GAFD;AAGTM,MAAAA,UAAU,EAAE,KAAKA,UAHR;AAITC,MAAAA,UAAU,EAAE,KAAKA,UAJR;AAKTY,MAAAA,KAAK,EAAE,KAAKD,YALH;AAMT8B,MAAAA,QAAQ,EAAE,KAAKlC,aANN;AAOTtC,MAAAA,MAAM,EAAE,KAAKA,MAPJ;AAQTyE,MAAAA,KAAK,EAAE,KAAKpD,QARH;AASTkB,MAAAA,GAAG,EAAE,KAAKA,GATD;AAUT8B,MAAAA,IAAI,EAAEA;AAVG,KAAN,EAWFxE,EAXE,CAAL;AAYD;;AAED,GAACL,OAAD,EAAWuD,KAAX,EAAkB;AAChB;AACA;AACA,WAAO,KAAKd,UAAL,IACL,KAAKP,aAAL,KACE,OAAOqB,KAAK,CAACxB,GAAb,KAAqB,QAArB,IAAiCwB,KAAK,CAACxB,GAAN,KAAc,KAAKO,UAApD,IACA,OAAOiB,KAAK,CAACvB,GAAb,KAAqB,QAArB,IAAiCuB,KAAK,CAACvB,GAAN,KAAc,KAAKO,UAFtD,CADK,IAKH,OAAO,KAAKR,GAAZ,KAAoB,QAApB,IAAgC,KAAKA,GAAL,KAAa,KAAKO,UAAlD,IACA,OAAO,KAAKN,GAAZ,KAAoB,QAApB,IAAgC,KAAKA,GAAL,KAAa,KAAKO,UANtD;AAOD;;AAED,GAACtC,GAAD,EAAOsD,KAAP,EAAc;AACZ,WAAOtC,MAAM,CAAC,KAAKc,GAAN,EAAWwB,KAAK,CAACxB,GAAjB,EAAsB,KAAKO,UAA3B,CAAb;AACD;;AAED,GAACpC,GAAD,EAAOqD,KAAP,EAAc;AACZ,WAAOtC,MAAM,CAAC,KAAKe,GAAN,EAAWuB,KAAK,CAACvB,GAAjB,EAAsB,KAAKO,UAA3B,CAAb;AACD;;AAED,GAACvD,IAAD,EAAQuE,KAAR,EAAe;AACb,UAAMsB,IAAI,GAAGtB,KAAK,CAACsB,IAAN,GAAa,MAAb,IAAuB,KAAKxB,KAAzC;AACA,UAAM6B,MAAM,GAAG,IAAI7G,GAAG,CAAC8G,WAAR,CAAoB5B,KAAK,CAACmB,QAA1B,EAAoC;AACjDG,MAAAA,IAAI,EAAEA,IAD2C;AAEjDO,MAAAA,SAAS,EAAE;AAFsC,KAApC,CAAf;AAIAF,IAAAA,MAAM,CAAC5B,EAAP,CAAU,OAAV,EAAmBzC,EAAE,IAAI,KAAKpB,OAAL,EAAcoB,EAAd,EAAkB0C,KAAlB,CAAzB;AAEA,QAAI8B,OAAO,GAAG,CAAd;;AACA,UAAMC,IAAI,GAAGzE,EAAE,IAAI;AACjB,UAAIA,EAAJ,EACE,OAAO,KAAKpB,OAAL,EAAcoB,EAAd,EAAkB0C,KAAlB,CAAP;AAEF,UAAI,EAAE8B,OAAF,KAAc,CAAlB,EACEjH,EAAE,CAACmH,KAAH,CAASL,MAAM,CAACM,EAAhB,EAAoB/D,CAAC,IAAI,KAAK7B,MAAL,GAAzB;AACH,KAND;;AAQAsF,IAAAA,MAAM,CAAC5B,EAAP,CAAU,QAAV,EAAoB7B,CAAC,IAAI;AACvB;AACA;AACA;AACA,YAAMgE,GAAG,GAAGlC,KAAK,CAACmB,QAAlB;AACA,YAAMc,EAAE,GAAGN,MAAM,CAACM,EAAlB;;AAEA,UAAIjC,KAAK,CAACmC,KAAN,IAAe,CAAC,KAAK7C,OAAzB,EAAkC;AAChCwC,QAAAA,OAAO;AACP,cAAMM,KAAK,GAAGpC,KAAK,CAACoC,KAAN,IAAe,IAAIC,IAAJ,EAA7B;AACA,cAAMF,KAAK,GAAGnC,KAAK,CAACmC,KAApB;AACAtH,QAAAA,EAAE,CAACyH,OAAH,CAAWL,EAAX,EAAeG,KAAf,EAAsBD,KAAtB,EAA6B7E,EAAE,IAC7BA,EAAE,GAAGzC,EAAE,CAAC0H,MAAH,CAAUL,GAAV,EAAeE,KAAf,EAAsBD,KAAtB,EAA6BK,GAAG,IAAIT,IAAI,CAACS,GAAG,IAAIlF,EAAR,CAAxC,CAAH,GACAyE,IAAI,EAFR;AAGD;;AAED,UAAI,KAAKtF,OAAL,EAAcuD,KAAd,CAAJ,EAA0B;AACxB8B,QAAAA,OAAO;AACP,cAAMtD,GAAG,GAAG,KAAK9B,GAAL,EAAUsD,KAAV,CAAZ;AACA,cAAMvB,GAAG,GAAG,KAAK9B,GAAL,EAAUqD,KAAV,CAAZ;AACAnF,QAAAA,EAAE,CAAC4H,MAAH,CAAUR,EAAV,EAAczD,GAAd,EAAmBC,GAAnB,EAAwBnB,EAAE,IACxBA,EAAE,GAAGzC,EAAE,CAAC6H,KAAH,CAASR,GAAT,EAAc1D,GAAd,EAAmBC,GAAnB,EAAwB+D,GAAG,IAAIT,IAAI,CAACS,GAAG,IAAIlF,EAAR,CAAnC,CAAH,GACAyE,IAAI,EAFR;AAGD;;AAEDA,MAAAA,IAAI;AACL,KA1BD;AA4BA,UAAMY,EAAE,GAAG,KAAKxE,SAAL,GAAiB,KAAKA,SAAL,CAAe6B,KAAf,KAAyBA,KAA1C,GAAkDA,KAA7D;;AACA,QAAI2C,EAAE,KAAK3C,KAAX,EAAkB;AAChB2C,MAAAA,EAAE,CAAC5C,EAAH,CAAM,OAAN,EAAezC,EAAE,IAAI,KAAKpB,OAAL,EAAcoB,EAAd,EAAkB0C,KAAlB,CAArB;AACAA,MAAAA,KAAK,CAAC4C,IAAN,CAAWD,EAAX;AACD;;AACDA,IAAAA,EAAE,CAACC,IAAH,CAAQjB,MAAR;AACD;;AAED,GAACjG,SAAD,EAAasE,KAAb,EAAoB;AAClB,UAAMsB,IAAI,GAAGtB,KAAK,CAACsB,IAAN,GAAa,MAAb,IAAuB,KAAKzB,KAAzC;AACA,SAAK5D,KAAL,EAAY+D,KAAK,CAACmB,QAAlB,EAA4BG,IAA5B,EAAkChE,EAAE,IAAI;AACtC,UAAIA,EAAJ,EACE,OAAO,KAAKpB,OAAL,EAAcoB,EAAd,EAAkB0C,KAAlB,CAAP;AAEF,UAAI8B,OAAO,GAAG,CAAd;;AACA,YAAMC,IAAI,GAAG7D,CAAC,IAAI;AAChB,YAAI,EAAE4D,OAAF,KAAc,CAAlB,EAAqB;AACnB,eAAKzF,MAAL;AACA2D,UAAAA,KAAK,CAACoB,MAAN;AACD;AACF,OALD;;AAOA,UAAIpB,KAAK,CAACmC,KAAN,IAAe,CAAC,KAAK7C,OAAzB,EAAkC;AAChCwC,QAAAA,OAAO;AACPjH,QAAAA,EAAE,CAAC0H,MAAH,CAAUvC,KAAK,CAACmB,QAAhB,EAA0BnB,KAAK,CAACoC,KAAN,IAAe,IAAIC,IAAJ,EAAzC,EAAqDrC,KAAK,CAACmC,KAA3D,EAAkEJ,IAAlE;AACD;;AAED,UAAI,KAAKtF,OAAL,EAAcuD,KAAd,CAAJ,EAA0B;AACxB8B,QAAAA,OAAO;AACPjH,QAAAA,EAAE,CAAC6H,KAAH,CAAS1C,KAAK,CAACmB,QAAf,EAAyB,KAAKzE,GAAL,EAAUsD,KAAV,CAAzB,EAA2C,KAAKrD,GAAL,EAAUqD,KAAV,CAA3C,EAA6D+B,IAA7D;AACD;;AAEDA,MAAAA,IAAI;AACL,KAvBD;AAwBD;;AAED,GAACjG,WAAD,EAAekE,KAAf,EAAsB;AACpB,SAAKY,IAAL,CAAU,6BAA6BZ,KAAK,CAACO,IAA7C,EAAmDP,KAAnD;AACAA,IAAAA,KAAK,CAACoB,MAAN;AACD;;AAED,GAACxF,OAAD,EAAWoE,KAAX,EAAkB;AAChB,SAAKrE,IAAL,EAAWqE,KAAX,EAAkBA,KAAK,CAACS,QAAxB,EAAkC,SAAlC;AACD;;AAED,GAAC5E,QAAD,EAAYmE,KAAZ,EAAmB;AACjB,SAAKrE,IAAL,EAAWqE,KAAX,EAAkBjF,IAAI,CAAC0E,OAAL,CAAa,KAAKD,GAAlB,EAAuBQ,KAAK,CAACS,QAA7B,CAAlB,EAA0D,MAA1D;AACD;;AAED,GAACrE,IAAD,IAAU;AACR,SAAKD,OAAL;AACD;;AAED,GAACE,MAAD,IAAY;AACV,SAAKF,OAAL;AACA,SAAKI,UAAL;AACD;;AAED,GAACC,IAAD,EAAQwD,KAAR,EAAe;AACb,SAAK3D,MAAL;AACA2D,IAAAA,KAAK,CAACoB,MAAN;AACD,GA9TyB,CAgU1B;AACA;AACA;;;AACA,GAAC7F,UAAD,EAAcyE,KAAd,EAAqB6C,EAArB,EAAyB;AACvB,WAAO7C,KAAK,CAACO,IAAN,KAAe,MAAf,IACL,CAAC,KAAKtD,MADD,IAEL4F,EAAE,CAACC,MAAH,EAFK,IAGLD,EAAE,CAACE,KAAH,IAAY,CAHP,IAILhG,OAAO,CAACC,QAAR,KAAqB,OAJvB;AAKD,GAzUyB,CA2U1B;;;AACA,GAAC1B,OAAD,EAAW0E,KAAX,EAAkB;AAChB,SAAK5D,IAAL;AACA,SAAKH,KAAL,EAAYlB,IAAI,CAACiI,OAAL,CAAahD,KAAK,CAACmB,QAAnB,CAAZ,EAA0C,KAAKtB,KAA/C,EAAsDvC,EAAE,IAAI;AAC1D,UAAIA,EAAJ,EACE,OAAO,KAAKpB,OAAL,EAAcoB,EAAd,EAAkB0C,KAAlB,CAAP;AACFnF,MAAAA,EAAE,CAACoI,KAAH,CAASjD,KAAK,CAACmB,QAAf,EAAyB,CAAC7D,EAAD,EAAKuF,EAAL,KAAY;AACnC,YAAIA,EAAE,KAAK,KAAKxD,IAAL,IAAa,KAAKD,KAAL,IAAcyD,EAAE,CAACV,KAAH,GAAWnC,KAAK,CAACmC,KAAjD,CAAN,EACE,KAAK3F,IAAL,EAAWwD,KAAX,EADF,KAEK,IAAI1C,EAAE,IAAI,KAAK/B,UAAL,EAAiByE,KAAjB,EAAwB6C,EAAxB,CAAV,EACH,KAAKrH,MAAL,EAAa,IAAb,EAAmBwE,KAAnB,EADG,KAEA,IAAI6C,EAAE,CAACK,WAAH,EAAJ,EAAsB;AACzB,cAAIlD,KAAK,CAACO,IAAN,KAAe,WAAnB,EAAgC;AAC9B,gBAAI,CAACP,KAAK,CAACsB,IAAP,IAAe,CAACuB,EAAE,CAACvB,IAAH,GAAU,MAAX,MAAuBtB,KAAK,CAACsB,IAAhD,EACE,KAAK9F,MAAL,EAAa,IAAb,EAAmBwE,KAAnB,EADF,KAGEnF,EAAE,CAACsI,KAAH,CAASnD,KAAK,CAACmB,QAAf,EAAyBnB,KAAK,CAACsB,IAA/B,EAAqChE,EAAE,IAAI,KAAK9B,MAAL,EAAa8B,EAAb,EAAiB0C,KAAjB,CAA3C;AACH,WALD,MAMEnF,EAAE,CAACuI,KAAH,CAASpD,KAAK,CAACmB,QAAf,EAAyB7D,EAAE,IAAI,KAAK9B,MAAL,EAAa8B,EAAb,EAAiB0C,KAAjB,CAA/B;AACH,SARI,MASHnD,UAAU,CAACmD,KAAK,CAACmB,QAAP,EAAiB7D,EAAE,IAAI,KAAK9B,MAAL,EAAa8B,EAAb,EAAiB0C,KAAjB,CAAvB,CAAV;AACH,OAfD;AAgBD,KAnBD;AAoBD;;AAED,GAACxE,MAAD,EAAU8B,EAAV,EAAc0C,KAAd,EAAqB;AACnB,QAAI1C,EAAJ,EACE,OAAO,KAAKpB,OAAL,EAAcoB,EAAd,EAAkB0C,KAAlB,CAAP;;AAEF,YAAQA,KAAK,CAACO,IAAd;AACE,WAAK,MAAL;AACA,WAAK,SAAL;AACA,WAAK,gBAAL;AACE,eAAO,KAAK9E,IAAL,EAAWuE,KAAX,CAAP;;AAEF,WAAK,MAAL;AACE,eAAO,KAAKnE,QAAL,EAAemE,KAAf,CAAP;;AAEF,WAAK,cAAL;AACE,eAAO,KAAKpE,OAAL,EAAcoE,KAAd,CAAP;;AAEF,WAAK,WAAL;AACA,WAAK,YAAL;AACE,eAAO,KAAKtE,SAAL,EAAgBsE,KAAhB,CAAP;AAdJ;AAgBD;;AAED,GAACrE,IAAD,EAAQqE,KAAR,EAAeS,QAAf,EAAyB4C,IAAzB,EAA+B;AAC7B;AACAxI,IAAAA,EAAE,CAACwI,IAAD,CAAF,CAAS5C,QAAT,EAAmBT,KAAK,CAACmB,QAAzB,EAAmC7D,EAAE,IAAI;AACvC,UAAIA,EAAJ,EACE,OAAO,KAAKpB,OAAL,EAAcoB,EAAd,EAAkB0C,KAAlB,CAAP;AACF,WAAK3D,MAAL;AACA2D,MAAAA,KAAK,CAACoB,MAAN;AACD,KALD;AAMD;;AAlYyB;;AAqY5B,MAAMkC,UAAN,SAAyBxF,MAAzB,CAAgC;AAC9BC,EAAAA,WAAW,CAAEC,GAAF,EAAO;AAChB,UAAMA,GAAN;AACD;;AAED,GAAC1C,OAAD,EAAW0E,KAAX,EAAkB;AAChB,UAAM1C,EAAE,GAAG,KAAKrB,KAAL,EAAYlB,IAAI,CAACiI,OAAL,CAAahD,KAAK,CAACmB,QAAnB,CAAZ,EAA0C,KAAKtB,KAA/C,CAAX;AACA,QAAIvC,EAAJ,EACE,OAAO,KAAKpB,OAAL,EAAcoB,EAAd,EAAkB0C,KAAlB,CAAP;;AACF,QAAI;AACF,YAAM6C,EAAE,GAAGhI,EAAE,CAAC0I,SAAH,CAAavD,KAAK,CAACmB,QAAnB,CAAX;AACA,UAAI,KAAK9B,IAAL,IAAa,KAAKD,KAAL,IAAcyD,EAAE,CAACV,KAAH,GAAWnC,KAAK,CAACmC,KAAhD,EACE,OAAO,KAAK3F,IAAL,EAAWwD,KAAX,CAAP,CADF,KAEK,IAAI,KAAKzE,UAAL,EAAiByE,KAAjB,EAAwB6C,EAAxB,CAAJ,EACH,OAAO,KAAKrH,MAAL,EAAa,IAAb,EAAmBwE,KAAnB,CAAP,CADG,KAEA;AACH,YAAI;AACF,cAAI6C,EAAE,CAACK,WAAH,EAAJ,EAAsB;AACpB,gBAAIlD,KAAK,CAACO,IAAN,KAAe,WAAnB,EAAgC;AAC9B,kBAAIP,KAAK,CAACsB,IAAN,IAAc,CAACuB,EAAE,CAACvB,IAAH,GAAU,MAAX,MAAuBtB,KAAK,CAACsB,IAA/C,EACEzG,EAAE,CAAC2I,SAAH,CAAaxD,KAAK,CAACmB,QAAnB,EAA6BnB,KAAK,CAACsB,IAAnC;AACH,aAHD,MAIEzG,EAAE,CAAC4I,SAAH,CAAazD,KAAK,CAACmB,QAAnB;AACH,WAND,MAOE5D,cAAc,CAACyC,KAAK,CAACmB,QAAP,CAAd;;AACF,iBAAO,KAAK3F,MAAL,EAAa,IAAb,EAAmBwE,KAAnB,CAAP;AACD,SAVD,CAUE,OAAO1C,EAAP,EAAW;AACX,iBAAO,KAAKpB,OAAL,EAAcoB,EAAd,EAAkB0C,KAAlB,CAAP;AACD;AACF;AACF,KArBD,CAqBE,OAAO1C,EAAP,EAAW;AACX,aAAO,KAAK9B,MAAL,EAAa,IAAb,EAAmBwE,KAAnB,CAAP;AACD;AACF;;AAED,GAACvE,IAAD,EAAQuE,KAAR,EAAe;AACb,UAAMsB,IAAI,GAAGtB,KAAK,CAACsB,IAAN,GAAa,MAAb,IAAuB,KAAKxB,KAAzC;;AAEA,UAAM4D,IAAI,GAAGpG,EAAE,IAAI;AACjB,UAAI;AAAEzC,QAAAA,EAAE,CAAC8I,SAAH,CAAa1B,EAAb;AAAkB,OAAxB,CAAyB,OAAO/D,CAAP,EAAU,CAAE;;AACrC,UAAIZ,EAAJ,EACE,KAAKpB,OAAL,EAAcoB,EAAd,EAAkB0C,KAAlB;AACH,KAJD;;AAMA,QAAI2B,MAAJ;AACA,QAAIM,EAAJ;;AACA,QAAI;AACFA,MAAAA,EAAE,GAAGpH,EAAE,CAAC+I,QAAH,CAAY5D,KAAK,CAACmB,QAAlB,EAA4B,GAA5B,EAAiCG,IAAjC,CAAL;AACD,KAFD,CAEE,OAAOhE,EAAP,EAAW;AACX,aAAOoG,IAAI,CAACpG,EAAD,CAAX;AACD;;AACD,UAAMqF,EAAE,GAAG,KAAKxE,SAAL,GAAiB,KAAKA,SAAL,CAAe6B,KAAf,KAAyBA,KAA1C,GAAkDA,KAA7D;;AACA,QAAI2C,EAAE,KAAK3C,KAAX,EAAkB;AAChB2C,MAAAA,EAAE,CAAC5C,EAAH,CAAM,OAAN,EAAezC,EAAE,IAAI,KAAKpB,OAAL,EAAcoB,EAAd,EAAkB0C,KAAlB,CAArB;AACAA,MAAAA,KAAK,CAAC4C,IAAN,CAAWD,EAAX;AACD;;AAEDA,IAAAA,EAAE,CAAC5C,EAAH,CAAM,MAAN,EAAc8D,KAAK,IAAI;AACrB,UAAI;AACFhJ,QAAAA,EAAE,CAACiJ,SAAH,CAAa7B,EAAb,EAAiB4B,KAAjB,EAAwB,CAAxB,EAA2BA,KAAK,CAACzD,MAAjC;AACD,OAFD,CAEE,OAAO9C,EAAP,EAAW;AACXoG,QAAAA,IAAI,CAACpG,EAAD,CAAJ;AACD;AACF,KAND;AAQAqF,IAAAA,EAAE,CAAC5C,EAAH,CAAM,KAAN,EAAa7B,CAAC,IAAI;AAChB,UAAIZ,EAAE,GAAG,IAAT,CADgB,CAEhB;AACA;;AACA,UAAI0C,KAAK,CAACmC,KAAN,IAAe,CAAC,KAAK7C,OAAzB,EAAkC;AAChC,cAAM8C,KAAK,GAAGpC,KAAK,CAACoC,KAAN,IAAe,IAAIC,IAAJ,EAA7B;AACA,cAAMF,KAAK,GAAGnC,KAAK,CAACmC,KAApB;;AACA,YAAI;AACFtH,UAAAA,EAAE,CAACkJ,WAAH,CAAe9B,EAAf,EAAmBG,KAAnB,EAA0BD,KAA1B;AACD,SAFD,CAEE,OAAO6B,SAAP,EAAkB;AAClB,cAAI;AACFnJ,YAAAA,EAAE,CAACoJ,UAAH,CAAcjE,KAAK,CAACmB,QAApB,EAA8BiB,KAA9B,EAAqCD,KAArC;AACD,WAFD,CAEE,OAAO+B,QAAP,EAAiB;AACjB5G,YAAAA,EAAE,GAAG0G,SAAL;AACD;AACF;AACF;;AAED,UAAI,KAAKvH,OAAL,EAAcuD,KAAd,CAAJ,EAA0B;AACxB,cAAMxB,GAAG,GAAG,KAAK9B,GAAL,EAAUsD,KAAV,CAAZ;AACA,cAAMvB,GAAG,GAAG,KAAK9B,GAAL,EAAUqD,KAAV,CAAZ;;AAEA,YAAI;AACFnF,UAAAA,EAAE,CAACsJ,UAAH,CAAclC,EAAd,EAAkBzD,GAAlB,EAAuBC,GAAvB;AACD,SAFD,CAEE,OAAO2F,QAAP,EAAiB;AACjB,cAAI;AACFvJ,YAAAA,EAAE,CAACwJ,SAAH,CAAarE,KAAK,CAACmB,QAAnB,EAA6B3C,GAA7B,EAAkCC,GAAlC;AACD,WAFD,CAEE,OAAO6F,OAAP,EAAgB;AAChBhH,YAAAA,EAAE,GAAGA,EAAE,IAAI8G,QAAX;AACD;AACF;AACF;;AAEDV,MAAAA,IAAI,CAACpG,EAAD,CAAJ;AACD,KAlCD;AAmCD;;AAED,GAAC5B,SAAD,EAAasE,KAAb,EAAoB;AAClB,UAAMsB,IAAI,GAAGtB,KAAK,CAACsB,IAAN,GAAa,MAAb,IAAuB,KAAKzB,KAAzC;AACA,UAAMvC,EAAE,GAAG,KAAKrB,KAAL,EAAY+D,KAAK,CAACmB,QAAlB,EAA4BG,IAA5B,CAAX;AACA,QAAIhE,EAAJ,EACE,OAAO,KAAKpB,OAAL,EAAcoB,EAAd,EAAkB0C,KAAlB,CAAP;;AACF,QAAIA,KAAK,CAACmC,KAAN,IAAe,CAAC,KAAK7C,OAAzB,EAAkC;AAChC,UAAI;AACFzE,QAAAA,EAAE,CAACoJ,UAAH,CAAcjE,KAAK,CAACmB,QAApB,EAA8BnB,KAAK,CAACoC,KAAN,IAAe,IAAIC,IAAJ,EAA7C,EAAyDrC,KAAK,CAACmC,KAA/D;AACD,OAFD,CAEE,OAAO7E,EAAP,EAAW,CAAE;AAChB;;AACD,QAAI,KAAKb,OAAL,EAAcuD,KAAd,CAAJ,EAA0B;AACxB,UAAI;AACFnF,QAAAA,EAAE,CAACwJ,SAAH,CAAarE,KAAK,CAACmB,QAAnB,EAA6B,KAAKzE,GAAL,EAAUsD,KAAV,CAA7B,EAA+C,KAAKrD,GAAL,EAAUqD,KAAV,CAA/C;AACD,OAFD,CAEE,OAAO1C,EAAP,EAAW,CAAE;AAChB;;AACD0C,IAAAA,KAAK,CAACoB,MAAN;AACD;;AAED,GAACnF,KAAD,EAASuF,GAAT,EAAcF,IAAd,EAAoB;AAClB,QAAI;AACF,aAAOtG,KAAK,CAACE,IAAN,CAAWsG,GAAX,EAAgB;AACrBhD,QAAAA,GAAG,EAAE,KAAKA,GADW;AAErBC,QAAAA,GAAG,EAAE,KAAKA,GAFW;AAGrBM,QAAAA,UAAU,EAAE,KAAKA,UAHI;AAIrBC,QAAAA,UAAU,EAAE,KAAKA,UAJI;AAKrBY,QAAAA,KAAK,EAAE,KAAKD,YALS;AAMrB8B,QAAAA,QAAQ,EAAE,KAAKlC,aANM;AAOrBtC,QAAAA,MAAM,EAAE,KAAKA,MAPQ;AAQrByE,QAAAA,KAAK,EAAE,KAAKpD,QARS;AASrBkB,QAAAA,GAAG,EAAE,KAAKA,GATW;AAUrB8B,QAAAA,IAAI,EAAEA;AAVe,OAAhB,CAAP;AAYD,KAbD,CAaE,OAAOhE,EAAP,EAAW;AACX,aAAOA,EAAP;AACD;AACF;;AAED,GAAC3B,IAAD,EAAQqE,KAAR,EAAeS,QAAf,EAAyB4C,IAAzB,EAA+B;AAC7B,QAAI;AACFxI,MAAAA,EAAE,CAACwI,IAAI,GAAG,MAAR,CAAF,CAAkB5C,QAAlB,EAA4BT,KAAK,CAACmB,QAAlC;AACAnB,MAAAA,KAAK,CAACoB,MAAN;AACD,KAHD,CAGE,OAAO9D,EAAP,EAAW;AACX,aAAO,KAAKpB,OAAL,EAAcoB,EAAd,EAAkB0C,KAAlB,CAAP;AACD;AACF;;AAlJ6B;;AAqJhClC,MAAM,CAACyG,IAAP,GAAcjB,UAAd;AACAkB,MAAM,CAACC,OAAP,GAAiB3G,MAAjB","sourcesContent":["'use strict'\n\nconst assert = require('assert')\nconst EE = require('events').EventEmitter\nconst Parser = require('./parse.js')\nconst fs = require('fs')\nconst fsm = require('fs-minipass')\nconst path = require('path')\nconst mkdir = require('./mkdir.js')\nconst mkdirSync = mkdir.sync\nconst wc = require('./winchars.js')\n\nconst ONENTRY = Symbol('onEntry')\nconst CHECKFS = Symbol('checkFs')\nconst ISREUSABLE = Symbol('isReusable')\nconst MAKEFS = Symbol('makeFs')\nconst FILE = Symbol('file')\nconst DIRECTORY = Symbol('directory')\nconst LINK = Symbol('link')\nconst SYMLINK = Symbol('symlink')\nconst HARDLINK = Symbol('hardlink')\nconst UNSUPPORTED = Symbol('unsupported')\nconst UNKNOWN = Symbol('unknown')\nconst CHECKPATH = Symbol('checkPath')\nconst MKDIR = Symbol('mkdir')\nconst ONERROR = Symbol('onError')\nconst PENDING = Symbol('pending')\nconst PEND = Symbol('pend')\nconst UNPEND = Symbol('unpend')\nconst ENDED = Symbol('ended')\nconst MAYBECLOSE = Symbol('maybeClose')\nconst SKIP = Symbol('skip')\nconst DOCHOWN = Symbol('doChown')\nconst UID = Symbol('uid')\nconst GID = Symbol('gid')\nconst crypto = require('crypto')\n\n// Unlinks on Windows are not atomic.\n//\n// This means that if you have a file entry, followed by another\n// file entry with an identical name, and you cannot re-use the file\n// (because it's a hardlink, or because unlink:true is set, or it's\n// Windows, which does not have useful nlink values), then the unlink\n// will be committed to the disk AFTER the new file has been written\n// over the old one, deleting the new file.\n//\n// To work around this, on Windows systems, we rename the file and then\n// delete the renamed file.  It's a sloppy kludge, but frankly, I do not\n// know of a better way to do this, given windows' non-atomic unlink\n// semantics.\n//\n// See: https://github.com/npm/node-tar/issues/183\n/* istanbul ignore next */\nconst unlinkFile = (path, cb) => {\n  if (process.platform !== 'win32')\n    return fs.unlink(path, cb)\n\n  const name = path + '.DELETE.' + crypto.randomBytes(16).toString('hex')\n  fs.rename(path, name, er => {\n    if (er)\n      return cb(er)\n    fs.unlink(name, cb)\n  })\n}\n\n/* istanbul ignore next */\nconst unlinkFileSync = path => {\n  if (process.platform !== 'win32')\n    return fs.unlinkSync(path)\n\n  const name = path + '.DELETE.' + crypto.randomBytes(16).toString('hex')\n  fs.renameSync(path, name)\n  fs.unlinkSync(name)\n}\n\n// this.gid, entry.gid, this.processUid\nconst uint32 = (a, b, c) =>\n  a === a >>> 0 ? a\n  : b === b >>> 0 ? b\n  : c\n\nclass Unpack extends Parser {\n  constructor (opt) {\n    if (!opt)\n      opt = {}\n\n    opt.ondone = _ => {\n      this[ENDED] = true\n      this[MAYBECLOSE]()\n    }\n\n    super(opt)\n\n    this.transform = typeof opt.transform === 'function' ? opt.transform : null\n\n    this.writable = true\n    this.readable = false\n\n    this[PENDING] = 0\n    this[ENDED] = false\n\n    this.dirCache = opt.dirCache || new Map()\n\n    if (typeof opt.uid === 'number' || typeof opt.gid === 'number') {\n      // need both or neither\n      if (typeof opt.uid !== 'number' || typeof opt.gid !== 'number')\n        throw new TypeError('cannot set owner without number uid and gid')\n      if (opt.preserveOwner)\n        throw new TypeError(\n          'cannot preserve owner in archive and also set owner explicitly')\n      this.uid = opt.uid\n      this.gid = opt.gid\n      this.setOwner = true\n    } else {\n      this.uid = null\n      this.gid = null\n      this.setOwner = false\n    }\n\n    // default true for root\n    if (opt.preserveOwner === undefined && typeof opt.uid !== 'number')\n      this.preserveOwner = process.getuid && process.getuid() === 0\n    else\n      this.preserveOwner = !!opt.preserveOwner\n\n    this.processUid = (this.preserveOwner || this.setOwner) && process.getuid ?\n      process.getuid() : null\n    this.processGid = (this.preserveOwner || this.setOwner) && process.getgid ?\n      process.getgid() : null\n\n    // mostly just for testing, but useful in some cases.\n    // Forcibly trigger a chown on every entry, no matter what\n    this.forceChown = opt.forceChown === true\n\n    // turn ><?| in filenames into 0xf000-higher encoded forms\n    this.win32 = !!opt.win32 || process.platform === 'win32'\n\n    // do not unpack over files that are newer than what's in the archive\n    this.newer = !!opt.newer\n\n    // do not unpack over ANY files\n    this.keep = !!opt.keep\n\n    // do not set mtime/atime of extracted entries\n    this.noMtime = !!opt.noMtime\n\n    // allow .., absolute path entries, and unpacking through symlinks\n    // without this, warn and skip .., relativize absolutes, and error\n    // on symlinks in extraction path\n    this.preservePaths = !!opt.preservePaths\n\n    // unlink files and links before writing. This breaks existing hard\n    // links, and removes symlink directories rather than erroring\n    this.unlink = !!opt.unlink\n\n    this.cwd = path.resolve(opt.cwd || process.cwd())\n    this.strip = +opt.strip || 0\n    this.processUmask = process.umask()\n    this.umask = typeof opt.umask === 'number' ? opt.umask : this.processUmask\n    // default mode for dirs created as parents\n    this.dmode = opt.dmode || (0o0777 & (~this.umask))\n    this.fmode = opt.fmode || (0o0666 & (~this.umask))\n    this.on('entry', entry => this[ONENTRY](entry))\n  }\n\n  [MAYBECLOSE] () {\n    if (this[ENDED] && this[PENDING] === 0) {\n      this.emit('prefinish')\n      this.emit('finish')\n      this.emit('end')\n      this.emit('close')\n    }\n  }\n\n  [CHECKPATH] (entry) {\n    if (this.strip) {\n      const parts = entry.path.split(/\\/|\\\\/)\n      if (parts.length < this.strip)\n        return false\n      entry.path = parts.slice(this.strip).join('/')\n\n      if (entry.type === 'Link') {\n        const linkparts = entry.linkpath.split(/\\/|\\\\/)\n        if (linkparts.length >= this.strip)\n          entry.linkpath = linkparts.slice(this.strip).join('/')\n      }\n    }\n\n    if (!this.preservePaths) {\n      const p = entry.path\n      if (p.match(/(^|\\/|\\\\)\\.\\.(\\\\|\\/|$)/)) {\n        this.warn('path contains \\'..\\'', p)\n        return false\n      }\n\n      // absolutes on posix are also absolutes on win32\n      // so we only need to test this one to get both\n      if (path.win32.isAbsolute(p)) {\n        const parsed = path.win32.parse(p)\n        this.warn('stripping ' + parsed.root + ' from absolute path', p)\n        entry.path = p.substr(parsed.root.length)\n      }\n    }\n\n    // only encode : chars that aren't drive letter indicators\n    if (this.win32) {\n      const parsed = path.win32.parse(entry.path)\n      entry.path = parsed.root === '' ? wc.encode(entry.path)\n        : parsed.root + wc.encode(entry.path.substr(parsed.root.length))\n    }\n\n    if (path.isAbsolute(entry.path))\n      entry.absolute = entry.path\n    else\n      entry.absolute = path.resolve(this.cwd, entry.path)\n\n    return true\n  }\n\n  [ONENTRY] (entry) {\n    if (!this[CHECKPATH](entry))\n      return entry.resume()\n\n    assert.equal(typeof entry.absolute, 'string')\n\n    switch (entry.type) {\n      case 'Directory':\n      case 'GNUDumpDir':\n        if (entry.mode)\n          entry.mode = entry.mode | 0o700\n\n      case 'File':\n      case 'OldFile':\n      case 'ContiguousFile':\n      case 'Link':\n      case 'SymbolicLink':\n        return this[CHECKFS](entry)\n\n      case 'CharacterDevice':\n      case 'BlockDevice':\n      case 'FIFO':\n        return this[UNSUPPORTED](entry)\n    }\n  }\n\n  [ONERROR] (er, entry) {\n    // Cwd has to exist, or else nothing works. That's serious.\n    // Other errors are warnings, which raise the error in strict\n    // mode, but otherwise continue on.\n    if (er.name === 'CwdError')\n      this.emit('error', er)\n    else {\n      this.warn(er.message, er)\n      this[UNPEND]()\n      entry.resume()\n    }\n  }\n\n  [MKDIR] (dir, mode, cb) {\n    mkdir(dir, {\n      uid: this.uid,\n      gid: this.gid,\n      processUid: this.processUid,\n      processGid: this.processGid,\n      umask: this.processUmask,\n      preserve: this.preservePaths,\n      unlink: this.unlink,\n      cache: this.dirCache,\n      cwd: this.cwd,\n      mode: mode\n    }, cb)\n  }\n\n  [DOCHOWN] (entry) {\n    // in preserve owner mode, chown if the entry doesn't match process\n    // in set owner mode, chown if setting doesn't match process\n    return this.forceChown ||\n      this.preserveOwner &&\n      ( typeof entry.uid === 'number' && entry.uid !== this.processUid ||\n        typeof entry.gid === 'number' && entry.gid !== this.processGid )\n      ||\n      ( typeof this.uid === 'number' && this.uid !== this.processUid ||\n        typeof this.gid === 'number' && this.gid !== this.processGid )\n  }\n\n  [UID] (entry) {\n    return uint32(this.uid, entry.uid, this.processUid)\n  }\n\n  [GID] (entry) {\n    return uint32(this.gid, entry.gid, this.processGid)\n  }\n\n  [FILE] (entry) {\n    const mode = entry.mode & 0o7777 || this.fmode\n    const stream = new fsm.WriteStream(entry.absolute, {\n      mode: mode,\n      autoClose: false\n    })\n    stream.on('error', er => this[ONERROR](er, entry))\n\n    let actions = 1\n    const done = er => {\n      if (er)\n        return this[ONERROR](er, entry)\n\n      if (--actions === 0)\n        fs.close(stream.fd, _ => this[UNPEND]())\n    }\n\n    stream.on('finish', _ => {\n      // if futimes fails, try utimes\n      // if utimes fails, fail with the original error\n      // same for fchown/chown\n      const abs = entry.absolute\n      const fd = stream.fd\n\n      if (entry.mtime && !this.noMtime) {\n        actions++\n        const atime = entry.atime || new Date()\n        const mtime = entry.mtime\n        fs.futimes(fd, atime, mtime, er =>\n          er ? fs.utimes(abs, atime, mtime, er2 => done(er2 && er))\n          : done())\n      }\n\n      if (this[DOCHOWN](entry)) {\n        actions++\n        const uid = this[UID](entry)\n        const gid = this[GID](entry)\n        fs.fchown(fd, uid, gid, er =>\n          er ? fs.chown(abs, uid, gid, er2 => done(er2 && er))\n          : done())\n      }\n\n      done()\n    })\n\n    const tx = this.transform ? this.transform(entry) || entry : entry\n    if (tx !== entry) {\n      tx.on('error', er => this[ONERROR](er, entry))\n      entry.pipe(tx)\n    }\n    tx.pipe(stream)\n  }\n\n  [DIRECTORY] (entry) {\n    const mode = entry.mode & 0o7777 || this.dmode\n    this[MKDIR](entry.absolute, mode, er => {\n      if (er)\n        return this[ONERROR](er, entry)\n\n      let actions = 1\n      const done = _ => {\n        if (--actions === 0) {\n          this[UNPEND]()\n          entry.resume()\n        }\n      }\n\n      if (entry.mtime && !this.noMtime) {\n        actions++\n        fs.utimes(entry.absolute, entry.atime || new Date(), entry.mtime, done)\n      }\n\n      if (this[DOCHOWN](entry)) {\n        actions++\n        fs.chown(entry.absolute, this[UID](entry), this[GID](entry), done)\n      }\n\n      done()\n    })\n  }\n\n  [UNSUPPORTED] (entry) {\n    this.warn('unsupported entry type: ' + entry.type, entry)\n    entry.resume()\n  }\n\n  [SYMLINK] (entry) {\n    this[LINK](entry, entry.linkpath, 'symlink')\n  }\n\n  [HARDLINK] (entry) {\n    this[LINK](entry, path.resolve(this.cwd, entry.linkpath), 'link')\n  }\n\n  [PEND] () {\n    this[PENDING]++\n  }\n\n  [UNPEND] () {\n    this[PENDING]--\n    this[MAYBECLOSE]()\n  }\n\n  [SKIP] (entry) {\n    this[UNPEND]()\n    entry.resume()\n  }\n\n  // Check if we can reuse an existing filesystem entry safely and\n  // overwrite it, rather than unlinking and recreating\n  // Windows doesn't report a useful nlink, so we just never reuse entries\n  [ISREUSABLE] (entry, st) {\n    return entry.type === 'File' &&\n      !this.unlink &&\n      st.isFile() &&\n      st.nlink <= 1 &&\n      process.platform !== 'win32'\n  }\n\n  // check if a thing is there, and if so, try to clobber it\n  [CHECKFS] (entry) {\n    this[PEND]()\n    this[MKDIR](path.dirname(entry.absolute), this.dmode, er => {\n      if (er)\n        return this[ONERROR](er, entry)\n      fs.lstat(entry.absolute, (er, st) => {\n        if (st && (this.keep || this.newer && st.mtime > entry.mtime))\n          this[SKIP](entry)\n        else if (er || this[ISREUSABLE](entry, st))\n          this[MAKEFS](null, entry)\n        else if (st.isDirectory()) {\n          if (entry.type === 'Directory') {\n            if (!entry.mode || (st.mode & 0o7777) === entry.mode)\n              this[MAKEFS](null, entry)\n            else\n              fs.chmod(entry.absolute, entry.mode, er => this[MAKEFS](er, entry))\n          } else\n            fs.rmdir(entry.absolute, er => this[MAKEFS](er, entry))\n        } else\n          unlinkFile(entry.absolute, er => this[MAKEFS](er, entry))\n      })\n    })\n  }\n\n  [MAKEFS] (er, entry) {\n    if (er)\n      return this[ONERROR](er, entry)\n\n    switch (entry.type) {\n      case 'File':\n      case 'OldFile':\n      case 'ContiguousFile':\n        return this[FILE](entry)\n\n      case 'Link':\n        return this[HARDLINK](entry)\n\n      case 'SymbolicLink':\n        return this[SYMLINK](entry)\n\n      case 'Directory':\n      case 'GNUDumpDir':\n        return this[DIRECTORY](entry)\n    }\n  }\n\n  [LINK] (entry, linkpath, link) {\n    // XXX: get the type ('file' or 'dir') for windows\n    fs[link](linkpath, entry.absolute, er => {\n      if (er)\n        return this[ONERROR](er, entry)\n      this[UNPEND]()\n      entry.resume()\n    })\n  }\n}\n\nclass UnpackSync extends Unpack {\n  constructor (opt) {\n    super(opt)\n  }\n\n  [CHECKFS] (entry) {\n    const er = this[MKDIR](path.dirname(entry.absolute), this.dmode)\n    if (er)\n      return this[ONERROR](er, entry)\n    try {\n      const st = fs.lstatSync(entry.absolute)\n      if (this.keep || this.newer && st.mtime > entry.mtime)\n        return this[SKIP](entry)\n      else if (this[ISREUSABLE](entry, st))\n        return this[MAKEFS](null, entry)\n      else {\n        try {\n          if (st.isDirectory()) {\n            if (entry.type === 'Directory') {\n              if (entry.mode && (st.mode & 0o7777) !== entry.mode)\n                fs.chmodSync(entry.absolute, entry.mode)\n            } else\n              fs.rmdirSync(entry.absolute)\n          } else\n            unlinkFileSync(entry.absolute)\n          return this[MAKEFS](null, entry)\n        } catch (er) {\n          return this[ONERROR](er, entry)\n        }\n      }\n    } catch (er) {\n      return this[MAKEFS](null, entry)\n    }\n  }\n\n  [FILE] (entry) {\n    const mode = entry.mode & 0o7777 || this.fmode\n\n    const oner = er => {\n      try { fs.closeSync(fd) } catch (_) {}\n      if (er)\n        this[ONERROR](er, entry)\n    }\n\n    let stream\n    let fd\n    try {\n      fd = fs.openSync(entry.absolute, 'w', mode)\n    } catch (er) {\n      return oner(er)\n    }\n    const tx = this.transform ? this.transform(entry) || entry : entry\n    if (tx !== entry) {\n      tx.on('error', er => this[ONERROR](er, entry))\n      entry.pipe(tx)\n    }\n\n    tx.on('data', chunk => {\n      try {\n        fs.writeSync(fd, chunk, 0, chunk.length)\n      } catch (er) {\n        oner(er)\n      }\n    })\n\n    tx.on('end', _ => {\n      let er = null\n      // try both, falling futimes back to utimes\n      // if either fails, handle the first error\n      if (entry.mtime && !this.noMtime) {\n        const atime = entry.atime || new Date()\n        const mtime = entry.mtime\n        try {\n          fs.futimesSync(fd, atime, mtime)\n        } catch (futimeser) {\n          try {\n            fs.utimesSync(entry.absolute, atime, mtime)\n          } catch (utimeser) {\n            er = futimeser\n          }\n        }\n      }\n\n      if (this[DOCHOWN](entry)) {\n        const uid = this[UID](entry)\n        const gid = this[GID](entry)\n\n        try {\n          fs.fchownSync(fd, uid, gid)\n        } catch (fchowner) {\n          try {\n            fs.chownSync(entry.absolute, uid, gid)\n          } catch (chowner) {\n            er = er || fchowner\n          }\n        }\n      }\n\n      oner(er)\n    })\n  }\n\n  [DIRECTORY] (entry) {\n    const mode = entry.mode & 0o7777 || this.dmode\n    const er = this[MKDIR](entry.absolute, mode)\n    if (er)\n      return this[ONERROR](er, entry)\n    if (entry.mtime && !this.noMtime) {\n      try {\n        fs.utimesSync(entry.absolute, entry.atime || new Date(), entry.mtime)\n      } catch (er) {}\n    }\n    if (this[DOCHOWN](entry)) {\n      try {\n        fs.chownSync(entry.absolute, this[UID](entry), this[GID](entry))\n      } catch (er) {}\n    }\n    entry.resume()\n  }\n\n  [MKDIR] (dir, mode) {\n    try {\n      return mkdir.sync(dir, {\n        uid: this.uid,\n        gid: this.gid,\n        processUid: this.processUid,\n        processGid: this.processGid,\n        umask: this.processUmask,\n        preserve: this.preservePaths,\n        unlink: this.unlink,\n        cache: this.dirCache,\n        cwd: this.cwd,\n        mode: mode\n      })\n    } catch (er) {\n      return er\n    }\n  }\n\n  [LINK] (entry, linkpath, link) {\n    try {\n      fs[link + 'Sync'](linkpath, entry.absolute)\n      entry.resume()\n    } catch (er) {\n      return this[ONERROR](er, entry)\n    }\n  }\n}\n\nUnpack.Sync = UnpackSync\nmodule.exports = Unpack\n"]},"metadata":{},"sourceType":"script"}