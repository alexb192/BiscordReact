{"ast":null,"code":"'use strict'; // wrapper around mkdirp for tar's needs.\n// TODO: This should probably be a class, not functionally\n// passing around state in a gazillion args.\n\nconst mkdirp = require('mkdirp');\n\nconst fs = require('fs');\n\nconst path = require('path');\n\nconst chownr = require('chownr');\n\nclass SymlinkError extends Error {\n  constructor(symlink, path) {\n    super('Cannot extract through symbolic link');\n    this.path = path;\n    this.symlink = symlink;\n  }\n\n  get name() {\n    return 'SylinkError';\n  }\n\n}\n\nclass CwdError extends Error {\n  constructor(path, code) {\n    super(code + ': Cannot cd into \\'' + path + '\\'');\n    this.path = path;\n    this.code = code;\n  }\n\n  get name() {\n    return 'CwdError';\n  }\n\n}\n\nconst mkdir = module.exports = (dir, opt, cb) => {\n  // if there's any overlap between mask and mode,\n  // then we'll need an explicit chmod\n  const umask = opt.umask;\n  const mode = opt.mode | 0o0700;\n  const needChmod = (mode & umask) !== 0;\n  const uid = opt.uid;\n  const gid = opt.gid;\n  const doChown = typeof uid === 'number' && typeof gid === 'number' && (uid !== opt.processUid || gid !== opt.processGid);\n  const preserve = opt.preserve;\n  const unlink = opt.unlink;\n  const cache = opt.cache;\n  const cwd = opt.cwd;\n\n  const done = (er, created) => {\n    if (er) cb(er);else {\n      cache.set(dir, true);\n      if (created && doChown) chownr(created, uid, gid, er => done(er));else if (needChmod) fs.chmod(dir, mode, cb);else cb();\n    }\n  };\n\n  if (cache && cache.get(dir) === true) return done();\n  if (dir === cwd) return fs.stat(dir, (er, st) => {\n    if (er || !st.isDirectory()) er = new CwdError(dir, er && er.code || 'ENOTDIR');\n    done(er);\n  });\n  if (preserve) return mkdirp(dir, mode, done);\n  const sub = path.relative(cwd, dir);\n  const parts = sub.split(/\\/|\\\\/);\n  mkdir_(cwd, parts, mode, cache, unlink, cwd, null, done);\n};\n\nconst mkdir_ = (base, parts, mode, cache, unlink, cwd, created, cb) => {\n  if (!parts.length) return cb(null, created);\n  const p = parts.shift();\n  const part = base + '/' + p;\n  if (cache.get(part)) return mkdir_(part, parts, mode, cache, unlink, cwd, created, cb);\n  fs.mkdir(part, mode, onmkdir(part, parts, mode, cache, unlink, cwd, created, cb));\n};\n\nconst onmkdir = (part, parts, mode, cache, unlink, cwd, created, cb) => er => {\n  if (er) {\n    if (er.path && path.dirname(er.path) === cwd && (er.code === 'ENOTDIR' || er.code === 'ENOENT')) return cb(new CwdError(cwd, er.code));\n    fs.lstat(part, (statEr, st) => {\n      if (statEr) cb(statEr);else if (st.isDirectory()) mkdir_(part, parts, mode, cache, unlink, cwd, created, cb);else if (unlink) fs.unlink(part, er => {\n        if (er) return cb(er);\n        fs.mkdir(part, mode, onmkdir(part, parts, mode, cache, unlink, cwd, created, cb));\n      });else if (st.isSymbolicLink()) return cb(new SymlinkError(part, part + '/' + parts.join('/')));else cb(er);\n    });\n  } else {\n    created = created || part;\n    mkdir_(part, parts, mode, cache, unlink, cwd, created, cb);\n  }\n};\n\nconst mkdirSync = module.exports.sync = (dir, opt) => {\n  // if there's any overlap between mask and mode,\n  // then we'll need an explicit chmod\n  const umask = opt.umask;\n  const mode = opt.mode | 0o0700;\n  const needChmod = (mode & umask) !== 0;\n  const uid = opt.uid;\n  const gid = opt.gid;\n  const doChown = typeof uid === 'number' && typeof gid === 'number' && (uid !== opt.processUid || gid !== opt.processGid);\n  const preserve = opt.preserve;\n  const unlink = opt.unlink;\n  const cache = opt.cache;\n  const cwd = opt.cwd;\n\n  const done = created => {\n    cache.set(dir, true);\n    if (created && doChown) chownr.sync(created, uid, gid);\n    if (needChmod) fs.chmodSync(dir, mode);\n  };\n\n  if (cache && cache.get(dir) === true) return done();\n\n  if (dir === cwd) {\n    let ok = false;\n    let code = 'ENOTDIR';\n\n    try {\n      ok = fs.statSync(dir).isDirectory();\n    } catch (er) {\n      code = er.code;\n    } finally {\n      if (!ok) throw new CwdError(dir, code);\n    }\n\n    done();\n    return;\n  }\n\n  if (preserve) return done(mkdirp.sync(dir, mode));\n  const sub = path.relative(cwd, dir);\n  const parts = sub.split(/\\/|\\\\/);\n  let created = null;\n\n  for (let p = parts.shift(), part = cwd; p && (part += '/' + p); p = parts.shift()) {\n    if (cache.get(part)) continue;\n\n    try {\n      fs.mkdirSync(part, mode);\n      created = created || part;\n      cache.set(part, true);\n    } catch (er) {\n      if (er.path && path.dirname(er.path) === cwd && (er.code === 'ENOTDIR' || er.code === 'ENOENT')) return new CwdError(cwd, er.code);\n      const st = fs.lstatSync(part);\n\n      if (st.isDirectory()) {\n        cache.set(part, true);\n        continue;\n      } else if (unlink) {\n        fs.unlinkSync(part);\n        fs.mkdirSync(part, mode);\n        created = created || part;\n        cache.set(part, true);\n        continue;\n      } else if (st.isSymbolicLink()) return new SymlinkError(part, part + '/' + parts.join('/'));\n    }\n  }\n\n  return done(created);\n};","map":{"version":3,"sources":["/home/n/React/loginpagedemo/frontend/node_modules/tar/lib/mkdir.js"],"names":["mkdirp","require","fs","path","chownr","SymlinkError","Error","constructor","symlink","name","CwdError","code","mkdir","module","exports","dir","opt","cb","umask","mode","needChmod","uid","gid","doChown","processUid","processGid","preserve","unlink","cache","cwd","done","er","created","set","chmod","get","stat","st","isDirectory","sub","relative","parts","split","mkdir_","base","length","p","shift","part","onmkdir","dirname","lstat","statEr","isSymbolicLink","join","mkdirSync","sync","chmodSync","ok","statSync","lstatSync","unlinkSync"],"mappings":"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","sourcesContent":["'use strict'\n// wrapper around mkdirp for tar's needs.\n\n// TODO: This should probably be a class, not functionally\n// passing around state in a gazillion args.\n\nconst mkdirp = require('mkdirp')\nconst fs = require('fs')\nconst path = require('path')\nconst chownr = require('chownr')\n\nclass SymlinkError extends Error {\n  constructor (symlink, path) {\n    super('Cannot extract through symbolic link')\n    this.path = path\n    this.symlink = symlink\n  }\n\n  get name () {\n    return 'SylinkError'\n  }\n}\n\nclass CwdError extends Error {\n  constructor (path, code) {\n    super(code + ': Cannot cd into \\'' + path + '\\'')\n    this.path = path\n    this.code = code\n  }\n\n  get name () {\n    return 'CwdError'\n  }\n}\n\nconst mkdir = module.exports = (dir, opt, cb) => {\n  // if there's any overlap between mask and mode,\n  // then we'll need an explicit chmod\n  const umask = opt.umask\n  const mode = opt.mode | 0o0700\n  const needChmod = (mode & umask) !== 0\n\n  const uid = opt.uid\n  const gid = opt.gid\n  const doChown = typeof uid === 'number' &&\n    typeof gid === 'number' &&\n    ( uid !== opt.processUid || gid !== opt.processGid )\n\n  const preserve = opt.preserve\n  const unlink = opt.unlink\n  const cache = opt.cache\n  const cwd = opt.cwd\n\n  const done = (er, created) => {\n    if (er)\n      cb(er)\n    else {\n      cache.set(dir, true)\n      if (created && doChown)\n        chownr(created, uid, gid, er => done(er))\n      else if (needChmod)\n        fs.chmod(dir, mode, cb)\n      else\n        cb()\n    }\n  }\n\n  if (cache && cache.get(dir) === true)\n    return done()\n\n  if (dir === cwd)\n    return fs.stat(dir, (er, st) => {\n      if (er || !st.isDirectory())\n        er = new CwdError(dir, er && er.code || 'ENOTDIR')\n      done(er)\n    })\n\n  if (preserve)\n    return mkdirp(dir, mode, done)\n\n  const sub = path.relative(cwd, dir)\n  const parts = sub.split(/\\/|\\\\/)\n  mkdir_(cwd, parts, mode, cache, unlink, cwd, null, done)\n}\n\nconst mkdir_ = (base, parts, mode, cache, unlink, cwd, created, cb) => {\n  if (!parts.length)\n    return cb(null, created)\n  const p = parts.shift()\n  const part = base + '/' + p\n  if (cache.get(part))\n    return mkdir_(part, parts, mode, cache, unlink, cwd, created, cb)\n  fs.mkdir(part, mode, onmkdir(part, parts, mode, cache, unlink, cwd, created, cb))\n}\n\nconst onmkdir = (part, parts, mode, cache, unlink, cwd, created, cb) => er => {\n  if (er) {\n    if (er.path && path.dirname(er.path) === cwd &&\n        (er.code === 'ENOTDIR' || er.code === 'ENOENT'))\n      return cb(new CwdError(cwd, er.code))\n\n    fs.lstat(part, (statEr, st) => {\n      if (statEr)\n        cb(statEr)\n      else if (st.isDirectory())\n        mkdir_(part, parts, mode, cache, unlink, cwd, created, cb)\n      else if (unlink)\n        fs.unlink(part, er => {\n          if (er)\n            return cb(er)\n          fs.mkdir(part, mode, onmkdir(part, parts, mode, cache, unlink, cwd, created, cb))\n        })\n      else if (st.isSymbolicLink())\n        return cb(new SymlinkError(part, part + '/' + parts.join('/')))\n      else\n        cb(er)\n    })\n  } else {\n    created = created || part\n    mkdir_(part, parts, mode, cache, unlink, cwd, created, cb)\n  }\n}\n\nconst mkdirSync = module.exports.sync = (dir, opt) => {\n  // if there's any overlap between mask and mode,\n  // then we'll need an explicit chmod\n  const umask = opt.umask\n  const mode = opt.mode | 0o0700\n  const needChmod = (mode & umask) !== 0\n\n  const uid = opt.uid\n  const gid = opt.gid\n  const doChown = typeof uid === 'number' &&\n    typeof gid === 'number' &&\n    ( uid !== opt.processUid || gid !== opt.processGid )\n\n  const preserve = opt.preserve\n  const unlink = opt.unlink\n  const cache = opt.cache\n  const cwd = opt.cwd\n\n  const done = (created) => {\n    cache.set(dir, true)\n    if (created && doChown)\n      chownr.sync(created, uid, gid)\n    if (needChmod)\n      fs.chmodSync(dir, mode)\n  }\n\n  if (cache && cache.get(dir) === true)\n    return done()\n\n  if (dir === cwd) {\n    let ok = false\n    let code = 'ENOTDIR'\n    try {\n      ok = fs.statSync(dir).isDirectory()\n    } catch (er) {\n      code = er.code\n    } finally {\n      if (!ok)\n        throw new CwdError(dir, code)\n    }\n    done()\n    return\n  }\n\n  if (preserve)\n    return done(mkdirp.sync(dir, mode))\n\n  const sub = path.relative(cwd, dir)\n  const parts = sub.split(/\\/|\\\\/)\n  let created = null\n  for (let p = parts.shift(), part = cwd;\n       p && (part += '/' + p);\n       p = parts.shift()) {\n\n    if (cache.get(part))\n      continue\n\n    try {\n      fs.mkdirSync(part, mode)\n      created = created || part\n      cache.set(part, true)\n    } catch (er) {\n      if (er.path && path.dirname(er.path) === cwd &&\n          (er.code === 'ENOTDIR' || er.code === 'ENOENT'))\n        return new CwdError(cwd, er.code)\n\n      const st = fs.lstatSync(part)\n      if (st.isDirectory()) {\n        cache.set(part, true)\n        continue\n      } else if (unlink) {\n        fs.unlinkSync(part)\n        fs.mkdirSync(part, mode)\n        created = created || part\n        cache.set(part, true)\n        continue\n      } else if (st.isSymbolicLink())\n        return new SymlinkError(part, part + '/' + parts.join('/'))\n    }\n  }\n\n  return done(created)\n}\n"]},"metadata":{},"sourceType":"script"}