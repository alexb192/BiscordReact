{"ast":null,"code":"\"use strict\";\n\nmodule.exports = exports = install;\nexports.usage = 'Attempts to install pre-built binary for module';\n\nvar fs = require('fs');\n\nvar path = require('path');\n\nvar log = require('npmlog');\n\nvar existsAsync = fs.exists || path.exists;\n\nvar versioning = require('./util/versioning.js');\n\nvar napi = require('./util/napi.js');\n\nvar mkdirp = require('mkdirp');\n\nvar npgVersion = 'unknown';\n\ntry {\n  // Read own package.json to get the current node-pre-pyp version.\n  var ownPackageJSON = fs.readFileSync(path.join(__dirname, '..', 'package.json'), 'utf8');\n  npgVersion = JSON.parse(ownPackageJSON).version;\n} catch (e) {}\n\nvar http_get = {\n  impl: undefined,\n  type: undefined\n};\n\ntry {\n  http_get.impl = require('request');\n  http_get.type = 'request';\n  log.warn(\"Using request for node-pre-gyp https download\");\n} catch (e) {\n  http_get.impl = require('needle');\n  http_get.type = 'needle';\n  log.warn(\"Using needle for node-pre-gyp https download\");\n}\n\nfunction download(uri, opts, callback) {\n  log.http('GET', uri);\n  var req = null; // Try getting version info from the currently running npm.\n\n  var envVersionInfo = process.env.npm_config_user_agent || 'node ' + process.version;\n  var requestOpts = {\n    uri: uri.replace('+', '%2B'),\n    headers: {\n      'User-Agent': 'node-pre-gyp (v' + npgVersion + ', ' + envVersionInfo + ')'\n    },\n    follow_max: 10\n  };\n\n  if (opts.cafile) {\n    try {\n      requestOpts.ca = fs.readFileSync(opts.cafile);\n    } catch (e) {\n      return callback(e);\n    }\n  } else if (opts.ca) {\n    requestOpts.ca = opts.ca;\n  }\n\n  var proxyUrl = opts.proxy || process.env.http_proxy || process.env.HTTP_PROXY || process.env.npm_config_proxy;\n\n  if (proxyUrl) {\n    if (/^https?:\\/\\//i.test(proxyUrl)) {\n      log.verbose('download', 'using proxy url: \"%s\"', proxyUrl);\n      requestOpts.proxy = proxyUrl;\n    } else {\n      log.warn('download', 'ignoring invalid \"proxy\" config setting: \"%s\"', proxyUrl);\n    }\n  }\n\n  try {\n    req = http_get.impl.get(requestOpts.uri, requestOpts);\n  } catch (e) {\n    return callback(e);\n  }\n\n  if (req) {\n    req.on('response', function (res) {\n      log.http(res.statusCode, uri);\n    });\n  }\n\n  return callback(null, req);\n}\n\nfunction place_binary(from, to, opts, callback) {\n  download(from, opts, function (err, req) {\n    if (err) return callback(err);\n    if (!req) return callback(new Error(\"empty req\"));\n    var badDownload = false;\n    var hasResponse = false;\n\n    function afterExtract(err, extractCount) {\n      if (err) return callback(err);\n      if (badDownload) return callback(new Error(\"bad download\"));\n\n      if (extractCount === 0) {\n        return callback(new Error('There was a fatal problem while downloading/extracting the tarball'));\n      }\n\n      log.info('tarball', 'done parsing tarball');\n      callback();\n    } // for request compatibility\n\n\n    req.on('error', function (err) {\n      badDownload = true;\n\n      if (!hasResponse) {\n        hasResponse = true;\n        return callback(err);\n      }\n    }); // for needle compatibility\n\n    req.on('err', function (err) {\n      badDownload = true;\n\n      if (!hasResponse) {\n        hasResponse = true;\n        return callback(err);\n      }\n    });\n    req.on('close', function () {\n      if (!hasResponse) {\n        hasResponse = true;\n        return callback(new Error('Connection closed while downloading tarball file'));\n      }\n    });\n    req.on('response', function (res) {\n      // ignore redirects, needle handles these automatically.\n      if (http_get.type === 'needle' && res.headers.hasOwnProperty('location') && res.headers.location !== '') {\n        return;\n      }\n\n      if (hasResponse) {\n        return;\n      }\n\n      hasResponse = true;\n\n      if (res.statusCode !== 200) {\n        badDownload = true;\n        var err = new Error(res.statusCode + ' status code downloading tarball ' + from);\n        err.statusCode = res.statusCode;\n        return callback(err);\n      } // start unzipping and untaring\n\n\n      req.pipe(extract(to, afterExtract));\n    });\n  });\n}\n\nfunction extract_from_local(from, to, callback) {\n  if (!fs.existsSync(from)) {\n    return callback(new Error('Cannot find file ' + from));\n  }\n\n  log.info('Found local file to extract from ' + from);\n\n  function afterExtract(err, extractCount) {\n    if (err) return callback(err);\n\n    if (extractCount === 0) {\n      return callback(new Error('There was a fatal problem while extracting the tarball'));\n    }\n\n    log.info('tarball', 'done parsing tarball');\n    callback();\n  }\n\n  fs.createReadStream(from).pipe(extract(to, afterExtract));\n}\n\nfunction extract(to, callback) {\n  var extractCount = 0;\n\n  function filter_func(entry) {\n    log.info('install', 'unpacking ' + entry.path);\n    extractCount++;\n  }\n\n  function afterTarball(err) {\n    callback(err, extractCount);\n  }\n\n  var tar = require('tar');\n\n  return tar.extract({\n    cwd: to,\n    strip: 1,\n    onentry: filter_func\n  }).on('close', afterTarball).on('error', callback);\n}\n\nfunction do_build(gyp, argv, callback) {\n  var args = ['rebuild'].concat(argv);\n  gyp.todo.push({\n    name: 'build',\n    args: args\n  });\n  process.nextTick(callback);\n}\n\nfunction print_fallback_error(err, opts, package_json) {\n  var fallback_message = ' (falling back to source compile with node-gyp)';\n  var full_message = '';\n\n  if (err.statusCode !== undefined) {\n    // If we got a network response it but failed to download\n    // it means remote binaries are not available, so let's try to help\n    // the user/developer with the info to debug why\n    full_message = \"Pre-built binaries not found for \" + package_json.name + \"@\" + package_json.version;\n    full_message += \" and \" + opts.runtime + \"@\" + (opts.target || process.versions.node) + \" (\" + opts.node_abi + \" ABI, \" + opts.libc + \")\";\n    full_message += fallback_message;\n    log.warn(\"Tried to download(\" + err.statusCode + \"): \" + opts.hosted_tarball);\n    log.warn(full_message);\n    log.http(err.message);\n  } else {\n    // If we do not have a statusCode that means an unexpected error\n    // happened and prevented an http response, so we output the exact error\n    full_message = \"Pre-built binaries not installable for \" + package_json.name + \"@\" + package_json.version;\n    full_message += \" and \" + opts.runtime + \"@\" + (opts.target || process.versions.node) + \" (\" + opts.node_abi + \" ABI, \" + opts.libc + \")\";\n    full_message += fallback_message;\n    log.warn(full_message);\n    log.warn(\"Hit error \" + err.message);\n  }\n}\n\nfunction install(gyp, argv, callback) {\n  var package_json = JSON.parse(fs.readFileSync('./package.json'));\n  var napi_build_version = napi.get_napi_build_version_from_command_args(argv);\n  var source_build = gyp.opts['build-from-source'] || gyp.opts.build_from_source;\n  var update_binary = gyp.opts['update-binary'] || gyp.opts.update_binary;\n  var should_do_source_build = source_build === package_json.name || source_build === true || source_build === 'true';\n\n  if (should_do_source_build) {\n    log.info('build', 'requesting source compile');\n    return do_build(gyp, argv, callback);\n  } else {\n    var fallback_to_build = gyp.opts['fallback-to-build'] || gyp.opts.fallback_to_build;\n    var should_do_fallback_build = fallback_to_build === package_json.name || fallback_to_build === true || fallback_to_build === 'true'; // but allow override from npm\n\n    if (process.env.npm_config_argv) {\n      var cooked = JSON.parse(process.env.npm_config_argv).cooked;\n      var match = cooked.indexOf(\"--fallback-to-build\");\n\n      if (match > -1 && cooked.length > match && cooked[match + 1] == \"false\") {\n        should_do_fallback_build = false;\n        log.info('install', 'Build fallback disabled via npm flag: --fallback-to-build=false');\n      }\n    }\n\n    var opts;\n\n    try {\n      opts = versioning.evaluate(package_json, gyp.opts, napi_build_version);\n    } catch (err) {\n      return callback(err);\n    }\n\n    opts.ca = gyp.opts.ca;\n    opts.cafile = gyp.opts.cafile;\n    var from = opts.hosted_tarball;\n    var to = opts.module_path;\n    var binary_module = path.join(to, opts.module_name + '.node');\n    existsAsync(binary_module, function (found) {\n      if (found && !update_binary) {\n        console.log('[' + package_json.name + '] Success: \"' + binary_module + '\" already installed');\n        console.log('Pass --update-binary to reinstall or --build-from-source to recompile');\n        return callback();\n      } else {\n        if (!update_binary) log.info('check', 'checked for \"' + binary_module + '\" (not found)');\n        mkdirp(to, function (err) {\n          if (err) {\n            after_place(err);\n          } else {\n            var fileName = from.startsWith('file://') && from.replace(/^file:\\/\\//, '');\n\n            if (fileName) {\n              extract_from_local(fileName, to, after_place);\n            } else {\n              place_binary(from, to, opts, after_place);\n            }\n          }\n        });\n      }\n\n      function after_place(err) {\n        if (err && should_do_fallback_build) {\n          print_fallback_error(err, opts, package_json);\n          return do_build(gyp, argv, callback);\n        } else if (err) {\n          return callback(err);\n        } else {\n          console.log('[' + package_json.name + '] Success: \"' + binary_module + '\" is installed via remote');\n          return callback();\n        }\n      }\n    });\n  }\n}","map":{"version":3,"sources":["/home/n/React/loginpagedemo/frontend/node_modules/node-pre-gyp/lib/install.js"],"names":["module","exports","install","usage","fs","require","path","log","existsAsync","exists","versioning","napi","mkdirp","npgVersion","ownPackageJSON","readFileSync","join","__dirname","JSON","parse","version","e","http_get","impl","undefined","type","warn","download","uri","opts","callback","http","req","envVersionInfo","process","env","npm_config_user_agent","requestOpts","replace","headers","follow_max","cafile","ca","proxyUrl","proxy","http_proxy","HTTP_PROXY","npm_config_proxy","test","verbose","get","on","res","statusCode","place_binary","from","to","err","Error","badDownload","hasResponse","afterExtract","extractCount","info","hasOwnProperty","location","pipe","extract","extract_from_local","existsSync","createReadStream","filter_func","entry","afterTarball","tar","cwd","strip","onentry","do_build","gyp","argv","args","concat","todo","push","name","nextTick","print_fallback_error","package_json","fallback_message","full_message","runtime","target","versions","node","node_abi","libc","hosted_tarball","message","napi_build_version","get_napi_build_version_from_command_args","source_build","build_from_source","update_binary","should_do_source_build","fallback_to_build","should_do_fallback_build","npm_config_argv","cooked","match","indexOf","length","evaluate","module_path","binary_module","module_name","found","console","after_place","fileName","startsWith"],"mappings":"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","sourcesContent":["\"use strict\";\n\nmodule.exports = exports = install;\n\nexports.usage = 'Attempts to install pre-built binary for module';\n\nvar fs = require('fs');\nvar path = require('path');\nvar log = require('npmlog');\nvar existsAsync = fs.exists || path.exists;\nvar versioning = require('./util/versioning.js');\nvar napi = require('./util/napi.js');\nvar mkdirp = require('mkdirp');\n\nvar npgVersion = 'unknown';\ntry {\n    // Read own package.json to get the current node-pre-pyp version.\n    var ownPackageJSON = fs.readFileSync(path.join(__dirname, '..', 'package.json'), 'utf8');\n    npgVersion = JSON.parse(ownPackageJSON).version;\n} catch (e) {}\n\nvar http_get = {\n    impl: undefined,\n    type: undefined\n};\n\ntry {\n  http_get.impl = require('request');\n  http_get.type = 'request';\n  log.warn(\"Using request for node-pre-gyp https download\");\n} catch (e) {\n  http_get.impl = require('needle');\n  http_get.type = 'needle';\n  log.warn(\"Using needle for node-pre-gyp https download\");\n}\n\nfunction download(uri,opts,callback) {\n    log.http('GET', uri);\n\n    var req = null;\n\n    // Try getting version info from the currently running npm.\n    var envVersionInfo = process.env.npm_config_user_agent ||\n        'node ' + process.version;\n\n    var requestOpts = {\n        uri: uri.replace('+','%2B'),\n        headers: {\n          'User-Agent': 'node-pre-gyp (v' + npgVersion + ', ' + envVersionInfo + ')'\n        },\n        follow_max: 10,\n    };\n\n    if (opts.cafile) {\n        try {\n            requestOpts.ca = fs.readFileSync(opts.cafile);\n        } catch (e) {\n            return callback(e);\n        }\n    } else if (opts.ca) {\n        requestOpts.ca = opts.ca;\n    }\n\n    var proxyUrl = opts.proxy ||\n                    process.env.http_proxy ||\n                    process.env.HTTP_PROXY ||\n                    process.env.npm_config_proxy;\n    if (proxyUrl) {\n      if (/^https?:\\/\\//i.test(proxyUrl)) {\n        log.verbose('download', 'using proxy url: \"%s\"', proxyUrl);\n        requestOpts.proxy = proxyUrl;\n      } else {\n        log.warn('download', 'ignoring invalid \"proxy\" config setting: \"%s\"', proxyUrl);\n      }\n    }\n    try {\n        req = http_get.impl.get(requestOpts.uri, requestOpts);\n    } catch (e) {\n        return callback(e);\n    }\n    if (req) {\n      req.on('response', function (res) {\n        log.http(res.statusCode, uri);\n      });\n    }\n    return callback(null,req);\n}\n\nfunction place_binary(from,to,opts,callback) {\n    download(from,opts,function(err,req) {\n        if (err) return callback(err);\n        if (!req) return callback(new Error(\"empty req\"));\n        var badDownload = false;\n        var hasResponse = false;\n\n        function afterExtract(err, extractCount) {\n            if (err) return callback(err);\n            if (badDownload) return callback(new Error(\"bad download\"));\n            if (extractCount === 0) {\n                return callback(new Error('There was a fatal problem while downloading/extracting the tarball'));\n            }\n            log.info('tarball', 'done parsing tarball');\n            callback();\n        }\n\n        // for request compatibility\n        req.on('error', function(err) {\n            badDownload = true;\n            if (!hasResponse) {\n                hasResponse = true;\n                return callback(err);\n            }\n        });\n\n        // for needle compatibility\n        req.on('err', function(err) {\n            badDownload = true;\n            if (!hasResponse) {\n                hasResponse = true;\n                return callback(err);\n            }\n        });\n\n        req.on('close', function () {\n            if (!hasResponse) {\n                hasResponse = true;\n                return callback(new Error('Connection closed while downloading tarball file'));\n            }\n        });\n\n      req.on('response', function(res) {\n            // ignore redirects, needle handles these automatically.\n            if (http_get.type === 'needle' && res.headers.hasOwnProperty('location') && res.headers.location !== '') {\n                return;\n            }\n            if (hasResponse) {\n                return;\n            }\n            hasResponse = true;\n            if (res.statusCode !== 200) {\n                badDownload = true;\n                var err = new Error(res.statusCode + ' status code downloading tarball ' + from);\n                err.statusCode = res.statusCode;\n                return callback(err);\n            }\n            // start unzipping and untaring\n            req.pipe(extract(to, afterExtract));\n        });\n    });\n}\n\nfunction extract_from_local(from, to, callback) {\n    if (!fs.existsSync(from)) {\n        return callback(new Error('Cannot find file ' + from));\n    }\n    log.info('Found local file to extract from ' + from);\n    function afterExtract(err, extractCount) {\n        if (err) return callback(err);\n        if (extractCount === 0) {\n            return callback(new Error('There was a fatal problem while extracting the tarball'));\n        }\n        log.info('tarball', 'done parsing tarball');\n        callback();\n    }\n    fs.createReadStream(from).pipe(extract(to, afterExtract));\n}\n\nfunction extract(to, callback) {\n    var extractCount = 0;\n    function filter_func(entry) {\n        log.info('install','unpacking ' + entry.path);\n        extractCount++;\n    }\n\n    function afterTarball(err) {\n        callback(err, extractCount);\n    }\n\n    var tar = require('tar');\n    return tar.extract({\n        cwd: to,\n        strip: 1,\n        onentry: filter_func\n    }).on('close', afterTarball).on('error', callback);\n}\n\n\nfunction do_build(gyp,argv,callback) {\n  var args = ['rebuild'].concat(argv);\n  gyp.todo.push( { name: 'build', args: args } );\n  process.nextTick(callback);\n}\n\nfunction print_fallback_error(err,opts,package_json) {\n    var fallback_message = ' (falling back to source compile with node-gyp)';\n    var full_message = '';\n    if (err.statusCode !== undefined) {\n        // If we got a network response it but failed to download\n        // it means remote binaries are not available, so let's try to help\n        // the user/developer with the info to debug why\n        full_message = \"Pre-built binaries not found for \" + package_json.name + \"@\" + package_json.version;\n        full_message += \" and \" + opts.runtime + \"@\" + (opts.target || process.versions.node) + \" (\" + opts.node_abi + \" ABI, \" + opts.libc + \")\";\n        full_message += fallback_message;\n        log.warn(\"Tried to download(\" + err.statusCode + \"): \" + opts.hosted_tarball);\n        log.warn(full_message);\n        log.http(err.message);\n    } else {\n        // If we do not have a statusCode that means an unexpected error\n        // happened and prevented an http response, so we output the exact error\n        full_message = \"Pre-built binaries not installable for \" + package_json.name + \"@\" + package_json.version;\n        full_message += \" and \" + opts.runtime + \"@\" + (opts.target || process.versions.node) + \" (\" + opts.node_abi + \" ABI, \" + opts.libc + \")\";\n        full_message += fallback_message;\n        log.warn(full_message);\n        log.warn(\"Hit error \" + err.message);\n    }\n}\n\nfunction install(gyp, argv, callback) {\n    var package_json = JSON.parse(fs.readFileSync('./package.json'));\n\tvar napi_build_version = napi.get_napi_build_version_from_command_args(argv);\n    var source_build = gyp.opts['build-from-source'] || gyp.opts.build_from_source;\n    var update_binary = gyp.opts['update-binary'] || gyp.opts.update_binary;\n    var should_do_source_build = source_build === package_json.name || (source_build === true || source_build === 'true');\n    if (should_do_source_build) {\n        log.info('build','requesting source compile');\n        return do_build(gyp,argv,callback);\n    } else {\n        var fallback_to_build = gyp.opts['fallback-to-build'] || gyp.opts.fallback_to_build;\n        var should_do_fallback_build = fallback_to_build === package_json.name || (fallback_to_build === true || fallback_to_build === 'true');\n        // but allow override from npm\n        if (process.env.npm_config_argv) {\n            var cooked = JSON.parse(process.env.npm_config_argv).cooked;\n            var match = cooked.indexOf(\"--fallback-to-build\");\n            if (match > -1 && cooked.length > match && cooked[match+1] == \"false\") {\n                should_do_fallback_build = false;\n                log.info('install','Build fallback disabled via npm flag: --fallback-to-build=false');\n            }\n        }\n        var opts;\n        try {\n            opts = versioning.evaluate(package_json, gyp.opts, napi_build_version);\n        } catch (err) {\n            return callback(err);\n        }\n\n        opts.ca = gyp.opts.ca;\n        opts.cafile = gyp.opts.cafile;\n\n        var from = opts.hosted_tarball;\n        var to = opts.module_path;\n        var binary_module = path.join(to,opts.module_name + '.node');\n        existsAsync(binary_module,function(found) {\n            if (found && !update_binary) {\n                console.log('['+package_json.name+'] Success: \"' + binary_module + '\" already installed');\n                console.log('Pass --update-binary to reinstall or --build-from-source to recompile');\n                return callback();\n            } else {\n                if (!update_binary) log.info('check','checked for \"' + binary_module + '\" (not found)');\n                mkdirp(to,function(err) {\n                    if (err) {\n                        after_place(err);\n                    } else {\n                        var fileName = from.startsWith('file://') && from.replace(/^file:\\/\\//, '');\n                        if (fileName) {\n                            extract_from_local(fileName, to, after_place);\n                        } else {\n                            place_binary(from,to,opts,after_place);\n                        }\n                    }\n                });\n            }\n            function after_place(err) {\n                if (err && should_do_fallback_build) {\n                    print_fallback_error(err,opts,package_json);\n                    return do_build(gyp,argv,callback);\n                } else if (err) {\n                    return callback(err);\n                } else {\n                    console.log('['+package_json.name+'] Success: \"' + binary_module + '\" is installed via remote');\n                    return callback();\n                }\n            }\n        });\n    }\n}\n"]},"metadata":{},"sourceType":"script"}