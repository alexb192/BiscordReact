{"ast":null,"code":"'use strict'; // Tar can encode large and negative numbers using a leading byte of\n// 0xff for negative, and 0x80 for positive.\n\nconst encode = exports.encode = (num, buf) => {\n  if (!Number.isSafeInteger(num)) // The number is so large that javascript cannot represent it with integer\n    // precision.\n    throw TypeError('cannot encode number outside of javascript safe integer range');else if (num < 0) encodeNegative(num, buf);else encodePositive(num, buf);\n  return buf;\n};\n\nconst encodePositive = (num, buf) => {\n  buf[0] = 0x80;\n\n  for (var i = buf.length; i > 1; i--) {\n    buf[i - 1] = num & 0xff;\n    num = Math.floor(num / 0x100);\n  }\n};\n\nconst encodeNegative = (num, buf) => {\n  buf[0] = 0xff;\n  var flipped = false;\n  num = num * -1;\n\n  for (var i = buf.length; i > 1; i--) {\n    var byte = num & 0xff;\n    num = Math.floor(num / 0x100);\n    if (flipped) buf[i - 1] = onesComp(byte);else if (byte === 0) buf[i - 1] = 0;else {\n      flipped = true;\n      buf[i - 1] = twosComp(byte);\n    }\n  }\n};\n\nconst parse = exports.parse = buf => {\n  var post = buf[buf.length - 1];\n  var pre = buf[0];\n  var value;\n  if (pre === 0x80) value = pos(buf.slice(1, buf.length));else if (pre === 0xff) value = twos(buf);else throw TypeError('invalid base256 encoding');\n  if (!Number.isSafeInteger(value)) // The number is so large that javascript cannot represent it with integer\n    // precision.\n    throw TypeError('parsed number outside of javascript safe integer range');\n  return value;\n};\n\nconst twos = buf => {\n  var len = buf.length;\n  var sum = 0;\n  var flipped = false;\n\n  for (var i = len - 1; i > -1; i--) {\n    var byte = buf[i];\n    var f;\n    if (flipped) f = onesComp(byte);else if (byte === 0) f = byte;else {\n      flipped = true;\n      f = twosComp(byte);\n    }\n    if (f !== 0) sum -= f * Math.pow(256, len - i - 1);\n  }\n\n  return sum;\n};\n\nconst pos = buf => {\n  var len = buf.length;\n  var sum = 0;\n\n  for (var i = len - 1; i > -1; i--) {\n    var byte = buf[i];\n    if (byte !== 0) sum += byte * Math.pow(256, len - i - 1);\n  }\n\n  return sum;\n};\n\nconst onesComp = byte => (0xff ^ byte) & 0xff;\n\nconst twosComp = byte => (0xff ^ byte) + 1 & 0xff;","map":{"version":3,"sources":["/home/n/React/loginpagedemo/frontend/node_modules/tar/lib/large-numbers.js"],"names":["encode","exports","num","buf","Number","isSafeInteger","TypeError","encodeNegative","encodePositive","i","length","Math","floor","flipped","byte","onesComp","twosComp","parse","post","pre","value","pos","slice","twos","len","sum","f","pow"],"mappings":"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","sourcesContent":["'use strict'\n// Tar can encode large and negative numbers using a leading byte of\n// 0xff for negative, and 0x80 for positive.\n\nconst encode = exports.encode = (num, buf) => {\n  if (!Number.isSafeInteger(num))\n    // The number is so large that javascript cannot represent it with integer\n    // precision.\n    throw TypeError('cannot encode number outside of javascript safe integer range')\n  else if (num < 0)\n    encodeNegative(num, buf)\n  else\n    encodePositive(num, buf)\n  return buf\n}\n\nconst encodePositive = (num, buf) => {\n  buf[0] = 0x80\n\n  for (var i = buf.length; i > 1; i--) {\n    buf[i-1] = num & 0xff\n    num = Math.floor(num / 0x100)\n  }\n}\n\nconst encodeNegative = (num, buf) => {\n  buf[0] = 0xff\n  var flipped = false\n  num = num * -1\n  for (var i = buf.length; i > 1; i--) {\n    var byte = num & 0xff\n    num = Math.floor(num / 0x100)\n    if (flipped)\n      buf[i-1] = onesComp(byte)\n    else if (byte === 0)\n      buf[i-1] = 0\n    else {\n      flipped = true\n      buf[i-1] = twosComp(byte)\n    }\n  }\n}\n\nconst parse = exports.parse = (buf) => {\n  var post = buf[buf.length - 1]\n  var pre = buf[0]\n  var value;\n  if (pre === 0x80)\n    value = pos(buf.slice(1, buf.length))\n  else if (pre === 0xff)\n    value = twos(buf)\n  else\n    throw TypeError('invalid base256 encoding')\n\n  if (!Number.isSafeInteger(value))\n    // The number is so large that javascript cannot represent it with integer\n    // precision.\n    throw TypeError('parsed number outside of javascript safe integer range')\n\n  return value\n}\n\nconst twos = (buf) => {\n  var len = buf.length\n  var sum = 0\n  var flipped = false\n  for (var i = len - 1; i > -1; i--) {\n    var byte = buf[i]\n    var f\n    if (flipped)\n      f = onesComp(byte)\n    else if (byte === 0)\n      f = byte\n    else {\n      flipped = true\n      f = twosComp(byte)\n    }\n    if (f !== 0)\n      sum -= f * Math.pow(256, len - i - 1)\n  }\n  return sum\n}\n\nconst pos = (buf) => {\n  var len = buf.length\n  var sum = 0\n  for (var i = len - 1; i > -1; i--) {\n    var byte = buf[i]\n    if (byte !== 0)\n      sum += byte * Math.pow(256, len - i - 1)\n  }\n  return sum\n}\n\nconst onesComp = byte => (0xff ^ byte) & 0xff\n\nconst twosComp = byte => ((0xff ^ byte) + 1) & 0xff\n"]},"metadata":{},"sourceType":"script"}